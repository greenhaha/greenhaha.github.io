<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>彼方のE栈</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2024-01-02T01:33:13.066Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>境界の彼方</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>流媒体协议-DASH</title>
    <link href="http://example.com/2024/01/05/%E6%B5%81%E5%AA%92%E4%BD%93%E5%8D%8F%E8%AE%AE-DASH/"/>
    <id>http://example.com/2024/01/05/%E6%B5%81%E5%AA%92%E4%BD%93%E5%8D%8F%E8%AE%AE-DASH/</id>
    <published>2024-01-05T02:11:51.000Z</published>
    <updated>2024-01-02T01:33:13.066Z</updated>
    
    <content type="html"><![CDATA[<h1 id="流媒体协议-DASH"><a href="#流媒体协议-DASH" class="headerlink" title="流媒体协议-DASH"></a>流媒体协议-DASH</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>除了前面讲的 Apple 的 HLS，还有 Adobe HTTP Dynamic Streaming (HDS)、Microsoft Smooth Streaming (MSS)。他们各家的协议原理大致相同，但是格式又不一样，也无法兼容，所以 Moving Picture Expert Group (MPEG) 就把大家叫到了一起，呼吁大家一起来制定一个标准的，然后就有了<a href="https://www.encoding.com/mpeg-dash/">MPEG-DASH</a>,它的主要目标是形成 IP 网络承载单一格式的流媒体并提供高效与高质量服务的统一方案，解决多制式传输方案(HTTP Live Streaming, Microsoft Smooth Streaming, HTTP Dynamic Streaming)并存格局下的存储与服务能力浪费、运营高成本与复杂度、系统间互操作弱等问题。</p><p><a href="https://mpeg.chiariglione.org/standards/mpeg-dash/">DASH(MPEG-DASH)</a>全称为 Dynamic Adaptive Streaming over HTTP.是由 MPEG 和 ISO 批准的独立于供应商的国际标准，它是一种基于 HTTP 的使用 TCP 传输协议的流媒体传输技术。它诞生的目的是为了统一标准，因此是兼容 SmoothStreaming 和 HLS 的.同时支持 TS profile 和 ISO profile，支持节目观看等级控制，支持父母锁. mpeg dash 支持的 DRM 类型包括 PlayReady 和 Marlin，而 HLS 支持的是 AES128（密钥长度为 128 位的高级加密标准 Advanced Encryption Standard）加密类型。</p><p>MPEG-DASH 是一种自适应比特率流技术，可根据实时网络状况实现动态自适应下载。和 HLS, HDS 技术类似， 都是把视频分割成一小段一小段， 通过 HTTP 协议进行传输，客户端得到之后进行播放；不同的是 MPEG-DASH 支持 MPEG-2 TS、MP4(最新的 HLS 也支持了 MP4)等多种格式, 可以将视频按照多种编码切割, 下载下来的媒体格式既可以是 ts 文件也可以是 mp4 文件，MPEG—DASH 技术与编解码器无关，可使用 H.265，H.264，VP9 等任何编解码器进行编码。</p><p>安卓平台上的 ExoPlayer 支持 MPEG-DASH。另外，三星、索尼、飞利浦、松下的一些较新型号的智能电视支持 MPEG—DASH。Google 的 Chromecast、YouTube 和 Netflix 也已支持 MPEG-DASH。</p><p><img src="https://raw.githubusercontent.com/CharonChui/Pictures/master/dash_compare.png" alt="dash_compare"></p><p>HLS 在 16 年支持了 fmp4，在 17 年支持了 4K。</p><h3 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h3><p><img src="https://raw.githubusercontent.com/CharonChui/Pictures/master/dash_main_idea.png" alt="dash_main_idea"></p><p>DASH 的核心思想是，在服务端，视频被提前编好多种码率，并且被切成固定长度的视频片段，存放到 HTTP 服务器中，当客户端播放时，通过 HTTP 请求向服务器请求视频切片，并根据网络状况的变化，请求相应质量的视频切片，从而达到对网络带宽的最大利用，并且保证播放流畅。可以实现不同画质内容无缝切换。所以在 YouTube 切换画质时完全不会黑屏，更不会影响观看。</p><p><img src="https://raw.githubusercontent.com/CharonChui/Pictures/master/a_dash_scenario.png" alt="image-20200406163508642"></p><p>DASH 的整个流程:</p><p>内容生成服务器(编码模块、封装模块) -&gt; 流媒体服务器(MPD、媒体文件、HTTP 服务器) &lt;-&gt; DASH 客户端(控制引擎、媒体引擎、HTTP 接入容器)</p><p><img src="https://raw.githubusercontent.com/CharonChui/Pictures/master/mpd_hierarchical_data.png" alt="image-20200406164238038"></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; standalone=&quot;yes&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">MPD</span> <span class="attr">id</span>=<span class="string">&quot;0564e940-122b-42bb-9d56-98f3def67247&quot;</span> <span class="attr">profiles</span>=<span class="string">&quot;urn:mpeg:dash:profile:isoff-main:2011&quot;</span> <span class="attr">type</span>=<span class="string">&quot;static&quot;</span> <span class="attr">availabilityStartTime</span>=<span class="string">&quot;2016-01-14T09:30:35.000Z&quot;</span> <span class="attr">publishTime</span>=<span class="string">&quot;2016-01-14T09:31:33.000Z&quot;</span> <span class="attr">mediaPresentationDuration</span>=<span class="string">&quot;P0Y0M0DT0H2M17.000S&quot;</span> <span class="attr">minBufferTime</span>=<span class="string">&quot;P0Y0M0DT0H0M1.000S&quot;</span> <span class="attr">bitmovin:version</span>=<span class="string">&quot;1.6.0&quot;</span> <span class="attr">xmlns:ns2</span>=<span class="string">&quot;http://www.w3.org/1999/xlink&quot;</span> <span class="attr">xmlns</span>=<span class="string">&quot;urn:mpeg:dash:schema:mpd:2011&quot;</span> <span class="attr">xmlns:bitmovin</span>=<span class="string">&quot;http://www.bitmovin.net/mpd/2015&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Period</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">AdaptationSet</span> <span class="attr">mimeType</span>=<span class="string">&quot;video/mp4&quot;</span> <span class="attr">codecs</span>=<span class="string">&quot;avc1.42c00d&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">SegmentTemplate</span> <span class="attr">media</span>=<span class="string">&quot;../video/$RepresentationID$/dash/segment_$Number$.m4s&quot;</span> <span class="attr">initialization</span>=<span class="string">&quot;../video/$RepresentationID$/dash/init.mp4&quot;</span> <span class="attr">duration</span>=<span class="string">&quot;120119&quot;</span> <span class="attr">startNumber</span>=<span class="string">&quot;0&quot;</span> <span class="attr">timescale</span>=<span class="string">&quot;30000&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Representation</span> <span class="attr">id</span>=<span class="string">&quot;1920_9000000&quot;</span> <span class="attr">bandwidth</span>=<span class="string">&quot;9000000&quot;</span> <span class="attr">width</span>=<span class="string">&quot;3840&quot;</span> <span class="attr">height</span>=<span class="string">&quot;1920&quot;</span> <span class="attr">frameRate</span>=<span class="string">&quot;30&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Representation</span> <span class="attr">id</span>=<span class="string">&quot;1080_5000000&quot;</span> <span class="attr">bandwidth</span>=<span class="string">&quot;5000000&quot;</span> <span class="attr">width</span>=<span class="string">&quot;2160&quot;</span> <span class="attr">height</span>=<span class="string">&quot;1080&quot;</span> <span class="attr">frameRate</span>=<span class="string">&quot;30&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Representation</span> <span class="attr">id</span>=<span class="string">&quot;720_3000000&quot;</span> <span class="attr">bandwidth</span>=<span class="string">&quot;3000000&quot;</span> <span class="attr">width</span>=<span class="string">&quot;1440&quot;</span> <span class="attr">height</span>=<span class="string">&quot;720&quot;</span> <span class="attr">frameRate</span>=<span class="string">&quot;30&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Representation</span> <span class="attr">id</span>=<span class="string">&quot;540_1500000&quot;</span> <span class="attr">bandwidth</span>=<span class="string">&quot;1500000&quot;</span> <span class="attr">width</span>=<span class="string">&quot;1080&quot;</span> <span class="attr">height</span>=<span class="string">&quot;540&quot;</span> <span class="attr">frameRate</span>=<span class="string">&quot;30&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Representation</span> <span class="attr">id</span>=<span class="string">&quot;360_1000000&quot;</span> <span class="attr">bandwidth</span>=<span class="string">&quot;1000000&quot;</span> <span class="attr">width</span>=<span class="string">&quot;720&quot;</span> <span class="attr">height</span>=<span class="string">&quot;360&quot;</span> <span class="attr">frameRate</span>=<span class="string">&quot;30&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">AdaptationSet</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">AdaptationSet</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span> <span class="attr">mimeType</span>=<span class="string">&quot;audio/mp4&quot;</span> <span class="attr">codecs</span>=<span class="string">&quot;mp4a.40.2&quot;</span> <span class="attr">bitmovin:label</span>=<span class="string">&quot;english stereo&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">AudioChannelConfiguration</span> <span class="attr">schemeIdUri</span>=<span class="string">&quot;urn:mpeg:dash:23003:3:audio_channel_configuration:2011&quot;</span> <span class="attr">value</span>=<span class="string">&quot;2&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">SegmentTemplate</span> <span class="attr">media</span>=<span class="string">&quot;../audio/$RepresentationID$/dash/segment_$Number$.m4s&quot;</span> <span class="attr">initialization</span>=<span class="string">&quot;../audio/$RepresentationID$/dash/init.mp4&quot;</span> <span class="attr">duration</span>=<span class="string">&quot;191472&quot;</span> <span class="attr">startNumber</span>=<span class="string">&quot;0&quot;</span> <span class="attr">timescale</span>=<span class="string">&quot;48000&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Representation</span> <span class="attr">id</span>=<span class="string">&quot;1_stereo_128000&quot;</span> <span class="attr">bandwidth</span>=<span class="string">&quot;128000&quot;</span> <span class="attr">audioSamplingRate</span>=<span class="string">&quot;48000&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">AdaptationSet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">Period</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">MPD</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="MPD"><a href="#MPD" class="headerlink" title="MPD"></a>MPD</h4><p>DASH 采用 3GPP AHS 中定义的 MPD(Media Presentation Description)作为媒体文件的描述文件（manifest），作用类似 HLS 的 m3u8 文件。MPD 文件以 XML 格式组织，用于描述 segment 的信息，比如时间、url、视频分辨率、码率等。<br>DASH 会通过 media presentation description (MPD)将视频内容切片成一个很短的文件片段，每个切片都有多个不同的码率，DASH Client 可以根据网络的情况选择一个码率进行播放，支持在不同码率之间无缝切换。<br>DASH 中的重要概念</p><h4 id="Period"><a href="#Period" class="headerlink" title="Period"></a>Period</h4><p>标注了视频的时长信息，也可以看做是更新 mpd 文件的最长时长，MPD 文件包含一个或者多个片段(Period)，它表示时间轴上的一段时间，每个片段都有一个起始时间和结束时间，并且包含了一个或者多个适配集合(Adaptation Set)。每个适配集合提供了一个或者多个媒体组件的信息，并包含了多种不同的码率。每个适配集合又是由多个呈现(Representation)组成，每个呈现就是同一个视频的不同特征的版本，如码率、分辨率等特征。由于每个的视频都要被切成固定长度的切片，因此每个呈现包括多个视频切片(Segment)，每个视频切片都有一个 URL 地址，这样客户端就可以通过这个地址向服务器发送 HTTP GET 请求获取该片段。同一个 Period 内，意味着可用的媒体内容及其各个可用码率（Representation）不会发生变更。直播情况下，“可能”需要周期地去服务器更新 MPD 文件，服务器可能会移除旧的已经过时的 Period,或是添加新的 Period。新的 Period 中可能会添加新的可用码率或去掉上一个 Period 中存在的某些码率(Representation)。</p><h4 id="Adaptation-Set"><a href="#Adaptation-Set" class="headerlink" title="Adaptation Set"></a>Adaptation Set</h4><p>包含了媒体呈现的形式，（视频/音频/字幕）。 一个 Period 由一个或者多个 Adaptationset 组成。Adaptationset 由一组可供切换的不同码率的码流（Representation)组成，这些码流中可能包含一个（ISO profile)或者多个(TS profile)media content components，因为 ISO profile 的 mp4 或者 fmp4 segment 中通常只含有一个视频或者音频内容，而 TS profile 中的 TS segment 同时含有视频和音频内容，当同时含有多个 media component content 时，每个被复用的 media content component 将被单独描述</p><h4 id="Representation"><a href="#Representation" class="headerlink" title="Representation"></a>Representation</h4><p>包含不同的码率、编码方式、帧率信息等。每个 Adaptationset 包含了一个或者多个 Representations,一个 Representation 包含一个或者多个 media streams，每个 media stream 对应一个 media content component。为了适应不同的网络带宽，实际播放的时候，视频会在一个 AdaptationSet 中的不同 Representaiton 之间切换码率，可能会从一个 Representation 切换到另外一个 Representation，会依次请求该 Representaiton 下不同 Segment 序列。</p><h4 id="Segments"><a href="#Segments" class="headerlink" title="Segments"></a>Segments</h4><p>每一个具体的片段。（1,2,4,6,10s …） Segments 可以包含任何媒体数据，关于容器，官方提供了两种建议: ISO base media file format(比如 MP4 文件格式)和 MPEG-2 Transport Stream。</p><p>每个 Representation 会划分为多个 Segment。Segment 分为 4 类，其中，最重要的是：Initialization Segment（每个 Representation 都包含 1 个 Init Seg），Media Segment（每个 Representation 的媒体内容包含若干 Media Seg）</p><ul><li><p>Initialization Segment：</p><p>Representation 的 Segments 一般都采用 1 个 Init Segment+多个普通 Segment 的方式，还有一种形式就是 Self Initialize Segment，这种形式没有单独的 Init Segment，初始化信息包括在了各个 Segment 中。Init Segment 中包含了解封装需要的全部信息，比如 Representation 中有哪些音视频流，各自的编码格式及参数。对于 ISO profile 来说(容器为 MP4)，包含了 moov box,H264 的 sps/pps 数据等关键信息存放于此（avCc box）。另外，同一个 Adaptation set 的多个 Representation 还可能共享同一个 Init Segment，该种情况下，对于 ISO profile 来说，诸如 stsd box，avCc box 等重要的 box 会含有多个 entry，每个 entry 对应一个 Representation，第一个 entry 对应第一个 Representation，第二个 entry 对应第二个 Representation，以此类推。</p></li><li><p>Subsegment</p><p>Segment 可能进一步划分为 subsegment，每个 subsegment 由数个 Acess Unit 组成，Segment index 提供了 subsegment 相对于 Segment 的字节范围和 presentation time range 。客户端可以先下载 Segment index。</p><p><code>*_init.mp4</code>: 初始的 mp4 文件，相当于视频头，在这个头文件中包含了完整的视频元信息(moov)，具体的可以使用 <code>MP4Box  -info</code> 查看。</p><p><code>*.m4s</code>: 即上面提到的 Segments 文件，每个 m4s 仅包含媒体信息 (moof + mdat)，而播放器是不能直接播放这个文件的，需要用支持 DASH 的播放器从 init 文件开始播放。</p></li></ul><p>确切的说，当 Adaptation set 的属性@segmentAlignment 为真（true）时，同一个 Adaptation set 中的多个 Representation 之中的媒体段是对齐的，因此，当从一个 Representation A 切换到另一个 Representation B 时，若 Representation A 的第 N 个媒体段已经下载完成，切换时可直接下载 Representation B 的第 N+1 个媒体段。</p><p>DASH 对媒体段定义了三种方式：</p><p>BaseURL：单段表示</p><p>SegmentList：段列表</p><p>SegmentTemplate：段模板</p><p>单段表示是最简单的：每个 Representation 只有一个媒体段。用 BaseURL 表示。举例如下：</p><h4 id="SAP-和无缝切换以及-SEEK"><a href="#SAP-和无缝切换以及-SEEK" class="headerlink" title="SAP 和无缝切换以及 SEEK"></a>SAP 和无缝切换以及 SEEK</h4><p>SAP：Stream Acess Point，可以简单理解为 I 帧，每个 Segment 的第一个帧都是 SAP，因此 Seek 时可直接 Seek 到某一个 Segment 的起始位置，利用 Init Segment+Seek 到的某个 Segment 的数据，在解封装后可实现完美解码。一般来说，同一个 Adaptation set 中的多个 Representation 是 Segment Align 的（当 Adaptation set 的属性@segmentAlignment 不为 false 时），因此，当从 Representation A 切换到 Representation B 时，如果当前 Representation A 的第 N 个 Segment 已经下载完成，切换时直接下载 Representation B 的第 N+1 个 Segment 即可。</p><p>码率自适应切换算法</p><ul><li>基于带宽的码率自适应切换算法</li><li>基于缓存的码率自适应切换算法</li></ul><p><img src="https://raw.githubusercontent.com/CharonChui/Pictures/master/dash_change_compare.png" alt="image-20200406165443536"></p><p>此基于时间缓存的码率自适应算法对网络带宽变化反应敏感，能够有效的提高平均码率，但同时码率切换次数过大，尤其是在网络状况波动很大的情况下，这势必会造成用户体验的下降。</p><ul><li><p>MSS 拥有最高的平均码率和较少的切换次数</p></li><li><p>HLS 的切换次数最少，但是以最低的平均码率作为代价</p></li><li><p>HDS 不能保证流程的播放</p></li><li><p>DASH 有足够的竞争力，也具有巨大的提升空间。</p></li></ul><h3 id="为什么使用-DASH"><a href="#为什么使用-DASH" class="headerlink" title="为什么使用 DASH"></a>为什么使用 DASH</h3><ul><li><p>DASH 支持多种编码，支持 H.265、H.264、VP9 等。</p></li><li><p>DASH 支持 MultiDRM，支持 PlayReady、Widewine，采用通用加密技术，支持终端自带 DRM，可以大幅度降低 DRM 投资成本。</p></li><li><p>DASH 支持多种文件封装，支持 MPEG-4、MPEG-2 TS。</p></li><li><p>DASH 支持多种 CDN 对接，采用相同的封装描述对接多厂家 CDN。</p></li><li><p>DASH 支持直播、点播、录制等丰富的视频特性。</p></li><li><p>DASH 支持动态码率适配 Adaptive Bitrate (ABR) ，支持多码率平滑切换。</p></li><li><p>DASH 支持缩略型描述以支持快速启动。</p></li></ul><h4 id="HLS-vs-DASH"><a href="#HLS-vs-DASH" class="headerlink" title="HLS vs DASH"></a>HLS vs DASH</h4><ul><li>在标准 HTTP 服务器上的用法： HLS 和 DASH 均可在常规 HTTP 服务器（例如 Nginx，Apache 等）上使用。</li><li>多个音频通道: 特别是对于多语言内容，重要的是能够在各个语言的不同音频通道之间进行切换。 DASH 和 HLS 都可以做到这一点。</li><li>字幕和标题: 为了给视频添加字幕，通常创建一个单独的文件，例如，文件可以具有 WebVTT 格式。然后从清单（即.m3u8 或.mpd 文件）中引用该文件。</li><li>插入广告: 通常，可以在 HLS 和 DASH 的实时流中插入广告。为此，只需交换单个视频块。 DASH 为此提供了一种有效的方法：标准化的界面允许有效地插入广告。</li><li>快速频道切换: 您可以在各个通道之间切换的速度取决于最大的子段（块）。块越小，通道更改速度越快。正如引言中已经提到的，HLS 块通常长约 10 秒，而 DASH 块通常长 2 至 4 秒。因此，DASH 在这方面领先一步。小块还具有降低代码效率的缺点。具有较小块的播放列表必须比具有较大块的播放列表更频繁地更新。这意味着包含较短视频片段的播放列表必须通过 HTTP 更频繁地更新。</li></ul><h2 id="结构与编码"><a href="#结构与编码" class="headerlink" title="结构与编码"></a><strong>结构与编码</strong></h2><p>MPEG-DASH 支持 TS 和 MP4 / ISO BMFF 媒体段。HLS 只支持 MPEG-2 TS。DASH 媒体段通常比 HLS 短，2 至 4 秒比较常见。DASH 不需要特定的编解码器。视频可以使用 H264 编码，也可以用其他编码，VP9 和 H265 也是比较受欢迎的编码。</p><p>一般而言，与 HLS 相比，DASH 可以提供实质上更低的端对端延迟。这对于现场直播的工作流程很重要。此外， MPEG-DASH 的基于模板的 MPD 不需要更新，可以在网络边缘服务器进行缓存，HLS 则需要周期性地更新传播多次。</p><p>DASH 支持索引和基于时间的模版，播放器能够基于公开的时钟，如 NTPS，进行同步。这对于多相机的情况下，多个播放器之间同步会比较容易。</p><h2 id="DRM"><a href="#DRM" class="headerlink" title="DRM"></a><strong>DRM</strong></h2><p>DASH 和 HLS 之间的另一个关键区别是它支持 DRM。可是，在 DASH 中不存在一个单一通用的 DRM 解决方案。例如，Google 的 Chrome 支持 Widevine，而 Microsoft 的 Internet Explorer 支持 PlayReady。然而，通过使用 MPEG-CENC（MPEG 通用加密）结合加密媒体扩展（EME），视频流内容可以仅被加密一次。HLS 支持 AES-128 加密，以及苹果自己的 DRM，Fairplay。</p><h4 id="测试流"><a href="#测试流" class="headerlink" title="测试流"></a>测试流</h4><ul><li><p>HEVC HLS with fMP4: <a href="https://bitmovin-a.akamaihd.net/content/dataset/multi-codec/hevc/stream_fmp4.m3u8">http://bitmovin-a.akamaihd.net/content/dataset/multi-codec/hevc/stream_fmp4.m3u8</a></p></li><li><p>HEVC HLS with TS (not supported by Apple): <a href="https://bitmovin-a.akamaihd.net/content/dataset/multi-codec/hevc/stream_ts.m3u8">http://bitmovin-a.akamaihd.net/content/dataset/multi-codec/hevc/stream_ts.m3u8</a></p><p><a href="https://bitmovin-a.akamaihd.net/content/playhouse-vr/m3u8s/105560.m3u8">https://bitmovin-a.akamaihd.net/content/playhouse-vr/m3u8s/105560.m3u8</a></p></li><li><p>HEVC MPEG-DASH: <a href="https://bitmovin-a.akamaihd.net/content/dataset/multi-codec/hevc/stream.mpd">http://bitmovin-a.akamaihd.net/content/dataset/multi-codec/hevc/stream.mpd</a></p></li><li><p>Multi-Codec MPEG-DASH (AVC/H.264, HEVC/H.265, VP9): <a href="http://bitmovin-a.akamaihd.net/content/dataset/multi-codec/stream.mpd">http://bitmovin-a.akamaihd.net/content/dataset/multi-codec/stream.mpd</a></p><p><a href="https://bitmovin-a.akamaihd.net/content/playhouse-vr/mpds/105560.mpd">https://bitmovin-a.akamaihd.net/content/playhouse-vr/mpds/105560.mpd</a></p></li><li><p>VP9 MPEG-DASH: <a href="http://bitmovin-a.akamaihd.net/content/dataset/multi-codec/stream_vp9.mpd">http://bitmovin-a.akamaihd.net/content/dataset/multi-codec/stream_vp9.mpd</a></p></li></ul><p>参考:</p><ul><li><a href="http://telestreamblog.telestream.net/2017/05/what-is-abr/">HLS，MPEG-DASH - What is ABR?</a></li><li><a href="https://www.bilibili.com/read/cv855111">B 站我们为什么使用 DASH</a></li><li><a href="https://strivecast.io/hls-vs-mpeg-dash/">Adaptive HTTP Streaming Technologies: HLS vs. DASH</a></li><li><a href="https://blog.csdn.net/nonmarking/article/details/86351147">自适应流媒体传输</a></li></ul><p>在线测试播放器:</p><p><a href="http://demo.theoplayer.com/test-your-stream-with-statistics">http://demo.theoplayer.com/test-your-stream-with-statistics</a></p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;</summary>
        
      
    
    
    
    <category term="知识剖析" scheme="http://example.com/categories/%E7%9F%A5%E8%AF%86%E5%89%96%E6%9E%90/"/>
    
    
    <category term="流媒体" scheme="http://example.com/tags/%E6%B5%81%E5%AA%92%E4%BD%93/"/>
    
    <category term="直播" scheme="http://example.com/tags/%E7%9B%B4%E6%92%AD/"/>
    
  </entry>
  
  <entry>
    <title>2023 总结</title>
    <link href="http://example.com/2024/01/01/2023%E6%80%BB%E7%BB%93/"/>
    <id>http://example.com/2024/01/01/2023%E6%80%BB%E7%BB%93/</id>
    <published>2024-01-01T04:05:22.000Z</published>
    <updated>2024-01-02T01:12:08.502Z</updated>
    
    <content type="html"><![CDATA[<h1 id="2023-总结"><a href="#2023-总结" class="headerlink" title="2023 总结"></a>2023 总结</h1><p>打开笔记本电脑面对着屏幕不禁陷入沉思，2023 年我该总结点啥呢。写一点再删一点断断续续。但是脑袋里一直有一个很模糊的景象，在告诉我你要去做，你必须要去做。<br>这个情况怎么说呢，已经持续 3 年多了，但是在我被面包车剐蹭之后，这个模糊的场景变得清晰了，但是还是依旧很模糊。每次当我用手机看一些新闻或者相关视频的时候，脑子里一直有一个声音一直在告诉要去做。一定要去做。<br>哈哈哈，可能这么说很魔幻，可能被人认为这个人是不是有病。说实话我也不知道我自己为什么会这样。有时候晚上躺在床上一直在想为什么会这样，为什么。在过去的一年里，我一直断断续续一直在想这个问题。为什么，为什么。有时候我会用忙碌的工作迫使自己不去可以注意这个问题。但是到最后还是在想这个问题。脑子里的那个声音总是断断续续告诉自己。你要去做。必须要去做。就好像我的身体和我的精神是割裂开的。我是缺少什么东西了吗。不知道，不清楚。</p><p>每次当我会的更多的时候，脑子里的声音就越强烈。而且这一年，也不能说这一年而是这最近一两年，每晚的做梦一直梦到自己的小学，初中，高中场景，或者一些相关的人。为什么，不知道。每次在梦中我都清晰的知道我自己已经毕业了，已经有工作了，但是已经还是梦到自己小初高学校的一些人或者事情。我这是念旧吗？不知道！不清楚。<del>有点说多了</del></p><p>该把话题扯回来了。想一想自己进入这个行业时间也蛮长的了。想当初在大学社团的时候，写一个 html 的颜色标签都不会到现在想一想。内心一阵苦笑。2023 年这一年，说轻松吧也不轻松，但是也不至于加班那种。这就给我了很多时间来归纳总结我自己的知识体系。前几年说实话自己学的蛮多的。但是归纳成自己的文档的蛮少的，今年的博客文档也没怎么更新。明明自己私下写了很多知识整理的内容。但是一直没有更新到自己的博客。可能这就是自己的拖延症吧。</p><p>说些很神奇的事情，有些时候我自己自学的一些新技术新内容，在有些时候很神奇的就会在某些项目中应用，这些新东西，或很长时间或者很短时间，就被新的项目提案中，列为必备技能或者技术。我有时候我都很佩服我自己。你说这个发生 1 次 2 次是偶然吧，关键是这种神奇的事情发生了很多次 2 只手都数不过来了。太神奇了。 <del>我可不是自卖自夸，请叫我先知先生 阿哈哈哈哈哈</del></p><p>看着自己写了这么多的内容，越看越像自己写的日记。无所谓了，总结和日记也差不多了，洒洒水啦，😂。我可不是偷懒哦，<strong>哦</strong>！<strong>哦</strong>！<strong>哦！</strong>。</p><p>一般来说有了总结就会有展望。那就写一点这一年我自己的计划吧。<br>首先：</p><ol><li><strong>体重减下来。</strong><br>今年是认真的，虽然前几年也减下来过，但是因为疫情也不能说怪疫情，也是因为自己松懈了，今年真的要把体重减下来。</li><li>看看有没有机会去日本出差。这个说实话我是真的挺想去日本去出差试试。<del>我可没有私心，我可不会承认我是一个老二次元了</del></li><li>技术方面的话保密。目前我自己有几个研究大概方向。但是没有具体想象，需要点时间。</li></ol><p>好了就写这么多了，这才是元旦，2024 第一天，等到春节我会更新自己的具体计划的敬请谅解！！！</p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;</summary>
        
      
    
    
    
    <category term="计划总结" scheme="http://example.com/categories/%E8%AE%A1%E5%88%92%E6%80%BB%E7%BB%93/"/>
    
    
    <category term="2023" scheme="http://example.com/tags/2023/"/>
    
    <category term="反省总结" scheme="http://example.com/tags/%E5%8F%8D%E7%9C%81%E6%80%BB%E7%BB%93/"/>
    
    <category term="企划" scheme="http://example.com/tags/%E4%BC%81%E5%88%92/"/>
    
    <category term="未来计划" scheme="http://example.com/tags/%E6%9C%AA%E6%9D%A5%E8%AE%A1%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>直播原理</title>
    <link href="http://example.com/2022/04/23/%E7%9B%B4%E6%92%AD%E5%8E%9F%E7%90%86%E4%B8%8E/"/>
    <id>http://example.com/2022/04/23/%E7%9B%B4%E6%92%AD%E5%8E%9F%E7%90%86%E4%B8%8E/</id>
    <published>2022-04-23T02:11:51.000Z</published>
    <updated>2024-01-02T01:12:08.529Z</updated>
    
    <content type="html"><![CDATA[<h1 id="直播原理与web直播实战"><a href="#直播原理与web直播实战" class="headerlink" title="直播原理与web直播实战"></a>直播原理与web直播实战</h1><h2 id="直播构成"><a href="#直播构成" class="headerlink" title="直播构成"></a>直播构成</h2><p><img src="http://greenhaha.oss-cn-beijing.aliyuncs.com/frontend/assets/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202022-04-23%20202423.png" alt="直播构成"></p><h2 id="直播流程"><a href="#直播流程" class="headerlink" title="直播流程"></a>直播流程</h2><p>视频直播可以分为采集，前处理，编码，传输，解码，渲染 这几个环节。</p><h3 id="采集"><a href="#采集" class="headerlink" title="采集"></a>采集</h3><p>一般是由客户端（IOS、安卓、PC或其它工具，如OBS）完成的，iOS是比较简单的，Android则要做些机型适配工作，PC最麻烦各种奇葩摄像头驱动</p><h3 id="前处理"><a href="#前处理" class="headerlink" title="前处理"></a>前处理</h3><p>主要是处理直播美颜，美颜算法需要用到GPU编程，需要懂图像处理算法的人，没有好的开源实现，要自己参考论文去研究。难点不在于美颜效果，而在于GPU占用和美颜效果之间找平衡。</p><h3 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h3><p>肯定要采用硬编码，软编码720p完全没希望，勉强能编码也会导致CPU过热烫到摄像头。编码要在分辨率，帧率，码率，GOP等参数设计上找到最佳平衡点。</p><h3 id="传输"><a href="#传输" class="headerlink" title="传输"></a>传输</h3><p>一般交给了CDN服务商。</p><h3 id="解码"><a href="#解码" class="headerlink" title="解码"></a>解码</h3><p>是对之前编码的操作，进行解码，在web里需要解码是HLS。</p><h3 id="渲染"><a href="#渲染" class="headerlink" title="渲染"></a>渲染</h3><p>主要用播放器来解决，web中常用到的播放器有 video.js ，目前我们使用是腾讯云播放器。</p><p>其实一个完成直播，远远不上面这几个环节，下面是腾讯云直播方案的整个流程图：</p><p><img src="http://greenhaha.oss-cn-beijing.aliyuncs.com/frontend/assets/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202022-04-23%20203038.png" alt="腾讯云"></p><h2 id="web中直播技术"><a href="#web中直播技术" class="headerlink" title="web中直播技术"></a>web中直播技术</h2><p>目前互联网上web做直播，主要是展示，主流web展示的话可能涉及到HLS跟RTMP这两个东西，现在我们重点讲解hls跟RTMP协议。</p><h3 id="HLS"><a href="#HLS" class="headerlink" title="HLS"></a>HLS</h3><p>HLS（HTTP Live Streaming全称）是一个基于HTTP的视频流协议，由Apple公司实现，Mac OS上的QuickTime、Safari 以及iOS上的 Safari都能很好的支持 HLS，高版本 Android 也增加了对 HLS 的支持。<br>一些常见的客户端如：MPlayerX、VLC 也都支持HLS协议，如果需要在chrome上播放，需要使用 <a href="https://link.juejin.cn/?target=https://github.com/videojs/videojs-contrib-hls">videojs-contrib-hls.js</a> 解析。<br><img src="http://greenhaha.oss-cn-beijing.aliyuncs.com/frontend/assets/img/1626023bd565d932_tplv-t2oaga2asx-zoom-in-crop-mark_1304_0_0_0.awebp" alt="HLS工作流程图"></p><h2 id="Server服务器"><a href="#Server服务器" class="headerlink" title="Server服务器"></a>Server服务器</h2><p>HLS的服务器组件负责获取的媒体输入流 , 然后Media编码后 MPEG-4（H.264 video 和 AAC audio）格式然后用硬件打包到 MPEG-2 (MPEG-2 transport stream)的传输流中。图中显示,传输流会经过stream segmenter, 这里的工作是MPEG-2传输流会被分散为小片段然后保存为一个或多个系列的 .ts 格式的媒体文件。这个过程需要借助编码工具来完成，比如 Apple stream segmenter。<br>(视频类是.ts文件,纯音频会被编码为一些音频小片段，通常为 ADTS头的AAC、MP3、或者 AC-3格式。)<br>服务端可以采用硬件编码和软件编码两种形式，其功能都是按照上文描述的规则对现有的媒体文件进行切片并使用索引文件进行管理。而软件切片通常会使用 Apple 公司提供的工具或者第三方的集成工具。</p><h2 id="Distribution分配组件"><a href="#Distribution分配组件" class="headerlink" title="Distribution分配组件"></a>Distribution分配组件</h2><p>同时上面提到的那个切片器（segmenter）也会创建一个索引文件，通常会包含这些媒体文件的一个列表，也能包含元数据。它一般都是一个个.M38U的列表。列表元素会关联一个 URL 用于客户端访问。然后按序去请求这些 URL。</p><p><img src="http://greenhaha.oss-cn-beijing.aliyuncs.com/frontend/assets/img/1626032618b54942_tplv-t2oaga2asx-zoom-in-crop-mark_1304_0_0_0.awebp" alt="索引文件结构图"></p><h3 id="主索引文件"><a href="#主索引文件" class="headerlink" title="主索引文件"></a>主索引文件</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#EXTM3U</span><br><span class="line">#EXT-X-STREAM-INF:PROGRAM-ID=1,BANDWIDTH=409037,RESOLUTION=416x234,CODECS=&quot;mp4a.40.2, avc1.42001e&quot;</span><br><span class="line">Gear1/prog_index.m3u8</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>第一行：<strong>#EXTM3U</strong></p><p>每个M3U文件第一行必须是这个tag，起标示作用</p><p>第二行：<strong>#EXT-X-STREAM-INF</strong></p><p>标签的属性列表中直接指明当前流是VIDEO还是AUDIO</p><p>包含属性 :</p><ul><li>BANDWIDTH 指定码率</li><li>PROGRAM-ID 唯一ID (这个属性在后面的协议版本废除了)</li><li>CODECS 指定流的编码类型</li><li>RESOLUTION：分辨率</li></ul><h3 id="子索引文件"><a href="#子索引文件" class="headerlink" title="子索引文件"></a>子索引文件</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#EXTM3U</span><br><span class="line">#EXT-X-TARGETDURATION:11</span><br><span class="line">#EXT-X-VERSION:3</span><br><span class="line">#EXT-X-MEDIA-SEQUENCE:0</span><br><span class="line">#EXT-X-PLAYLIST-TYPE:VOD</span><br><span class="line">#EXTINF:10.133333,</span><br><span class="line">fileSequence0.ts</span><br><span class="line">#EXTINF:10.000666,</span><br><span class="line">fileSequence1.ts</span><br><span class="line">#EXTINF:10.667334,</span><br><span class="line">fileSequence2.ts</span><br><span class="line">#EXTINF:9.686001,</span><br><span class="line">fileSequence3.ts</span><br><span class="line">#EXTINF:9.768665,</span><br><span class="line">fileSequence4.ts</span><br><span class="line">#EXTINF:10.000000,</span><br><span class="line">fileSequence5.ts</span><br><span class="line">#EXT-X-ENDLIST</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>#EXTM3U</strong> m3u文件头，必须放在第一行。<br><strong>#EXT-X-TARGETDURATION</strong> 每个分片TS的最大的时长。<br><strong>#EXT-X-VERSION</strong> 用以标示协议版本。<br><strong>#EXT-X-MEDIA-SEQUENCE</strong> TS分片的序列号。<br><strong>#EXT-X-PLAYLIST-TYPE</strong> 提供关于PlayList的可变性的信息， 这个对整个PlayList文件有效，是可选的。<br><strong>#EXTINF</strong> extra info，分片TS的信息，如时长，带宽等。</p><h3 id="主索引文件与子索引文件的区别"><a href="#主索引文件与子索引文件的区别" class="headerlink" title="主索引文件与子索引文件的区别"></a>主索引文件与子索引文件的区别</h3><ul><li>主索引文件和子索引文件都是.M3U8的playlist</li><li>主索引文件只需下载一次，但对于直播节目子索引文件定期重新加载</li></ul><h2 id="client客户端"><a href="#client客户端" class="headerlink" title="client客户端"></a>client客户端</h2><p>分配组件由标准的网络服务器。他们负责接受Client客户端请求并提供相关联的资源给客户端。</p><h3 id="videojs-contrib-hls-js组件解析过程"><a href="#videojs-contrib-hls-js组件解析过程" class="headerlink" title="videojs-contrib-hls.js组件解析过程"></a>videojs-contrib-hls.js组件解析过程</h3><p><img src="http://greenhaha.oss-cn-beijing.aliyuncs.com/frontend/assets/img/16260382981ee008_tplv-t2oaga2asx-zoom-in-crop-mark_1304_0_0_0.awebp" alt="videojs-contrib-hls.js解析图"></p><p>HLS简单讲就是把整个流分成一个个小的片段，基于 HTTP 的文件来下载，每次只下载一小部分。<br>前面提到了用于 H5 播放直播视频时引入的一个 .m3u8 的文件，这个文件就是基于 HLS 协议，存放视频流元数据的文件。<br>每一个 .m3u8 文件，分别对应若干个 ts 文件，这些 ts 文件才是真正存放视频的数据，m3u8 文件只是存放了一些 ts 文件的配置信息和相关路径，当视频播放时，.m3u8 是动态改变的，再通过解析器（videojs-contrib-hls.js）解析这个文件，并找到对应的 ts 文件来播放，所以一般为了加快速度，.m3u8 放在 web 服务器上，ts 文件放在 cdn 上。</p><h2 id="RTMP"><a href="#RTMP" class="headerlink" title="RTMP"></a>RTMP</h2><p>Real Time Messaging Protocol（简称 RTMP）是 Macromedia 开发的一套视频直播协议，现在属于 Adobe。这套方案需要搭建专门的 RTMP 流媒体服务如 Adobe Media Server，并且在浏览器中只能使用 Flash 实现播放器。它的实时性非常好，延迟很小，但无法支持移动端 WEB 播放是它的硬伤。<br>浏览器端，HTML5 video标签无法播放 RTMP 协议的视频，可以通过 video.js 来实现。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">&quot;http://vjs.zencdn.net/5.8.8/video-js.css&quot;</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;<span class="name">video</span> <span class="attr">id</span>=<span class="string">&quot;example_video_1&quot;</span> <span class="attr">class</span>=<span class="string">&quot;video-js vjs-default-skin&quot;</span> <span class="attr">controls</span> <span class="attr">preload</span>=<span class="string">&quot;auto&quot;</span> <span class="attr">width</span>=<span class="string">&quot;640&quot;</span> <span class="attr">height</span>=<span class="string">&quot;264&quot;</span> <span class="attr">loop</span>=<span class="string">&quot;loop&quot;</span> <span class="attr">webkit-playsinline</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">&quot;rtmp://10.14.221.17:1935/rtmplive/home&quot;</span> <span class="attr">type</span>=<span class="string">&#x27;rtmp/flv&#x27;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">video</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;http://vjs.zencdn.net/5.8.8/video.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">videojs.options.flash.swf = <span class="string">&#x27;video.swf&#x27;</span>;</span></span><br><span class="line"><span class="javascript">videojs(<span class="string">&#x27;example_video_1&#x27;</span>).ready(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript"><span class="built_in">this</span>.play();</span></span><br><span class="line"><span class="javascript">&#125;);</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="HLS-VS-RTMP-优缺点对比"><a href="#HLS-VS-RTMP-优缺点对比" class="headerlink" title="HLS VS RTMP 优缺点对比"></a>HLS VS RTMP 优缺点对比</h2><table><thead><tr><th><strong>协议</strong></th><th><strong>原理</strong></th><th><strong>延时</strong></th><th><strong>优点</strong></th><th><strong>缺点</strong></th><th><strong>使用场景</strong></th></tr></thead><tbody><tr><td>HLS(http)</td><td>集合一段时间数据生成ts切片文件更m3u8文件</td><td>10s-30s</td><td>跨平台</td><td>延时性高</td><td>移动端</td></tr><tr><td>RTMP(TCP)</td><td>每个时刻的数据收到后立即发送</td><td>2s</td><td>延时低、实时性好</td><td>跨平台差</td><td>PC+直播+实时性要求高+互动性强</td></tr></tbody></table>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;</summary>
        
      
    
    
    
    <category term="知识剖析" scheme="http://example.com/categories/%E7%9F%A5%E8%AF%86%E5%89%96%E6%9E%90/"/>
    
    
    <category term="直播" scheme="http://example.com/tags/%E7%9B%B4%E6%92%AD/"/>
    
    <category term="chromeAPI" scheme="http://example.com/tags/chromeAPI/"/>
    
  </entry>
  
  <entry>
    <title>express-session 原理</title>
    <link href="http://example.com/2022/03/16/express-session/"/>
    <id>http://example.com/2022/03/16/express-session/</id>
    <published>2022-03-16T13:35:36.000Z</published>
    <updated>2024-01-02T01:12:08.503Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Express-session解析"><a href="#Express-session解析" class="headerlink" title="Express-session解析"></a>Express-session解析</h2><h3 id="session-是什么"><a href="#session-是什么" class="headerlink" title="session 是什么"></a>session 是什么</h3><p>ession一般译作会话，牛津词典对其的解释是进行某活动连续的一段时间。在web应用的用户看来，session是另一种记录客户状态的机制，不同的是Cookie保存在客户端浏览器中，而session保存在服务器上。<br>客户端浏览器访问服务器的时候，服务器把客户端信息以某种形式记录在服务器上.客户端浏览器再次访问时只需要从该Session中查找该客户的状态就可以了。</p><blockquote><p>Session是有状态的，而HTTP协议是无状态的，二者是否矛盾呢？</p></blockquote><p>Session和HTTP协议属于<code>不同层面的事物</code>，HTTP属于ISO七层模型的最高层<code>应用层</code>，<strong>前者Session不属于后者</strong>，前者HTTP是具体的动态页面技术来实现的，但同时它又是<strong>基于后者的</strong>。</p><h3 id="Session的原理：摘录"><a href="#Session的原理：摘录" class="headerlink" title="Session的原理：摘录"></a>Session的原理：摘录</h3><p>基本原理是服务端为每一个session维护一份会话信息数据, 而客户端和服务端依靠一个全局唯一的标识来访问会话信息数据。用户访问web应用时，服务端程序决定何时创建session，创建session可以概括为三个步骤：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. 生成全局唯一标识符（sessionid）；</span><br><span class="line">2. 开辟数据存储空间。一般会在内存中创建相应的数据结构，但这种情况下，系统一旦掉电，所有的会话数据就会丢失，如果是电子商务网站，这种事故会造成严重的后果。不过也可以写到文件里甚至存储在数据库中，这样虽然会增加I/O开销，但session可以实现某种程度的持久化，而且更有利于session的共享；</span><br><span class="line">3. 将session的全局唯一标示符发送给客户端。</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>问题的关键就在<strong>服务端如何发送这个session的唯一标识上</strong>。联系到HTTP协议，数据无非可以放到请求行、头域或Body里，基于此，一般来说会有两种常用的方式：<code>cookie</code>和<code>URL重写</code>。</p><h3 id="session和cookie-优缺点和各自的应用场景："><a href="#session和cookie-优缺点和各自的应用场景：" class="headerlink" title="session和cookie 优缺点和各自的应用场景："></a>session和cookie 优缺点和各自的应用场景：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">1.   应用场景</span><br><span class="line">Cookie的典型应用场景是Remember Me服务，即用户的账户信息通过cookie的形式保存在客户端，当用户再次</span><br><span class="line">请求匹配的URL的时候，账户信息会被传送到服务端，交由相应的程序完成自动登录等功能。当然也可以保存</span><br><span class="line">一些客户端信息，比如页面布局以及搜索历史等等。</span><br><span class="line">Session的典型应用场景是用户登录某网站之后，将其登录信息放入session，在以后的每次请求中查询相应</span><br><span class="line">的登录信息以确保该用户合法。当然还是有购物车等等经典场景；</span><br><span class="line">2.   安全性</span><br><span class="line">cookie将信息保存在客户端，如果不进行加密的话，无疑会暴露一些隐私信息，安全性很差，一般情况下敏</span><br><span class="line">感信息是经过加密后存储在cookie中，但很容易就会被窃取。而session只会将信息存储在服务端，如果存</span><br><span class="line">储在文件或数据库中，也有被窃取的可能，只是可能性比cookie小了太多。</span><br><span class="line">Session安全性方面比较突出的是存在会话劫持的问题，这是一种安全威胁。总体来讲，session的安全性</span><br><span class="line">要高于cookie；</span><br><span class="line">3.   性能</span><br><span class="line">Cookie存储在客户端，消耗的是客户端的I/O和内存，而session存储在服务端，消耗的是服务端的资源。</span><br><span class="line">但是session对服务器造成的压力比较集中，而cookie很好地分散了资源消耗，就这点来说，cookie是要优于session的；</span><br><span class="line">4.   时效性</span><br><span class="line">Cookie可以通过设置有效期使其较长时间内存在于客户端，而session一般只有比较短的有效期（用户主动销毁</span><br><span class="line">session或关闭浏览器后引发超时）；</span><br><span class="line">5.   其他</span><br><span class="line">Cookie的处理在开发中没有session方便。而且cookie在客户端是有数量和大小的限制的，而session的大小</span><br><span class="line">却只以硬件为限制，能存储的数据无疑大了太多。</span><br></pre></td></tr></table></figure><p>Session工作的大致步骤</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1. 用户提交包含用户名和密码的表单，发送HTTP请求。</span><br><span class="line">2. 服务器验证用户发来的用户名密码。</span><br><span class="line">3. 如果正确则把当前用户名（通常是用户对象）存储到redis中，并生成它在redis中的ID。</span><br><span class="line">    这个ID称为Session ID，通过Session ID可以从Redis中取出对应的用户对象， 敏感数据（比如authed=true）都存储在这个用户对象中。</span><br><span class="line">4. 设置Cookie为sessionId=xxxxxx|checksum并发送HTTP响应， 仍然为每一项Cookie都设置签名。</span><br><span class="line">5. 用户收到HTTP响应后，便看不到任何敏感数据了。在此后的请求中发送该Cookie给服务器。</span><br><span class="line">6. 服务器收到此后的HTTP请求后，发现Cookie中有SessionID，进行放篡改验证。</span><br><span class="line">7. 如果通过了验证，根据该ID从Redis中取出对应的用户对象， 查看该对象的状态并继续执行业务逻辑。</span><br></pre></td></tr></table></figure><h2 id="express-session中间件"><a href="#express-session中间件" class="headerlink" title="express-session中间件"></a>express-session中间件</h2><p>express-session中间件将会话数据存储在服务器上；它仅将会话标识（而非会话数据）保存在 cookie 中。从1.5.0版本开始, express-session不再依赖<code>cookie-parser</code>,直接通过<code>req/res</code>读取/写入;默认存储位置<code>内存存储</code>(服务器端),</p><p>安装:  <code>npm install express-session</code></p><p>主要方法 : <strong>session(options)</strong></p><p>通过option来设置session存储，除了session ID外，session中的任何数据都不存储在cookie中。<br>options可选参数:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">1. name - cookie的名字（原属性名为 key）。（默认：’connect.sid’）</span><br><span class="line">2. store - session存储实例</span><br><span class="line">3. secret - 用它来对session cookie签名，防止篡改</span><br><span class="line">4. cookie - session cookie设置 （默认：&#123; path: ‘/‘, httpOnly: true,secure: false, maxAge: null &#125;）</span><br><span class="line">5. genid - 生成新session ID的函数 （默认使用uid2库）</span><br><span class="line">6. rolling - 在每次请求时强行设置cookie，这将重置cookie过期时间（默认：false）</span><br><span class="line">7. resave - 强制保存session即使它并没有变化 （默认： true）</span><br><span class="line">8. proxy - 当设置了secure cookies（通过”x-forwarded-proto” header ）时信任反向代理。当设定为true时，</span><br><span class="line">”x-forwarded-proto” header 将被使用。当设定为false时，所有headers将被忽略。当该属性没有被设定时，将使用Express的trust proxy。</span><br><span class="line">9. saveUninitialized - 强制将未初始化的session存储。当新建了一个session且未设定属性或值时，它就处于</span><br><span class="line">未初始化状态。在设定一个cookie前，这对于登陆验证，减轻服务端存储压力，权限控制是有帮助的。（默认：true）</span><br><span class="line">10. unset - 控制req.session是否取消（例如通过 delete，或者将它的值设置为null）。这可以使session保持存储</span><br><span class="line">状态但忽略修改或删除的请求（默认：keep）</span><br></pre></td></tr></table></figure><h3 id="express-session的一些方法"><a href="#express-session的一些方法" class="headerlink" title="express-session的一些方法:"></a>express-session的一些方法:</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. Session.destroy():删除session，当检测到客户端关闭时调用。</span><br><span class="line">2. Session.reload():当session有修改时，刷新session。</span><br><span class="line">3. Session.regenerate()：将已有session初始化。</span><br><span class="line">4. Session.save()：保存session。</span><br></pre></td></tr></table></figure><h3 id="内存存储-方式实例代码"><a href="#内存存储-方式实例代码" class="headerlink" title="内存存储 方式实例代码:"></a>内存存储 方式实例代码:</h3><p>一旦我们将express-session中间件用use挂载后，我们可以很方便的通过req参数来存储和访问session对象的数据。req.session是一个JSON格式的JavaScript对象，我们可以在使用的过程中随意的增加成员，这些成员会自动的被保存到option参数指定的地方，默认即为内存中去。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">var express = require(&#x27;express&#x27;);</span><br><span class="line">var session = require(&#x27;express-session&#x27;);</span><br><span class="line">var app = express();// Use the session middleware </span><br><span class="line">app.use(session(&#123; </span><br><span class="line">////这里的name值得是cookie的name，默认cookie的name是：connect.sid</span><br><span class="line">  //name: &#x27;hhw&#x27;,</span><br><span class="line">  secret: &#x27;keyboard cat&#x27;, </span><br><span class="line">  cookie: (&#x27;name&#x27;, &#x27;value&#x27;, &#123; path: &#x27;/&#x27;, httpOnly: true,secure: false, maxAge:  60000 &#125;),  //重新保存：强制会话保存即使是未修改的。默认为true但是得写上</span><br><span class="line">  resave: true, </span><br><span class="line">  //强制“未初始化”的会话保存到存储。 </span><br><span class="line">  saveUninitialized: true,  </span><br><span class="line">  </span><br><span class="line">&#125;))</span><br><span class="line">// 只需要用express app的use方法将session挂载在‘/’路径即可，这样所有的路由都可以访问到session。//可以给要挂载的session传递不同的option参数，来控制session的不同特性 </span><br><span class="line">app.get(&#x27;/&#x27;, function(req, res, next) &#123;  </span><br><span class="line">var sess = req.session//用这个属性获取session中保存的数据，而且返回的JSON数据</span><br><span class="line">  if (sess.views) &#123;</span><br><span class="line">    sess.views++</span><br><span class="line">    res.setHeader(&#x27;Content-Type&#x27;, &#x27;text/html&#x27;)</span><br><span class="line">    res.write(&#x27;&lt;p&gt;欢迎第 &#x27; + sess.views + &#x27;次访问       &#x27; + &#x27;expires in:&#x27; + (sess.cookie.maxAge / 1000) + &#x27;s&lt;/p&gt;&#x27;)</span><br><span class="line">    res.end();</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    sess.views = 1</span><br><span class="line">    res.end(&#x27;welcome to the session demo. refresh!&#x27;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.listen(3000);</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;</summary>
        
      
    
    
    
    <category term="知识剖析" scheme="http://example.com/categories/%E7%9F%A5%E8%AF%86%E5%89%96%E6%9E%90/"/>
    
    
    <category term="Node" scheme="http://example.com/tags/Node/"/>
    
    <category term="express" scheme="http://example.com/tags/express/"/>
    
    <category term="中间件" scheme="http://example.com/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    <category term="express-session" scheme="http://example.com/tags/express-session/"/>
    
  </entry>
  
  <entry>
    <title>Interface 与 Type的区别</title>
    <link href="http://example.com/2022/03/14/interface%E4%B8%8Etype/"/>
    <id>http://example.com/2022/03/14/interface%E4%B8%8Etype/</id>
    <published>2022-03-14T03:48:43.000Z</published>
    <updated>2024-01-02T01:12:08.506Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Interface-与Type"><a href="#Interface-与Type" class="headerlink" title="Interface 与Type"></a>Interface 与Type</h2><p>在使用typescript的时候经常会使用到interface与type。对于这两者区别在<a href="https://github.com/microsoft/TypeScript/blob/main/doc/spec-ARCHIVED.md">官方文档</a>中说明了两者区别</p><blockquote><ul><li>An interface can be named in an extends or implements clause, but a type alias for an object type literal cannot.<br/>(接口可以在扩展或实现子句中命名，但对象类型文字的类型别名不能)</li><li>An interface can have multiple merged declarations, but a type alias for an object type literal cannot.(一个接口可以有多个合并的声明，但对象类型文字的类型别名不能。)</li></ul></blockquote><h2 id="相同点"><a href="#相同点" class="headerlink" title="相同点"></a>相同点</h2><p>简单一句话： <strong>都可以描述一个对象或者函数</strong></p><h3 id="interface"><a href="#interface" class="headerlink" title="interface"></a>interface</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> person &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> setperson &#123;</span><br><span class="line">  (name: <span class="built_in">string</span>, <span class="attr">age</span>: <span class="built_in">number</span>): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="type"><a href="#type" class="headerlink" title="type"></a>type</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> person = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> setperson = <span class="function">(<span class="params">name: <span class="built_in">string</span>, age: <span class="built_in">number</span></span>)=&gt;</span> <span class="built_in">void</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="都允许拓展（extends）与-交叉类型（Intersection-Types）"><a href="#都允许拓展（extends）与-交叉类型（Intersection-Types）" class="headerlink" title="都允许拓展（extends）与 交叉类型（Intersection Types）"></a>都允许拓展（extends）与 交叉类型（Intersection Types）</h3><p>interface 和 type 都可以拓展，并且两者并不是相互独立的，也就是说 interface 可以 extends type, type 也可以 extends interface 。interface 可以 extends， 但 type 是不允许 extends 和 implement 的，但是 type 却可以通过交叉类型 实现 interface 的 extend 行为，并且两者并不是相互独立的，也就是说 interface 可以 extends type, type 也可以 与 interface 类型 交叉 。 <strong>虽然效果差不多，但是两者语法不同。</strong></p><h3 id="interface-extends-interface"><a href="#interface-extends-interface" class="headerlink" title="interface extends interface"></a>interface extends interface</h3><p>interface 继承使用关键字 extends</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Name &#123; </span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> User <span class="keyword">extends</span> Name &#123; </span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="type-与-type-交叉"><a href="#type-与-type-交叉" class="headerlink" title="type 与 type 交叉"></a>type 与 type 交叉</h3><p>type 继承使用符号&amp;</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Name = &#123; </span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> User = Name &amp; &#123; <span class="attr">age</span>: <span class="built_in">number</span>  &#125;;</span><br></pre></td></tr></table></figure><h3 id="interface-extends-type"><a href="#interface-extends-type" class="headerlink" title="interface extends type"></a>interface extends type</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Name = &#123; </span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> User <span class="keyword">extends</span> Name &#123; </span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="type-与-interface-交叉"><a href="#type-与-interface-交叉" class="headerlink" title="type 与 interface 交叉"></a>type 与 interface 交叉</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Name &#123; </span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> User = Name &amp; &#123; </span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="不同点"><a href="#不同点" class="headerlink" title="不同点"></a>不同点</h2><h3 id="type-可以而-interface-不行"><a href="#type-可以而-interface-不行" class="headerlink" title="type 可以而 interface 不行"></a>type 可以而 interface 不行</h3><ul><li><p>type 可以声明基本类型别名，联合类型，元组等类型<br></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基本类型别名</span></span><br><span class="line"><span class="keyword">type</span> Name = <span class="built_in">string</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 联合类型</span></span><br><span class="line"><span class="keyword">interface</span> Dog &#123;</span><br><span class="line">    wong();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> Cat &#123;</span><br><span class="line">    miao();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Pet = Dog | Cat</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体定义数组每个位置的类型</span></span><br><span class="line"><span class="keyword">type</span> PetList = [Dog, Pet]</span><br></pre></td></tr></table></figure></li><li><p>type 语句中还可以使用 typeof 获取实例的 类型进行赋值<br></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当你想获取一个变量的类型时，使用 typeof</span></span><br><span class="line"><span class="keyword">let</span> div = <span class="built_in">document</span>.createElement(<span class="string">&#x27;div&#x27;</span>);</span><br><span class="line"><span class="keyword">type</span> B = <span class="keyword">typeof</span> div</span><br></pre></td></tr></table></figure></li><li><p>其他骚操作</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> StringOrNumber = <span class="built_in">string</span> | <span class="built_in">number</span>;  </span><br><span class="line"><span class="keyword">type</span> Text = <span class="built_in">string</span> | &#123; <span class="attr">text</span>: <span class="built_in">string</span> &#125;;  </span><br><span class="line"><span class="keyword">type</span> NameLookup = Dictionary&lt;<span class="built_in">string</span>, Person&gt;;  </span><br><span class="line"><span class="keyword">type</span> Callback&lt;T&gt; = <span class="function">(<span class="params">data: T</span>) =&gt;</span> <span class="built_in">void</span>;  </span><br><span class="line"><span class="keyword">type</span> Pair&lt;T&gt; = [T, T];  </span><br><span class="line"><span class="keyword">type</span> Coordinates = Pair&lt;<span class="built_in">number</span>&gt;;  </span><br><span class="line"><span class="keyword">type</span> Tree&lt;T&gt; = T | &#123; <span class="attr">left</span>: Tree&lt;T&gt;, right: Tree&lt;T&gt; &#125;;</span><br></pre></td></tr></table></figure></li></ul><h3 id="interface-可以而-type-不行"><a href="#interface-可以而-type-不行" class="headerlink" title="interface 可以而 type 不行"></a>interface 可以而 type 不行</h3><p>interface 能够声明合并</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> User &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> User &#123;</span><br><span class="line">  <span class="attr">sex</span>: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">User 接口为 &#123;</span></span><br><span class="line"><span class="comment">  name: string</span></span><br><span class="line"><span class="comment">  age: number</span></span><br><span class="line"><span class="comment">  sex: string </span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>一般来说，如果不清楚什么时候用interface/type，能用 interface 实现，就用 interface , 如果不能就用 type 。其他更多详情参看<a href="https://github.com/microsoft/TypeScript/blob/main/doc/spec-ARCHIVED.md">官方规范文档</a></p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;</summary>
        
      
    
    
    
    <category term="知识剖析" scheme="http://example.com/categories/%E7%9F%A5%E8%AF%86%E5%89%96%E6%9E%90/"/>
    
    
    <category term="Node" scheme="http://example.com/tags/Node/"/>
    
    <category term="TypeScript" scheme="http://example.com/tags/TypeScript/"/>
    
  </entry>
  
  <entry>
    <title>express中间件</title>
    <link href="http://example.com/2021/08/27/express%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    <id>http://example.com/2021/08/27/express%E4%B8%AD%E9%97%B4%E4%BB%B6/</id>
    <published>2021-08-27T07:35:36.000Z</published>
    <updated>2024-01-02T01:12:08.503Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是express-中间件？"><a href="#什么是express-中间件？" class="headerlink" title="什么是express 中间件？"></a>什么是express 中间件？</h2><p>在express 的官网中有一段对中间件函数的解释：</p><blockquote><p>Middleware functions are functions that have access to the request object (req), the response object (res), and the next middleware function in the application’s request-response cycle. The next middleware function is commonly denoted by a variable named next.</p></blockquote><p>理解这句话可以看一下下图：<br><img src="https://greenhaha.oss-cn-beijing.aliyuncs.com/frontend/assets/img/middleware.png" alt="middleware 流程"></p><p>可以把express 理解成一个水管，用户的请求内容（request）可以理解为进水口，返回的内容（response）可以理解为出水口。而中间件在其中起到的 可以理解为这个水管的过滤器对请求的内容进行过滤处理之后排出过滤或者处理的结果。</p><p>那么对于在日常开发中使用中间的好处的话可以总结3点：</p><ul><li>逻辑清楚，层次分明。 正如TCP/IP中的分层一样，通过分层，可以使得每一个部分各司其职，更好的干事情。</li><li>便于维护。如果觉得其中一个做的不好，还可以换一个中间件，而其他的不用替换。</li><li>可复用。我们写好了一个中间件之后，就可以直接拿来在别的地方用了，就比如，我们在使用第三方中间件的时候，直接npm install somemiddleware，然后 require，最后直接 app.use 即可，非常方便。</li></ul><p>正如官网对中间件的解释：Middleware function 中间件的本质就是一个函数，这时候在理解上面的好处的时候实际上就是函数组件化的优点。</p><p>在express里中间件可以大致分为4类：</p><ul><li>应用级中间件 Application-level middleware </li><li>路由级中间件 Router-level middleware</li><li>错误级中间件 Error-handling middleware</li><li>内置级中间件 Built-in middleware</li><li>第三方中间件 Third-party middleware</li></ul><h3 id="应用级中间件（Application-level-middleware）"><a href="#应用级中间件（Application-level-middleware）" class="headerlink" title="应用级中间件（Application-level middleware）"></a>应用级中间件（Application-level middleware）</h3><p>其实应用级中间件可以理解为直接作用于express实例上的，这么说可能不太理解，但是<code>expresss().ues()</code>一定用过，其实这个就是应用级中间件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>)</span><br><span class="line"><span class="keyword">let</span> app = express()</span><br><span class="line">app.use(middleware1)   <span class="comment">// app.use() 方法中可以直接加载中间件</span></span><br></pre></td></tr></table></figure><h3 id="路由级中间件（Router-level-middleware）"><a href="#路由级中间件（Router-level-middleware）" class="headerlink" title="路由级中间件（Router-level middleware）"></a>路由级中间件（Router-level middleware）</h3><p>路由级中间件和一般的应用级中间件使用的方法是一样的，它们之间的区别是功能上职责区别。路由级中间件是为进行路由的管理，这里的路由并非是前端页面的路由，可以理解为单纯的url管理</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> app = express()</span><br><span class="line"><span class="keyword">let</span> router = express.Router()</span><br><span class="line"><span class="comment">// a middleware function with no mount path. This code is executed for every request to the router</span></span><br><span class="line">router.use(<span class="function"><span class="keyword">function</span> (<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;Time:&#x27;</span>, <span class="built_in">Date</span>.now())</span><br><span class="line">  next()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="错误级中间件（Error-handling-middleware）"><a href="#错误级中间件（Error-handling-middleware）" class="headerlink" title="错误级中间件（Error-handling middleware）"></a>错误级中间件（Error-handling middleware）</h3><p>这个中间件可以理解为拦截请求错误的。有四个参数，所以你必须提供四个参数来表明这个中间件是一个错误处理中间件，即使也许你不需要Next对象，你也得明确说明，否则的话，这就会被解析为一个普通的中间件，而非错误处理中间件了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">app.use(<span class="function"><span class="keyword">function</span> (<span class="params">err, req, res, next</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.error(err.stack)</span><br><span class="line">  res.status(<span class="number">500</span>).send(<span class="string">&#x27;Something broke!&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="内置级中间件（Built-in-middleware）"><a href="#内置级中间件（Built-in-middleware）" class="headerlink" title="内置级中间件（Built-in middleware）"></a>内置级中间件（Built-in middleware）</h3><p>express.js本身就是一个基于node的web应用程序。一个web应用就会涉及到静态资源的加载，express也不例外。因此对于静态资源的加载问题，express在4.4之后就不再依赖connect。因此目前express中唯一的一个内置应用级中间件就是<code>express.static</code>。这个函数是基于server-static的。目的是为了提供类似html，css，img，js等静态资源的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">express.static(root, [options])</span><br></pre></td></tr></table></figure><p>具体使用方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> options = &#123;</span><br><span class="line">  <span class="attr">dotfiles</span>: <span class="string">&#x27;ignore&#x27;</span>,</span><br><span class="line">  <span class="attr">etag</span>: <span class="literal">false</span>,</span><br><span class="line">  <span class="attr">extensions</span>: [<span class="string">&#x27;htm&#x27;</span>, <span class="string">&#x27;html&#x27;</span>],</span><br><span class="line">  <span class="attr">index</span>: <span class="literal">false</span>,</span><br><span class="line">  <span class="attr">maxAge</span>: <span class="string">&#x27;1d&#x27;</span>,</span><br><span class="line">  <span class="attr">redirect</span>: <span class="literal">false</span>,</span><br><span class="line">  <span class="attr">setHeaders</span>: <span class="function"><span class="keyword">function</span> (<span class="params">res, path, stat</span>) </span>&#123;</span><br><span class="line">    res.set(<span class="string">&#x27;x-timestamp&#x27;</span>, <span class="built_in">Date</span>.now())</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">app.use(express.static(<span class="string">&#x27;public&#x27;</span>, options))</span><br></pre></td></tr></table></figure><p>如果有多个静态文件的目录</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">app.use(express.static(<span class="string">&#x27;public&#x27;</span>))</span><br><span class="line">app.use(express.static(<span class="string">&#x27;file&#x27;</span>))</span><br><span class="line">app.use(express.static(<span class="string">&#x27;image&#x27;</span>))</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="第三方级中间件（Third-party-middleware）"><a href="#第三方级中间件（Third-party-middleware）" class="headerlink" title="第三方级中间件（Third-party middleware）"></a>第三方级中间件（Third-party middleware）</h3><p>第三方级中间件按照字面理解的话就是第三方中间件。这些中间件非官方开发，有独立开发者自己开发的中间件。这种中间件有很多比如：</p><ul><li>cookie-parser</li><li>body-parser 等等</li></ul><h2 id="中间件实现原理"><a href="#中间件实现原理" class="headerlink" title="中间件实现原理"></a>中间件实现原理</h2><p>上面介绍的express的中间件，其实中间件就是一个函数，在相应发送之前对请求进行一些操作</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">middleware</span>(<span class="params">req, res, next</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// do someting</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// run next function</span></span><br><span class="line">    next()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>中间件函数它有一个next参数，而这个next参数也是一个函数，他表示函数数组中的下一个函数。那么就会有另外一个问题：函数数组又是什么呢？<br>其实就是express内部维护一个函数数组，这个函数数组表示在发出响应之前要执行的所有函数，也就是中间件数组</p><p>使用<code>app.use(fn)</code>后，传进来的fn就会被扔到这个数组里，执行完毕后调用<code>next()</code>方法执行函数数组里的下一个函数，如果没有调用next()的话，就不会调用下一个函数了，也就是说调用就会被终止</p><h2 id="简单实现一个express中间件"><a href="#简单实现一个express中间件" class="headerlink" title="简单实现一个express中间件"></a>简单实现一个express中间件</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 仿照express实现中间件的功能</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Created by BadWaka on 2017/3/6.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 仿express实现中间件机制</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;app&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">express</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> funcs = []; <span class="comment">// 待执行的函数数组</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> app = <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">next</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> task = funcs[i++];  <span class="comment">// 取出函数数组里的下一个函数</span></span><br><span class="line">            <span class="keyword">if</span> (!task) &#123;    <span class="comment">// 如果函数不存在,return</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            task(req, res, next);   <span class="comment">// 否则,执行下一个函数</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        next();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * use方法就是把函数添加到函数数组中</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param <span class="variable">task</span></span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    app.use = <span class="function"><span class="keyword">function</span> (<span class="params">task</span>) </span>&#123;</span><br><span class="line">        funcs.push(task);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> app;    <span class="comment">// 返回实例</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面是测试case</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> app = express();</span><br><span class="line">http.createServer(app).listen(<span class="string">&#x27;3000&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;listening 3000....&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">middlewareA</span>(<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;middlewareA before next()&#x27;</span>);</span><br><span class="line">    next();</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;middlewareA after next()&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">middlewareB</span>(<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;middlewareB before next()&#x27;</span>);</span><br><span class="line">    next();</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;middlewareB after next()&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">middlewareC</span>(<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;middlewareC before next()&#x27;</span>);</span><br><span class="line">    next();</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;middlewareC after next()&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">app.use(middlewareA);</span><br><span class="line">app.use(middlewareB);</span><br><span class="line">app.use(middlewareC);</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;</summary>
        
      
    
    
    
    <category term="知识剖析" scheme="http://example.com/categories/%E7%9F%A5%E8%AF%86%E5%89%96%E6%9E%90/"/>
    
    
    <category term="Node" scheme="http://example.com/tags/Node/"/>
    
    <category term="express" scheme="http://example.com/tags/express/"/>
    
    <category term="中间件" scheme="http://example.com/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript隐式类型转换</title>
    <link href="http://example.com/2021/08/26/js%E9%9A%90%E5%BC%8F%E8%BD%AC%E6%8D%A2/"/>
    <id>http://example.com/2021/08/26/js%E9%9A%90%E5%BC%8F%E8%BD%AC%E6%8D%A2/</id>
    <published>2021-08-26T07:47:56.000Z</published>
    <updated>2024-01-02T01:12:08.508Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://greenhaha.oss-cn-beijing.aliyuncs.com/frontend/assets/img/how-it-fucking-work.png" alt="JavaScript隐式类型转换"><br>javascript 在发生隐式类型转换的时候会有各种个样的问题,即使有很多经验的开发者有时候也不一定能理清楚具体规律是什么。</p><span class="blur">其实写这篇文章的主要原因是面试时候问到这个，而我却满脸❓</span>。因此我想要好好整理这一块<h2 id="数学运算符中的类型转换"><a href="#数学运算符中的类型转换" class="headerlink" title="数学运算符中的类型转换"></a>数学运算符中的类型转换</h2><p>因为 JS 并没有类型声明，所以任意两个变量或字面量，都可以做加减乘除。</p><h3 id="减、乘、除"><a href="#减、乘、除" class="headerlink" title="减、乘、除"></a>减、乘、除</h3><p>非<code>Number</code>类型运用数学运算符<code>(- * /)</code>时，会先将非<code>Number</code>类型转换为<code>Number</code>类型。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> - <span class="literal">true</span> <span class="comment">// 0， 首先把 true 转换为数字 1， 然后执行 1 - 1</span></span><br><span class="line"><span class="number">1</span> - <span class="literal">null</span> <span class="comment">// 1,  首先把 null 转换为数字 0， 然后执行 1 - 0</span></span><br><span class="line"><span class="number">1</span> * <span class="literal">undefined</span> <span class="comment">//  NaN, undefined 转换为数字是 NaN</span></span><br><span class="line"><span class="number">2</span> * [<span class="string">&#x27;5&#x27;</span>] <span class="comment">//  10， [&#x27;5&#x27;]首先会变成 &#x27;5&#x27;, 然后再变成数字 5</span></span><br></pre></td></tr></table></figure><h3 id="加法的特殊性"><a href="#加法的特殊性" class="headerlink" title="加法的特殊性"></a>加法的特殊性</h3><p>JS里 <code>+</code>还可以用来拼接字符串。谨记以下3条：</p><ul><li>当一侧为<code>String</code>类型，被识别为字符串拼接，并会优先将另一侧转换为字符串类型。</li><li>当一侧为<code>Number</code>类型，另一侧为原始类型，则将原始类型转换为<code>Number</code>类型。</li><li>当一侧为<code>Number</code>类型，另一侧为引用类型，将引用类型和<code>Number</code>类型转换成字符串后拼接。</li></ul><p>优先级从高到低，即 <code>3+&#39;abc&#39;</code> 会应用规则 1，而 <code>3+true</code>会应用规则2。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">123</span> + <span class="string">&#x27;123&#x27;</span> <span class="comment">// 123123   （规则1）</span></span><br><span class="line"><span class="number">123</span> + <span class="literal">null</span>  <span class="comment">// 123    （规则2）</span></span><br><span class="line"><span class="number">123</span> + <span class="literal">true</span> <span class="comment">// 124    （规则2）</span></span><br><span class="line"><span class="number">123</span> + &#123;&#125;  <span class="comment">// 123[object Object]    （规则3）</span></span><br></pre></td></tr></table></figure><h2 id="逻辑语句中的类型转换"><a href="#逻辑语句中的类型转换" class="headerlink" title="逻辑语句中的类型转换"></a>逻辑语句中的类型转换</h2><p>使用 <code>if while for</code> 语句时，我们期望表达式是一个<code>Boolean</code>，所以一定伴随着隐式类型转换。而这里面又分为两种情况:</p><h3 id="单个变量"><a href="#单个变量" class="headerlink" title="单个变量"></a>单个变量</h3><p>只有单个变量，会先将变量转换为<code>Boolean</code>值。</p><p>我们可以参考附录的转换表来判断各种类型转变为<code>Boolean</code>后的值。</p><p>不过这里有个小技巧：</p><p>只有 <code>null undefined &#39;&#39; NaN 0 false</code> 这几个是 <code>false</code>，其他的情况都是 <code>true</code>，比如 <code>&#123;&#125;</code> , <code>[]</code>。</p><h3 id="使用-比较中的5条规则"><a href="#使用-比较中的5条规则" class="headerlink" title="使用 == 比较中的5条规则"></a>使用 == 比较中的5条规则</h3><p>可以严格使用 ===，不过了解==的习性还是很有必要的<br>根据 == 两侧的数据类型，我们总结出 5 条规则：</p><ul><li>规则 1：NaN和其他任何类型比较永远返回false（包括和他自己）<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">NaN</span> == <span class="literal">NaN</span> <span class="comment">// false</span></span><br></pre></td></tr></table></figure></li><li>规则 2：Boolean 和其他任何类型比较，Boolean 首先被转换为 Number 类型。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">true</span> == <span class="number">1</span>  <span class="comment">// true </span></span><br><span class="line"><span class="literal">true</span> == <span class="string">&#x27;2&#x27;</span>  <span class="comment">// false, 先把 true 变成 1，而不是把 &#x27;2&#x27; 变成 true</span></span><br><span class="line"><span class="literal">true</span> == [<span class="string">&#x27;1&#x27;</span>]  <span class="comment">// true, 先把 true 变成 1， [&#x27;1&#x27;]拆箱成 &#x27;1&#x27;, 再参考规则3</span></span><br><span class="line"><span class="literal">true</span> == [<span class="string">&#x27;2&#x27;</span>]  <span class="comment">// false, 同上</span></span><br><span class="line"><span class="literal">undefined</span> == <span class="literal">false</span> <span class="comment">// false ，首先 false 变成 0，然后参考规则4</span></span><br><span class="line"><span class="literal">null</span> == <span class="literal">false</span> <span class="comment">// false，同上</span></span><br></pre></td></tr></table></figure></li><li>规则 3：<code>String</code>和<code>Number</code>比较，先将<code>String</code>转换为<code>Number</code>类型</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">123</span> == <span class="string">&#x27;123&#x27;</span> <span class="comment">// true, &#x27;123&#x27; 会先变成 123</span></span><br><span class="line"><span class="string">&#x27;&#x27;</span> == <span class="number">0</span> <span class="comment">// true, &#x27;&#x27; 会首先变成 0</span></span><br></pre></td></tr></table></figure><ul><li>规则 4：null == undefined比较结果是true，除此之外，null、undefined和其他任何结果的比较值都为false。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">null</span> == <span class="literal">undefined</span> <span class="comment">// true</span></span><br><span class="line"><span class="literal">null</span> == <span class="string">&#x27;&#x27;</span> <span class="comment">// false</span></span><br><span class="line"><span class="literal">null</span> == <span class="number">0</span> <span class="comment">// false</span></span><br><span class="line"><span class="literal">null</span> == <span class="literal">false</span> <span class="comment">// false</span></span><br><span class="line"><span class="literal">undefined</span> == <span class="string">&#x27;&#x27;</span> <span class="comment">// false</span></span><br><span class="line"><span class="literal">undefined</span> == <span class="number">0</span> <span class="comment">// false</span></span><br><span class="line"><span class="literal">undefined</span> == <span class="literal">false</span> <span class="comment">// false</span></span><br></pre></td></tr></table></figure></li><li>规则 5：原始类型和引用类型做比较时，引用类型会依照<code>ToPrimitive</code>规则转换为原始类型。<blockquote><p><code>ToPrimitive</code>规则，是引用类型向原始类型转变的规则，它遵循先<code>valueOf</code>后<code>toString</code>的模式期望得到一个原始类型。<br>如果还是没法得到一个原始类型，就会抛出 <code>TypeError</code>。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;[object Object]&#x27;</span> == &#123;&#125; </span><br><span class="line"><span class="comment">// true, 对象和字符串比较，对象通过 toString 得到一个基本类型值</span></span><br><span class="line"><span class="string">&#x27;1,2,3&#x27;</span> == [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>] </span><br><span class="line"><span class="comment">// true, 同上  [1, 2, 3]通过 toString 得到一个基本类型值</span></span><br></pre></td></tr></table></figure></li></ul><p>附录：<br><img src="https://greenhaha.oss-cn-beijing.aliyuncs.com/frontend/assets/img/convert-table.png" alt="附录"></p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;</summary>
        
      
    
    
    
    <category term="知识剖析" scheme="http://example.com/categories/%E7%9F%A5%E8%AF%86%E5%89%96%E6%9E%90/"/>
    
    
    <category term="JavaScript" scheme="http://example.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>TS 类型中的 any、void 和 never</title>
    <link href="http://example.com/2021/08/25/TS%E7%B1%BB%E5%9E%8B%E4%B8%ADany%C2%B7void%C2%B7never/"/>
    <id>http://example.com/2021/08/25/TS%E7%B1%BB%E5%9E%8B%E4%B8%ADany%C2%B7void%C2%B7never/</id>
    <published>2021-08-25T02:11:51.000Z</published>
    <updated>2024-01-02T01:12:08.502Z</updated>
    
    <content type="html"><![CDATA[<p>在ts的类型中常见的类型<code>number</code>, <code>string</code>, <code>boolean</code>等之外, 也有其他不直观的类型表达<code>any</code> <code>void</code> <code>never</code></p><h2 id="any-类型"><a href="#any-类型" class="headerlink" title="any 类型"></a>any 类型</h2><p>在一些情况下，如果我们无法确定变量的类型时（或者无需确认类型时），我们可以将其指定为 any 类型。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isNumber</span>(<span class="params">value: any</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">typeof</span> value === <span class="string">&#x27;number&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上，TS中对于被标记为 <code>any</code> 类型的变量，是没有进行类型检查而直接通过编译阶段的检查。</p><blockquote><p>We want to opt-out of type checking and let the values pass through compile-time checks. To do so, we label these with the any type.</p></blockquote><p>就个人来说，使用ts 的目的是为了提高并保证系统的健壮性，而<code>any</code>类型却没有进行类型的检查直接通过编译阶段对系统的稳定性来说有一定影响</p><h3 id="any-类型的特点"><a href="#any-类型的特点" class="headerlink" title="any 类型的特点"></a>any 类型的特点</h3><ul><li>允许赋值为任意类型<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> value: any = <span class="string">&#x27;seven&#x27;</span>;</span><br><span class="line">value = <span class="number">7</span>;</span><br></pre></td></tr></table></figure></li><li>可以访问任意属性和方法<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> value: any = <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以访问任意属性</span></span><br><span class="line"><span class="built_in">console</span>.log(value.name);</span><br><span class="line"><span class="built_in">console</span>.log(value.name.firstName);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以调用任意方法</span></span><br><span class="line">value.setName(<span class="string">&#x27;Jerry&#x27;</span>);</span><br><span class="line">value.setName(<span class="string">&#x27;Jerry&#x27;</span>).sayHello();</span><br><span class="line">value.name.setFirstName(<span class="string">&#x27;Cat&#x27;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>当变量为任意值之后，对它的任何操作返回的内容的类型都是任意值。很容易让某一块代码变得难以维护，丧失了静态类型检查阶段发现错误的可能性</li></ul><h3 id="变量如果在声明的时候，未指定其类型，那么它会被识别为任意值类型"><a href="#变量如果在声明的时候，未指定其类型，那么它会被识别为任意值类型" class="headerlink" title="变量如果在声明的时候，未指定其类型，那么它会被识别为任意值类型"></a>变量如果在声明的时候，未指定其类型，那么它会被识别为任意值类型</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> value;</span><br><span class="line">value = <span class="string">&#x27;seven&#x27;</span>;</span><br><span class="line">value = <span class="number">7</span>;</span><br></pre></td></tr></table></figure><p>未声明类型的变量虽然一开始被识别为 any 类型，但是经过赋值后，TS 会根据赋值类型来标识变量的类型</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> value;</span><br><span class="line"></span><br><span class="line">value = <span class="string">&#x27;seven&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> diff1 = value - <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 类型检查错误： The left-hand side of an arithmetic operation must be of type &#x27;any&#x27;, &#x27;number&#x27;, &#x27;bigint&#x27; or an enum type</span></span><br><span class="line"></span><br><span class="line">value = <span class="number">7</span>;</span><br><span class="line">cosnt diff2 = value - <span class="number">1</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="void-类型"><a href="#void-类型" class="headerlink" title="void 类型"></a>void 类型</h3><p><code>void</code> 类型表示没有任何类型</p><blockquote><p>void is a little like the opposite of any: the absence of having any type at all</p></blockquote><p>没有返回值的函数，其返回值类型为 <code>void</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;this is foo function&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>声明为<code>void</code>类型的变量，只能赋予<code>undefined</code>和<code>null</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> unusable: <span class="keyword">void</span> = <span class="literal">undefined</span>;</span><br></pre></td></tr></table></figure><h2 id="never"><a href="#never" class="headerlink" title="never"></a>never</h2><p><code>never</code> 类型表示永远不会有值的一种类型。(很抽象是不是)</p><blockquote><p>The never type represents the type of values that never occur.</p></blockquote><ul><li>never类型是那些总是会抛出异常或根本就不会有返回值的函数表达式或箭头函数表达式的返回值类型<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回never的函数必须存在无法达到的终点</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 因为总是抛出异常，所以 error 将不会有返回值</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">error</span>(<span class="params">message: string</span>): <span class="title">never</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(message);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 因为存在死循环，所以 infiniteLoop 将不会有返回值</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">infiniteLoop</span>(<span class="params"></span>): <span class="title">never</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>永远不可能存在的情况：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> foo = <span class="number">123</span>;</span><br><span class="line"><span class="keyword">if</span> (foo !== <span class="number">123</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> bar = foo;    <span class="comment">// bar: never</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="never-和-void-的差异"><a href="#never-和-void-的差异" class="headerlink" title="never 和 void 的差异"></a>never 和 void 的差异</h3><code>void</code> 表示没有任何类型，<code>never</code> 表示永远不存在的值的类型。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回never的函数必须存在无法达到的终点</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">infiniteLoop</span>(<span class="params"></span>): <span class="title">never</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个函数不能申明其返回值类型是 never</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">warnUser</span>(<span class="params"></span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;This is my warning message&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;</summary>
        
      
    
    
    
    <category term="知识剖析" scheme="http://example.com/categories/%E7%9F%A5%E8%AF%86%E5%89%96%E6%9E%90/"/>
    
    
    <category term="JavaScript" scheme="http://example.com/tags/JavaScript/"/>
    
    <category term="函数式编程" scheme="http://example.com/tags/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
    
    <category term="ELM" scheme="http://example.com/tags/ELM/"/>
    
  </entry>
  
  <entry>
    <title>ELM 编程语言</title>
    <link href="http://example.com/2021/08/20/elm/"/>
    <id>http://example.com/2021/08/20/elm/</id>
    <published>2021-08-20T02:11:51.000Z</published>
    <updated>2024-01-02T01:12:08.503Z</updated>
    
    <content type="html"><![CDATA[<p>在一个晴朗的午后，我正在拿我的专属神器‘保温杯’在快乐的划水摸鱼中，此时一个惊天阴谋将发生。项目经理面带微笑的走过来说：接下来开发会需要用到 ‘ELM’，你好好看看学一学！说完就离开了，留下了一脸楞逼的我。 ‘ELM’是啥？ELM能干什么？ELM应该怎么干？ 素质三连问？—– 中二病又犯了_(:3 LZ)_</p><h2 id="ELM-是什么？"><a href="#ELM-是什么？" class="headerlink" title="ELM 是什么？"></a>ELM 是什么？</h2><p>对于第一次接触的小伙伴来说估计也是一脸懵逼中，‘ELM’？==》‘element’ ==》‘饿了么’！机智如我<span class="blur">智障如我</span>。不用学，不久‘饿了么’，简单小菜一碟。然而google一下之后发现事情远远没有那么简单。</p><blockquote><p>Elm是一个领域特定编程语言，用于声明式的创建基于web浏览器的图形用户界面。Elm是纯函数式的，开发它时强调了易用性、性能和健壮性。它宣传为“实际上没有运行时间异常”，Elm编译器的静态类型检查使之成为可能。   —–维基百科</p></blockquote><p>一个领域特定编程语言？纯函数式？runningtime no error？静态类型检查？看介绍好高大上。机智的我搜索打开<a href="https://elm-lang.org/">ELM官网</a>。官网中第一句话就是：A delightful language<br>for reliable web applications.（对于开发web应用程序这是一个令开发者兴奋的语言 — 抱歉中文是我翻译的，然后之后我会对delightful这个词有一个新的理解 无论精神上还是肉体上）</p><p> <img src="https://greenhaha.oss-cn-beijing.aliyuncs.com/frontend/assets/img/elmindex.png" alt="elm 首页"></p><p>那么回到正题：ELM是什么？<br>官网给出了回答：ELM是一个可以编译成JavaScript的纯函数语言。其实说直白一点就是他也算是前端语言吧，不过他需要自己的解释器将对应的语法翻译成JavaScript最终在浏览器上执行。并且redux的产生于设计思想其实是借鉴ELM。<br>EML和JavaScript不同，虽然最终解释运行在浏览器上，但是开发的语法却和JavaScript不同。ELM的编译器使用的Haskell语法，你可以把它理解成是一个纯函数语法，和JavaScript有点相似但是与JavaScript又完全不同。之后会说到的。他有自己的运行环境：elm-live 或者是elm-go。是实施提供了elm的热更功能。不要问我为啥知道，这就是我在上面提到的 ‘delightful’的原因</p><h2 id="ELM能干什么"><a href="#ELM能干什么" class="headerlink" title="ELM能干什么"></a>ELM能干什么</h2><p>这个是重点：ELM有自己的语法，因为他是一门语言并且最终解释称JavaScript并在浏览器上运行。因此ELM有自己的数据更新机制，这套机制和redux相似：<br><img src="https://greenhaha.oss-cn-beijing.aliyuncs.com/frontend/assets/img/buttons.svg" alt="elm 更新机制"></p><p>ELM生成的HTML可以在屏幕上显示，而这种运行其实可以分为三个部分</p><ul><li>Model  — 可以理解为应用的状态（打比方的话可以认为是redux的全局state）</li><li>View   — 可以认为是视图层，把state放知道html上</li><li>Update — 用于更新应用的状态的（打比方的话可以认为是reducer）</li></ul><p>其实仔细一品的话其实就会发现，这特喵的不就和react 一个组件的内部更新一样吗。（原谅我不厚道的笑出了猪声）</p><h2 id="ELM应该怎么干？"><a href="#ELM应该怎么干？" class="headerlink" title="ELM应该怎么干？"></a>ELM应该怎么干？</h2><p>一个就简单的例子（hasekell语法需要自己学习）：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Browser</span><br><span class="line"><span class="keyword">import</span> Html exposing (Html, button, div, text)</span><br><span class="line"><span class="keyword">import</span> Html.Events exposing (onClick)</span><br><span class="line"></span><br><span class="line">-- MAIN</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">main =</span><br><span class="line">  Browser.sandbox &#123; init = init, update = update, view = view &#125;</span><br><span class="line"></span><br><span class="line">-- MODEL</span><br><span class="line"></span><br><span class="line">type alias Model = Int</span><br><span class="line"></span><br><span class="line"><span class="attr">init</span> : Model</span><br><span class="line">init =</span><br><span class="line">  <span class="number">0</span></span><br><span class="line"></span><br><span class="line">-- UPDATE</span><br><span class="line"></span><br><span class="line">type Msg = Increment | Decrement</span><br><span class="line"></span><br><span class="line"><span class="attr">update</span> : Msg -&gt; Model -&gt; Model</span><br><span class="line">update msg model =</span><br><span class="line">  <span class="keyword">case</span> msg <span class="keyword">of</span></span><br><span class="line">    Increment -&gt;</span><br><span class="line">      model + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    Decrement -&gt;</span><br><span class="line">      model - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">-- VIEW</span><br><span class="line"></span><br><span class="line"><span class="attr">view</span> : Model -&gt; Html Msg</span><br><span class="line">view model =</span><br><span class="line">  div []</span><br><span class="line">    [ button [ onClick Decrement ] [ text <span class="string">&quot;-&quot;</span> ]</span><br><span class="line">    , div [] [ text (<span class="built_in">String</span>.fromInt model) ]</span><br><span class="line">    , button [ onClick Increment ] [ text <span class="string">&quot;+&quot;</span> ]</span><br><span class="line">    ]</span><br></pre></td></tr></table></figure><h3 id="Main"><a href="#Main" class="headerlink" title="Main"></a>Main</h3><p><code>Main</code>函数对于ELM来说是特别的，它是用来在屏幕上描述显示HMLT的，你可以理解为它是一个沙盒。在程序init值初始化后，<code>view</code>函数会把view中的所有内容描述在屏幕上。</p><h3 id="Model"><a href="#Model" class="headerlink" title="Model"></a>Model</h3><p>state在ELM中时极其重要的存在，Model存在的重点是捕获收集当前应用的所有详细信息数据，而在上面的例子中则是当作一个计数器来使用</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type alias Model = init</span><br></pre></td></tr></table></figure><p>由于ELM是静态类型检验，所有在定义类型后需要给予初始值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">init : Model</span><br><span class="line">init = <span class="number">0</span></span><br></pre></td></tr></table></figure><h3 id="View"><a href="#View" class="headerlink" title="View"></a>View</h3><p>画面是如何呈现在屏幕上，这是则需要<code>View</code>函数。<br>上面的例子中：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">view : Model -&gt; Html Msg</span><br><span class="line">view model =</span><br><span class="line">  div []</span><br><span class="line">    [ button [ onClick Decrement ] [ text <span class="string">&quot;-&quot;</span> ]</span><br><span class="line">    , div [] [ text (<span class="built_in">String</span>.fromInt model) ]</span><br><span class="line">    , button [ onClick Increment ] [ text <span class="string">&quot;+&quot;</span> ]</span><br><span class="line">    ]</span><br></pre></td></tr></table></figure><p>他接受一个Model作为参数 并且输出HTML信息。（在ELM中静态类型校验是无处不在的）</p><h3 id="Update"><a href="#Update" class="headerlink" title="Update"></a>Update</h3><p><code>update</code>函数则是描述了Model中state的值如何更新<br>更具例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type Msg = Increment | Decrement</span><br></pre></td></tr></table></figure><p>当收到触发的Msg的时候就会在更新函数中对Model中state进行更新</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">update : Msg -&gt; Model -&gt; Model</span><br><span class="line">update msg model =</span><br><span class="line">  <span class="keyword">case</span> msg <span class="keyword">of</span></span><br><span class="line">    Increment -&gt;</span><br><span class="line">      model + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    Decrement -&gt;</span><br><span class="line">      model - <span class="number">1</span></span><br></pre></td></tr></table></figure><p>上面的例子就是一个最基础的ELM的demo。通过点击按钮更新页面上的内容。<br>运行机制的话如下图所示：<br><img src="https://greenhaha.oss-cn-beijing.aliyuncs.com/frontend/assets/img/elm%E6%95%B0%E6%8D%AE%E6%B5%81.png" alt="elm 数据流"></p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;</summary>
        
      
    
    
    
    <category term="文档教程" scheme="http://example.com/categories/%E6%96%87%E6%A1%A3%E6%95%99%E7%A8%8B/"/>
    
    
    <category term="JavaScript" scheme="http://example.com/tags/JavaScript/"/>
    
    <category term="函数式编程" scheme="http://example.com/tags/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
    
    <category term="ELM" scheme="http://example.com/tags/ELM/"/>
    
  </entry>
  
  <entry>
    <title>常用布局</title>
    <link href="http://example.com/2021/07/23/%E5%B8%B8%E7%94%A8%E5%B8%83%E5%B1%80/"/>
    <id>http://example.com/2021/07/23/%E5%B8%B8%E7%94%A8%E5%B8%83%E5%B1%80/</id>
    <published>2021-07-23T13:05:22.000Z</published>
    <updated>2024-01-02T01:12:08.528Z</updated>
    
    <content type="html"><![CDATA[<h1 id="常用布局"><a href="#常用布局" class="headerlink" title="常用布局"></a>常用布局</h1><h2 id="正常布局流-Normal-flow"><a href="#正常布局流-Normal-flow" class="headerlink" title="正常布局流(Normal flow)"></a>正常布局流(Normal flow)</h2><p>正常布局流（normal flow）是指在不对页面进行任何布局控制时，浏览器默认的HTML布局方式<br>其实总结一句话：原生态，没有任何修饰行css。遵循最基本的BFC布局</p><blockquote><p>BFC(Block formatting context)直译为”块级格式化上下文”。它是一个独立的渲染区域，只有Block-level box参与（在下面有解释）， 它规定了内部的Block-level Box如何布局，并且与这个区域外部毫不相干。所谓的BFC就是css布局的一个概念，是一块区域，一个环境</p></blockquote><h2 id="弹性盒子（Flexbox）"><a href="#弹性盒子（Flexbox）" class="headerlink" title="弹性盒子（Flexbox）"></a>弹性盒子（Flexbox）</h2><p>弹性盒子（Flexbox）是CSS弹性盒子布局模块（<a href="https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Flexible_Box_Layout">Flexible Box Layout</a> Module）的缩写。专门设计出来用于创建横向或是纵向的一维页面布局。</p><p>弹性盒子布局是css的模块之一，它定义了一种对用户界面设计而优化的css盒子模型。在弹性布局模型中，弹性容器的子元素可以在容器中任意方向上排列，可以“任意伸缩”其尺寸</p><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p><img src="https://greenhaha.oss-cn-beijing.aliyuncs.com/frontend/assets/img/flex.png" alt="flex原理图"></p><p>要理解flex布局需要明白flex容器它是有2个轴线的，水平主轴（main axis）和垂直的交叉轴（cross axis）。水平轴和垂直轴是可以通过修改来变幻的，使垂直轴变成主轴，水平方向变成交叉轴。<br>在容器中，每个子元素（单元块）成为 flex item。每个单元占据的主轴空间为（mian size），占据的交叉轴空间为（cross size）<br>main size 不等于 宽度  cross size 不等于 高度。这两个值取决于当前主轴方向，如果垂直方向是主轴，那么单元的高度就是main size</p><h3 id="Flex-容器"><a href="#Flex-容器" class="headerlink" title="Flex 容器"></a>Flex 容器</h3><p>flex容器对于实现flex布局是一个很重要的存在。实现一个flex布局需要先制定一个容器。任何一个容器都可以被指定为flex布局。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: flex | inline-flex;       //可以有两种取值</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分别生成一个块状或行内的 flex 容器盒子。简单说来，如果你使用块元素如 div，你就可以使用 flex，而如果你使用行内元素，你可以使用 inline-flex。</p><blockquote><p>需要注意的是：当时设置 flex 布局之后，子元素的 float、clear、vertical-align 的属性将会失效</p></blockquote><p>有下面六种属性可以设置在容器上，它们分别是：</p><ul><li>flex-direction ()</li><li>flex-wrap</li><li>flex-flow</li><li>justify-content</li><li>align-items</li><li>align-content</li></ul><h4 id="flex-direction-决定主轴的方向（即容器中子元素排列方向）"><a href="#flex-direction-决定主轴的方向（即容器中子元素排列方向）" class="headerlink" title="flex-direction: 决定主轴的方向（即容器中子元素排列方向）"></a>flex-direction: 决定主轴的方向（即容器中子元素排列方向）</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">flex-direction</span>: row | row-reverse | column | column-reverse;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>默认值：row 主轴为水平方向，起点在左端<br><img src="https://greenhaha.oss-cn-beijing.aliyuncs.com/frontend/assets/img/flex-directionrow.png" alt="flex-direction:row"></p><p>row-reverse：主轴为水平防线，起点在右端<br><img src="https://greenhaha.oss-cn-beijing.aliyuncs.com/frontend/assets/img/row-reverse.png" alt="row-reverse"></p><p>column:主轴为垂直方向，起点在最上面<br><img src="https://greenhaha.oss-cn-beijing.aliyuncs.com/frontend/assets/img/column.png"></p><p>column-reverse:主轴为垂直方向，起点在最下面<br><img src="https://greenhaha.oss-cn-beijing.aliyuncs.com/frontend/assets/img/row-reverse.png" alt="column-reverse"></p><h4 id="flex-wrap-决定容器中子元素是否可以换行"><a href="#flex-wrap-决定容器中子元素是否可以换行" class="headerlink" title="flex-wrap: 决定容器中子元素是否可以换行"></a>flex-wrap: 决定容器中子元素是否可以换行</h4><p>默认情况下，子元素都会排列在主轴上（实际就是一行上），使用flex-wrap 可实现容器中子元素的换行</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">flex-wrap</span>: nowrap | wrap | wrap-reverse;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>默认值：nowrap 不换行，即当主轴尺寸固定是时，当空间不足时，子元素尺寸会随之调整并不会挤到下一行<br><img src="https://greenhaha.oss-cn-beijing.aliyuncs.com/frontend/assets/img/nowrap.png" alt="nowrap"></p><p>wrap： 子元素在主轴排列的时候超出容器时换行 在第一行的上方<br><img src="https://greenhaha.oss-cn-beijing.aliyuncs.com/frontend/assets/img/wrap.png" alt="wrap"></p><p>wrap-reverse: 换行 在第一行的下方<br><img src="https://greenhaha.oss-cn-beijing.aliyuncs.com/frontend/assets/img/wrap-reverse.png" alt="wrap-reverse"></p><h4 id="flex-flow-flex-direction和flex-wrap的简写形式"><a href="#flex-flow-flex-direction和flex-wrap的简写形式" class="headerlink" title="flex-flow: flex-direction和flex-wrap的简写形式"></a>flex-flow: flex-direction和flex-wrap的简写形式</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">flex-flow</span>: &lt;flex-direction&gt; || &lt;flex-wrap&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>默认值为: row nowrap，感觉没什么卵用</p><h4 id="justify-content：定义了项目在主轴的对齐方式"><a href="#justify-content：定义了项目在主轴的对齐方式" class="headerlink" title="justify-content：定义了项目在主轴的对齐方式"></a>justify-content：定义了项目在主轴的对齐方式</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">justify-content</span>: flex-start | flex-end | center | space-between | space-around;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>建立在主轴为水平方向时测试，即 flex-direction: row</p></blockquote><p>默认值: flex-start 左对齐<br><img src="https://greenhaha.oss-cn-beijing.aliyuncs.com/frontend/assets/img/flex-start.png" alt="flex-start"></p><p>flex-end: 右对齐<br><img src="https://greenhaha.oss-cn-beijing.aliyuncs.com/frontend/assets/img/flex-end.png" alt="flex-end"></p><p>center:  居中<br><img src="https://greenhaha.oss-cn-beijing.aliyuncs.com/frontend/assets/img/center.png" alt="center"></p><p>space-between: 两端对齐，子元素之间的间隔相等，剩余空间平均分配间隙相同<br><img src="https://greenhaha.oss-cn-beijing.aliyuncs.com/frontend/assets/img/space-between.png" alt="space-between"></p><p>space-around: 每个项目两侧的间隔相同，子元素之间的间隔比子元素与边缘的间隔大一倍<br><img src="https://greenhaha.oss-cn-beijing.aliyuncs.com/frontend/assets/img/space-around.png" alt="space-around"></p><h4 id="align-items-定义了子元素在交叉轴上的对其方式"><a href="#align-items-定义了子元素在交叉轴上的对其方式" class="headerlink" title="align-items: 定义了子元素在交叉轴上的对其方式"></a>align-items: 定义了子元素在交叉轴上的对其方式</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">align-items</span>: flex-start | flex-end | center | baseline | stretch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>默认值：<code>stretch</code> 即如果子元素没有设置高度或者为auto，将充满整个容器的高度<br><img src="https://greenhaha.oss-cn-beijing.aliyuncs.com/frontend/assets/img/stretch.png" alt="stretch"><br>假设容器高度设置为 100px，而项目都没有设置高度的情况下，则项目的高度也为 100px。</p><ul><li>flex-start: 交叉轴起点对齐</li></ul><p><img src="https://greenhaha.oss-cn-beijing.aliyuncs.com/frontend/assets/img/alignitemflex-start.png" alt="alignitemflex-start"><br>假设容器高度设置为 100px，而项目分别为 20px, 40px, 60px, 80px, 100px, 则如上图显示。</p><ul><li>flex-end: 交叉轴的终点对齐</li></ul><p><img src="https://greenhaha.oss-cn-beijing.aliyuncs.com/frontend/assets/img/alignitemflexend.png" alt="alignitem-flexend"></p><ul><li>center: 交叉轴的中点对齐</li></ul><p><img src="https://greenhaha.oss-cn-beijing.aliyuncs.com/frontend/assets/img/alignitemcenter.png" alt="alignitemcenter"></p><ul><li>baseline: 项目的第一行文字的基线对齐</li></ul><p><img src="https://greenhaha.oss-cn-beijing.aliyuncs.com/frontend/assets/img/alignitembaseline.png" alt="baseline"><br>以文字的底部为主，仔细看图可以理解。</p><h4 id="align-content-定义了多根轴线的对齐方式，如果项目只有一根轴线，那么该属性将不起作用"><a href="#align-content-定义了多根轴线的对齐方式，如果项目只有一根轴线，那么该属性将不起作用" class="headerlink" title="align-content: 定义了多根轴线的对齐方式，如果项目只有一根轴线，那么该属性将不起作用"></a>align-content: 定义了多根轴线的对齐方式，如果项目只有一根轴线，那么该属性将不起作用</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">align-content</span>: flex-start | flex-end | center | space-between | space-around | stretch;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>当<code>flex-wrap</code>设置之后 默认情况下 容器中只会有一条轴线，子元素是不会换行的，因此不会产生其他轴线。<br>但是<code>flex-wrap</code>设置为<code>wrap</code> 换行属性之后，容器中可能会出现其他轴线，这时候就需要去设置轴线的对齐方式了</p><ul><li>默认值：stretch<br><img src="https://greenhaha.oss-cn-beijing.aliyuncs.com/frontend/assets/img/aligncontentstretch.png" alt="aligncontentstretch"><br>从图可以看出又三条轴线(因为容器宽度有限)，当值为 stretch 时会三条轴线平分容器的垂直方向上的空间。</li></ul><p>虽然在每条轴线上项目的默认值也为 stretch，但是由于我每个子元素我都设置了高度，所以它并没有撑开整个容器。如果项目不设置高度的话就会变成下面这样：<br><img src="https://greenhaha.oss-cn-beijing.aliyuncs.com/frontend/assets/img/aligncontentstretch2.png" alt="aligncontentstretch"><br>前面也有提到(align-items)，这里重点还是理解三条轴线会平分垂直轴上的空间。</p><ul><li><p>flex-start：轴线全部在交叉轴上的起点对齐<br><img src="https://greenhaha.oss-cn-beijing.aliyuncs.com/frontend/assets/img/aligncontentflexstart.png" alt="aligncontentflexstart"></p></li><li><p>flex-end：轴线全部在交叉轴上的终点对齐<br><img src="https://greenhaha.oss-cn-beijing.aliyuncs.com/frontend/assets/img/aligncontentflexend.png" alt="aligncontentflexend"></p></li><li><p>center: 轴线全部在交叉轴上的中间对齐<br><img src="https://greenhaha.oss-cn-beijing.aliyuncs.com/frontend/assets/img/aligncontentcenter.png" alt="aligncontencenter"></p></li><li><p>space-between: 轴线两端对齐，之间的间隔相等，即剩余空间等分成间隙<br><img src="https://greenhaha.oss-cn-beijing.aliyuncs.com/frontend/assets/img/aligncontentspacebetween.png" alt="aligncontentspacebetween"></p></li><li><p>space-around：每个轴线两侧的间隔相等，所以轴线之间的间隔比轴线与边缘的间隔大一倍。</p></li></ul><p><img src="https://greenhaha.oss-cn-beijing.aliyuncs.com/frontend/assets/img/aligncontentspacearound.png" alt="aligncontentspacearound"></p><h3 id="Flex-子元素"><a href="#Flex-子元素" class="headerlink" title="Flex 子元素"></a>Flex 子元素</h3><ul><li>order</li><li>flex-basis</li><li>flex-grow</li><li>flex-shrink</li><li>flex</li><li>align-self</li></ul><p>以上6中属性作用在子元素上</p><ul><li>order: 定义项目在容器中的排列顺序，数值越小，排列越靠前，默认值为 0<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">    <span class="attribute">order</span>: &lt;integer&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><img src="https://greenhaha.oss-cn-beijing.aliyuncs.com/frontend/assets/img/order.png" alt="order"></p><p>在 HTML 结构中，虽然 -2，-1 的 item 排在后面，但是由于分别设置了 order，使之能够排到最前面。<br>可以理解为order 数值越小排列的时候越排在前面</p><ul><li>flex-basis：定义了在分配多余空间之前，项目占据的主轴空间，浏览器根据这个属性，计算主轴是否有多余空间</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">    <span class="attribute">flex-basis</span>: &lt;length&gt; | auto;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>默认值：auto，即子元素自身大小，<br>当主轴为水平方向的时候，当设置了 flex-basis，项目的宽度设置值会失效，flex-basis 需要跟 flex-grow 和 flex-shrink 配合使用才能发挥效果。</p><blockquote><ul><li>当 flex-basis 值为 0 % 时，是把该项目视为零尺寸的，故即使声明该尺寸为 140px，也并没有什么用。</li><li>当 flex-basis 值为 auto 时，则跟根据尺寸的设定值(假如为 100px)，则这 100px 不会纳入剩余空间。</li></ul></blockquote><ul><li>flex-grow:定义子元素放大比例</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">    <span class="attribute">flex-grow</span>: &lt;number&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>默认值：0，flex布局后即使存在剩余空间也不会放大<br><img src="https://greenhaha.oss-cn-beijing.aliyuncs.com/frontend/assets/img/flexgrow.png" alt="flexgrow"><br>当所有的项目都以 flex-basis 的值进行排列后，仍有剩余空间，那么这时候 flex-grow 就会发挥作用了。<br>如果所有项目的 flex-grow 属性都为 1，则它们将等分剩余空间。(如果有的话)</p><p>如果一个项目的 flex-grow 属性为 2，其他项目都为 1，则前者占据的剩余空间将比其他项多一倍。</p><p>当然如果当所有项目以 flex-basis 的值排列完后发现空间不够了，且 flex-wrap：nowrap 时，此时 flex-grow 则不起作用了，这时候就需要接下来的这个属性。</p><ul><li>flex-shrink:定义了项目的缩小比例</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">    <span class="attribute">flex-shrink</span>: &lt;number&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>默认值: 1，即如果空间不足，该项目将缩小，负值对该属性无效。<br><img src="https://greenhaha.oss-cn-beijing.aliyuncs.com/frontend/assets/img/flexshrink.png" alt="flex-shrink"><br>每个子元素都设置了宽度为 50px，但是由于自身容器宽度只有 200px，这时候每个子元素会被同比例进行缩小，因为默认值为 1。</p><blockquote><ul><li>如果所有项目的 flex-shrink 属性都为 1，当空间不足时，都将等比例缩小。</li><li>如果一个项目的 flex-shrink 属性为 0，其他项目都为 1，则空间不足时，前者不缩小。</li></ul></blockquote><ul><li>flex: flex-grow, flex-shrink 和 flex-basis的简写</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item</span>&#123;</span><br><span class="line">    <span class="attribute">flex</span>: none | [ &lt;<span class="string">&#x27;flex-grow&#x27;</span>&gt; &lt;<span class="string">&#x27;flex-shrink&#x27;</span>&gt;? || &lt;<span class="string">&#x27;flex-basis&#x27;</span>&gt; ]</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>flex 的默认值是以上三个属性值的组合。假设以上三个属性同样取默认值，则 flex 的默认值是 0 1 auto。</p><p>有关快捷值：auto (1 1 auto) 和 none (0 0 auto)</p><p>关于 flex 取值，还有许多特殊的情况，可以按以下来进行划分：</p><p>当 flex 取值为一个非负数字，则该数字为 flex-grow 值，flex-shrink 取 1，flex-basis 取 0%，如下是等同的：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;<span class="attribute">flex</span>: <span class="number">1</span>;&#125;</span><br><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">    <span class="attribute">flex-grow</span>: <span class="number">1</span>;</span><br><span class="line">    <span class="attribute">flex-shrink</span>: <span class="number">1</span>;</span><br><span class="line">    <span class="attribute">flex-basis</span>: <span class="number">0%</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当 flex 取值为 0 时，对应的三个值分别为 0 1 0%</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;<span class="attribute">flex</span>: <span class="number">0</span>;&#125;</span><br><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">    <span class="attribute">flex-grow</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">flex-shrink</span>: <span class="number">1</span>;</span><br><span class="line">    <span class="attribute">flex-basis</span>: <span class="number">0%</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当 flex 取值为一个长度或百分比，则视为 flex-basis 值，flex-grow 取 1，flex-shrink 取 1，有如下等同情况（注意 0% 是一个百分比而不是一个非负数字）</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item-1</span> &#123;<span class="attribute">flex</span>: <span class="number">0%</span>;&#125;</span><br><span class="line"><span class="selector-class">.item-1</span> &#123;</span><br><span class="line">    <span class="attribute">flex-grow</span>: <span class="number">1</span>;</span><br><span class="line">    <span class="attribute">flex-shrink</span>: <span class="number">1</span>;</span><br><span class="line">    <span class="attribute">flex-basis</span>: <span class="number">0%</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.item-2</span> &#123;<span class="attribute">flex</span>: <span class="number">24px</span>;&#125;</span><br><span class="line"><span class="selector-class">.item-2</span> &#123;</span><br><span class="line">    <span class="attribute">flex-grow</span>: <span class="number">1</span>;</span><br><span class="line">    <span class="attribute">flex-shrink</span>: <span class="number">1</span>;</span><br><span class="line">    <span class="attribute">flex-basis</span>: <span class="number">24px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当 flex 取值为两个非负数字，则分别视为 flex-grow 和 flex-shrink 的值，flex-basis 取 0%，如下是等同的：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;<span class="attribute">flex</span>: <span class="number">2</span> <span class="number">3</span>;&#125;</span><br><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">    <span class="attribute">flex-grow</span>: <span class="number">2</span>;</span><br><span class="line">    <span class="attribute">flex-shrink</span>: <span class="number">3</span>;</span><br><span class="line">    <span class="attribute">flex-basis</span>: <span class="number">0%</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当 flex 取值为一个非负数字和一个长度或百分比，则分别视为 flex-grow 和 flex-basis 的值，flex-shrink 取 1，如下是等同的：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;<span class="attribute">flex</span>: <span class="number">11</span> <span class="number">32px</span>;&#125;</span><br><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">    <span class="attribute">flex-grow</span>: <span class="number">11</span>;</span><br><span class="line">    <span class="attribute">flex-shrink</span>: <span class="number">1</span>;</span><br><span class="line">    <span class="attribute">flex-basis</span>: <span class="number">32px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>建议优先使用这个属性，而不是单独写三个分离的属性。</p><p>grow 和 shrink 是一对双胞胎，grow 表示伸张因子，shrink 表示是收缩因子。</p><p>grow 在 flex 容器下的子元素的宽度和比容器和小的时候起作用。 grow 定义了子元素的尺寸增长因子，容器中除去子元素之和剩下的尺寸会按照各个子元素的 grow 值进行平分加大各个子元素上。</p><blockquote><ul><li>当 flex-wrap 为 wrap | wrap-reverse，且子项宽度和不及父容器宽度时，flex-grow 会起作用，子项会根据 flex-grow 设定的值放大（为0的项不放大）</li><li>当 flex-wrap 为 wrap | wrap-reverse，且子项宽度和超过父容器宽度时，首先一定会换行，换行后，每一行的右端都可能会有剩余空间（最后一行包含的子项可能比前几行少，所以剩余空间可能会更大），这时 flex-grow 会起作用，若当前行所有子项的 flex-grow 都为0，则剩余空间保留，若当前行存在一个子项的 flex-grow 不为0，则剩余空间会被 flex-grow 不为0的子项占据</li><li>当 flex-wrap 为 nowrap，且子项宽度和不及父容器宽度时，flex-grow 会起作用，子项会根据 flex-grow 设定的值放大（为0的项不放大）</li><li>当 flex-wrap 为 nowrap，且子项宽度和超过父容器宽度时，flex-shrink 会起作用，子项会根据 flex-shrink 设定的值进行缩小（为0的项不缩小）。但这里有一个较为特殊情况，就是当这一行所有子项 flex-shrink 都为0时，也就是说所有的子项都不能缩小，就会出现讨厌的横向滚动条</li></ul></blockquote><p>总结上面四点，可以看出不管在什么情况下，在同一时间，flex-shrink 和 flex-grow 只有一个能起作用，这其中的道理细想起来也很浅显：空间足够时，flex-grow 就有发挥的余地，而空间不足时，flex-shrink 就能起作用。当然，flex-wrap 的值为 wrap | wrap-reverse 时，表明可以换行，既然可以换行，一般情况下空间就总是足够的，flex-shrink 当然就不会起作用</p><ul><li>align-self: 允许单个项目有与其他项目不一样的对齐方式</li></ul><p>每个子元素覆盖<code>align-self</code>定义的属性<br>默认值：auto，表示继承父元素的 align-items 属性，如果没有父元素，则等同于 stretch。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">     <span class="attribute">align-self</span>: auto | flex-start | flex-end | center | baseline | stretch;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这个跟 <code>align-items</code> 属性时一样的，只不过 <code>align-self</code> 是对单个子元素生效的，而 <code>align-items</code> 则是对容器下的所有子元素生效的。</p><p><img src="https://greenhaha.oss-cn-beijing.aliyuncs.com/frontend/assets/img/alignself.png" alt="align-self"><br>容器 align-items 设置为 flex-start，而第三</p><h2 id="Grid布局（网格布局）"><a href="#Grid布局（网格布局）" class="headerlink" title="Grid布局（网格布局）"></a>Grid布局（网格布局）</h2><p>Flexbox用于设计横向或纵向的布局，而Grid布局则被设计用于同时在两个维度上把元素按行和列排列整齐。它是最强大的css布局方案<br><br>它将网页划分成一个个网格，可以任意组合不同的网格，做出各种各样的布局。以前，只能通过复杂的 CSS 框架达到的效果，现在浏览器内置了<br><img src="https://greenhaha.oss-cn-beijing.aliyuncs.com/frontend/assets/img/gridcss.png" alt="grid"></p><p>Grid布局与Flex布局有一定的相似性，都可以指定容器内部多个项目的位置。但是他们有一定的区别。<br>Flex 布局是轴线布局，只能指定“项目”（子元素）针对轴线的位置，可以看作是一维布局。Grid布局则是将容器划分“行”和“列”，产生单元格，<br>然后指定“项目所在“的单元格。可以看作是二维布局。Grid布局远比Flex布局强大。</p><h3 id="基本概念-1"><a href="#基本概念-1" class="headerlink" title="基本概念"></a>基本概念</h3><ul><li>容器与项目<br>采用网格布局的区域，称为“容器”（container）。 容器内部采用网格定位的子元素。称为”项目“（item）<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;<span class="name">p</span>&gt;</span>1<span class="tag">&lt;/<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;<span class="name">p</span>&gt;</span>2<span class="tag">&lt;/<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;<span class="name">p</span>&gt;</span>3<span class="tag">&lt;/<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>上面代码中，最外层的<code>&lt;div&gt;</code>元素就是容器，内层的三个<code>&lt;div&gt;</code>元素就是项目。</li></ul><blockquote><p>注意：项目只能是容器的顶层子元素，不包含项目的子元素，比如上面代码的<code>&lt;p&gt;</code>元素就不是项目。Grid 布局只对项目生效。</p></blockquote><ul><li>行和列<br>容器里面的水平区域称为“行”（row），垂直区域称为“列”（column）<br><img src="https://greenhaha.oss-cn-beijing.aliyuncs.com/frontend/assets/img/row.png" alt="row-column"></li></ul><p>上图中，水平的深色区域就是”行”，垂直的深色区域就是”列”。</p><ul><li>单元格</li></ul><p>行和列的交叉区域，称为”单元格”（cell）。</p><p>正常情况下，n行和m列会产生n x m个单元格。比如，3行3列会产生9个单元格。</p><ul><li>网格线<br>划分网格的线，称为”网格线”（grid line）。水平网格线划分出行，垂直网格线划分出列。</li></ul><p>正常情况下，n行有n + 1根水平网格线，m列有m + 1根垂直网格线，比如三行就有四根水平网格线。</p><p><img src="https://greenhaha.oss-cn-beijing.aliyuncs.com/frontend/assets/img/%E7%BD%91%E6%A0%BC%E7%BA%BF.png" alt="网格线"><br>上图是一个 4 x 4 的网格，共有5根水平网格线和5根垂直网格线。</p><h3 id="容器属性"><a href="#容器属性" class="headerlink" title="容器属性"></a>容器属性</h3><p>Grid布局的属性分为2种，一种定义在容器上面，称为容器属性；另一种定义在项目上面，称为项目属性</p><ul><li>display属性<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span>&#123;</span><br><span class="line">    <span class="attribute">display</span>: grid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="https://greenhaha.oss-cn-beijing.aliyuncs.com/frontend/assets/img/displaygrid.png" alt="display:grid"><br>上图是<code>display: grid</code>的<a href="https://jsbin.com/guvivum/edit?html,css,output">效果</a>。</li></ul><p>默认情况下，容器元素都是块级元素，但也可以设计成行内元素</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span>&#123;</span><br><span class="line">    <span class="attribute">display</span>: inline-grid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码指定div 是一个行内元素并且该元素采用网格布局<br><img src="https://greenhaha.oss-cn-beijing.aliyuncs.com/frontend/assets/img/inlinegrid.png" alt="inlinegrid"></p><blockquote><p>注意⚠️： 设置为网格布局后，容器子元素的 <code>float</code>、<code>display: inline-block</code>、<code>dispaly: table-cell</code>、<code>vertical-align</code>、<code>column-*</code> 等设置都失效。</p></blockquote><ul><li>gird-template-columns 属性 &amp; grid-template-rows 属性<br>容器指定了网格布局以后，接着就要划分行和列。<code>grid-template-columns</code>属性定义每一列的列宽，<code>grid-template-rows</code>属性定义每一行的行高。</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: grid;</span><br><span class="line">    grid-template-<span class="attribute">columns</span>: <span class="number">100px</span> <span class="number">100px</span> <span class="number">100px</span>;</span><br><span class="line">    grid-template-rows: <span class="number">100px</span> <span class="number">100px</span> <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上方代码指定一个三行三列的网格，行宽和行高都是<code>100px</code>.<br><img src="https://greenhaha.oss-cn-beijing.aliyuncs.com/frontend/assets/img/gridtemplaterow.png" alt="gridtemplaterows"><br>对于单位的使用没有特殊限制 <code>%</code> 或者绝对单位 <a href="https://jsbin.com/povapisuma/edit?html,css,output">效果</a></p><ol><li>repeat()</li></ol><p><code>repeat()</code>函数可以简化重复的值</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span>&#123;</span><br><span class="line">    <span class="attribute">display</span>: grid;</span><br><span class="line">    grid-template-<span class="attribute">columns</span>: <span class="built_in">repeat</span>(<span class="number">3</span>, <span class="number">90px</span>);</span><br><span class="line">    grid-template-rows: <span class="built_in">repeat</span>(<span class="number">3</span>, <span class="number">80px</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>repeate(x, y)</code> 接受2个参数<br>x：表示重复的次数<br>y：表示参数重复的值</p><p><code>repeat()</code>重复某种模式也是可以的</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grid-template-<span class="attribute">columns</span>: <span class="built_in">repeat</span>(<span class="number">2</span>, <span class="number">100px</span> <span class="number">90px</span> <span class="number">120px</span>);</span><br></pre></td></tr></table></figure><p><a href="https://jsbin.com/hovemudute/edit?html,css,output">上方代码效果</a><br><img src="https://greenhaha.oss-cn-beijing.aliyuncs.com/frontend/assets/img/repeat.png" alt="repeat1"></p><ol start="2"><li>auto-file 关键字</li></ol><p>单元格大小是固定的，但是容器的大小不确定。如果想要每一行（或每一列）容纳尽可能多的单元格，这时可以使用<code>auto-fill</code> 关键字表示自动填充。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span>&#123;</span><br><span class="line">    <span class="attribute">display</span>: grid;</span><br><span class="line">    grid-template-<span class="attribute">columns</span>: <span class="built_in">repeat</span>(auto-fill, <span class="number">110px</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://jsbin.com/vegevemuhe/edit?html,css,output">代码</a>表示每列宽度<code>100px</code>,  然后自动填充，知道容器不能放置更多的列<br><img src="https://greenhaha.oss-cn-beijing.aliyuncs.com/frontend/assets/img/autofill.png" alt="auto-fill"></p><ol start="3"><li>fr关键字</li></ol><p>为方便表示比例关系，网格布局提供了<code>fr</code>关键字（fraction的缩写，译为 “片段”）。如果两列宽度分别为<code>1fr</code>和<code>2fr</code>,就表示后者是前者的2倍。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span>&#123;</span><br><span class="line">    <span class="attribute">display</span>: grid;</span><br><span class="line">    grid-template-<span class="attribute">columns</span>: <span class="number">1</span>fr <span class="number">1</span>fr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://jsbin.com/hadexek/edit?html,css,output">上面代码</a>表示2个相同的宽度<br><img src="https://greenhaha.oss-cn-beijing.aliyuncs.com/frontend/assets/img/fr.png" alt="fr"></p><p>fr可以与绝对长度的单位结合使用，很方便</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span>&#123;</span><br><span class="line">    <span class="attribute">display</span>: grid;</span><br><span class="line">    grid-template-<span class="attribute">columns</span>: <span class="number">150px</span> <span class="number">1</span>fr <span class="number">2</span>fr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://jsbin.com/remowec/edit?html,css,output">上面代码</a>表示，第一列的宽度为150像素，第二列的宽度是第三列的一半。<br><img src="https://greenhaha.oss-cn-beijing.aliyuncs.com/frontend/assets/img/frpx.png" alt="frpx"></p><ol start="4"><li>minmax()</li></ol><p><code>minmax()</code>函数产生一个长度范围，表示长度就在这个范围之中，他接受2个参数，minmax(x, y)</p><p>x: 最小值<br>y: 最大值</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grid--template-<span class="attribute">columns</span>: <span class="number">1</span>fr <span class="number">1</span>fr <span class="built_in">minmax</span>(<span class="number">100px</span>, <span class="number">1</span>fr);</span><br></pre></td></tr></table></figure><p>上面代码中，minmax(100px, 1fr)表示列宽不小于100px，不大于1fr</p><ol start="5"><li>auto 关键字<br><code>auto</code>关键字表示由路由器自己决定长度<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grid-template-columns: 100px auto 100px</span><br></pre></td></tr></table></figure></li></ol><p>上面的代码中第二列的宽度，基本上等于改列单元格的最大宽度，除非单元格内容设置了<code>min-width</code>, 且这个值大于最大宽度。</p><ol start="6"><li>网格线的名称<br><code>grid-template-columns</code>属性和<code>grid-template-rows</code>属性里面，还可以使用方括号，指定每一根网格线的名称，方便使用</li></ol><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span>&#123;</span><br><span class="line">    <span class="attribute">display</span>: grid;</span><br><span class="line">    grid-template-<span class="attribute">columns</span>:  [c1] <span class="number">100px</span> [c2] <span class="number">100px</span> [c3] auto [c4];</span><br><span class="line">    grid-template-rows: [r1] <span class="number">100px</span> [r2] <span class="number">100px</span> [r3] auto [r4];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码指定网格布局为3行x3列，因此有4根垂直网格线和4根水平网格线。方括号里面依次是这八根线的名称。<br>网格布局允许同一根线有多个名称。比如<code>[fifth-line row-5]</code></p><ol start="7"><li>布局实例</li></ol><p><code>grid-template-columns</code> 属性对于网页布局非常好用。两栏式布局只需要一行代码</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.wrapper</span>&#123;</span><br><span class="line">    <span class="attribute">display</span>: grid;</span><br><span class="line">    grid-template-<span class="attribute">columns</span>: <span class="number">70%</span> <span class="number">30%</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>传统的十二网格布局也很容易</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grid-template-<span class="attribute">columns</span>: <span class="built_in">repeat</span>(<span class="number">12</span>, <span class="number">1</span>fr)</span><br></pre></td></tr></table></figure><ul><li>grid-row-gap 属性 &amp; grid-column-gap 属性 &amp; grid-gap 属性</li></ul><p><code>grid-row-gap</code> 属性设置行与行的间隔（行间距）， <code>grid-columns-gap</code>属性设置列与列的间隔（列间距）</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span>&#123;</span><br><span class="line">    grid-row-gap: <span class="number">20px</span>;</span><br><span class="line">    grid-<span class="attribute">column-gap</span>: <span class="number">20px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://jsbin.com/mezufab/edit?html,css,output">上面代码中</a>,<code>grid-row-gap</code>用于设置行间距，<code>grid-column-gap</code> 用于设置列间距。<br><img src="https://greenhaha.oss-cn-beijing.aliyuncs.com/frontend/assets/img/gridrowcolumngap.png" alt="grid-row-gap&amp;grid-column-gap"></p><p><code>grid-gap</code>属性是<code>grid-column-gap</code>和<code>grid-row-gap</code>合并简写形式</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grid-gap: &lt;grid-row-gap&gt; &lt;grid-column-gap&gt;</span><br></pre></td></tr></table></figure><p>上面的一段CSS代码等同于下面的代码</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span>&#123;</span><br><span class="line">    grid-gap: <span class="number">20px</span> <span class="number">20px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果<code>grid-gap</code>省略了第二个值，浏览器认为第二个值等于第一个值</p><blockquote><p>更具最新标准，上面三个属性名称<code>grid-</code>前缀已经删除，<code>grid-column-gap</code>和<code>grid-row-gap</code>写成<code>column-gap</code>和<code>row-gap</code>， <code>grid-gap</code>写成<code>gap</code> </p></blockquote><ul><li>grid-template-areas 属性</li></ul><p>网格布局允许指定“区域”（area）， 一个区域由单个或多个单元格组成。<code>grid-template-areas</code> 属性用于定义区域。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: grid;</span><br><span class="line">  grid-template-<span class="attribute">columns</span>: <span class="number">100px</span> <span class="number">100px</span> <span class="number">100px</span>;</span><br><span class="line">  grid-template-rows: <span class="number">100px</span> <span class="number">100px</span> <span class="number">100px</span>;</span><br><span class="line">  grid-template-areas: <span class="string">&#x27;a b c&#x27;</span></span><br><span class="line">                       <span class="string">&#x27;d e f&#x27;</span></span><br><span class="line">                       <span class="string">&#x27;g h i&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码先划出9个单元格，然后将其定名为<code>a</code>到<code>i</code>的九个区域，分别对应这九个单元格。</p><h2 id="定位"><a href="#定位" class="headerlink" title="定位"></a>定位</h2>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;</summary>
        
      
    
    
    
    <category term="知识剖析" scheme="http://example.com/categories/%E7%9F%A5%E8%AF%86%E5%89%96%E6%9E%90/"/>
    
    
    <category term="浏览器" scheme="http://example.com/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
    <category term="CSS" scheme="http://example.com/tags/CSS/"/>
    
    <category term="布局" scheme="http://example.com/tags/%E5%B8%83%E5%B1%80/"/>
    
  </entry>
  
  <entry>
    <title>快速搭建一个MOCKSERVE服务器</title>
    <link href="http://example.com/2021/07/05/%E6%90%AD%E5%BB%BAmockserve/"/>
    <id>http://example.com/2021/07/05/%E6%90%AD%E5%BB%BAmockserve/</id>
    <published>2021-07-05T12:30:22.000Z</published>
    <updated>2024-01-02T01:12:08.529Z</updated>
    
    <content type="html"><![CDATA[<h1 id="如何快速搭建一个mockserve服务器"><a href="#如何快速搭建一个mockserve服务器" class="headerlink" title="如何快速搭建一个mockserve服务器"></a>如何快速搭建一个mockserve服务器</h1><h2 id="什么是mock"><a href="#什么是mock" class="headerlink" title="什么是mock"></a>什么是mock</h2><p>如果将mock单独翻译过来，其意义为 “虚假、虚设”，因此在软件开发领域，我们也可以将其理解成 “虚假数据”，或者 “真实数据的替身”。</p><h2 id="mock的好处"><a href="#mock的好处" class="headerlink" title="mock的好处"></a>mock的好处</h2><ul><li>团队可以更好地并行工作</li></ul><p>当使用mock之后，各团队之间可以不需要再互相等待对方的进度，只需要约定好相互之间的数据规范（文档），即可使用mock构建一个可用的接口，然后尽快的进行开发和调试以及自测，提升开发进度的的同时，也将发现缺陷的时间点大大提前。</p><ul><li>开启TDD（Test-Driven Development）模式，即测试驱动开发</li></ul><p>单元测试是TDD实现的基石，而TDD经常会碰到协同模块尚未开发完成的情况，但是有了mock，这些一切都不是问题。当接口定义好后，测试人员就可以创建一个Mock，把接口添加到自动化测试环境，提前创建测试。</p><ul><li>测试覆盖率</li></ul><p>比如一个接口在各种不同的状态下要返回不同的值，之前我们的做法是复现这种状态然后再去请求接口，这是非常不科学的做法，而且这种复现方法很大可能性因为操作的时机或者操作方式不当导致失败，甚至污染之前数据库中的数据。如果我们使用mock，就完全不用担心这些问题。</p><ul><li>方便演示</li></ul><p>通过使用Mock模拟数据接口，我们即可在只开发了UI的情况下，无须服务端的开发就可以进行产品的演示。</p><ul><li>隔离系统</li></ul><p>在使用某些接口的时候，为了避免系统中数据库被污染，我们可以将这些接口调整为Mock的模式，以此保证数据库的干净。</p><h2 id="如何快速实现一个mockserve"><a href="#如何快速实现一个mockserve" class="headerlink" title="如何快速实现一个mockserve"></a>如何快速实现一个mockserve</h2><h3 id="什么是mockserve"><a href="#什么是mockserve" class="headerlink" title="什么是mockserve"></a>什么是mockserve</h3><p>专门实现 mock 功能的一个服务。</p><h3 id="mockserve-的作用"><a href="#mockserve-的作用" class="headerlink" title="mockserve 的作用"></a>mockserve 的作用</h3><p>的业务系统很少有孤立存在的，它们或多或少需要使用兄弟团队或是其他公司提供的服务，这给我们的联调和测试造成了麻烦。对于这种情况，我们常见的解决方案是搭建一个临时的server，模拟那些服务，提供数据进行联调和测试。这就是 mock server 出现原因。</p><p><img src="https://greenhaha.oss-cn-beijing.aliyuncs.com/frontend/assets/img/mockserve.png" alt="mockserve"></p><h3 id="mock数据的几种方式"><a href="#mock数据的几种方式" class="headerlink" title="mock数据的几种方式"></a>mock数据的几种方式</h3><ol><li><p>直接在页面写死数据，后期等接口来了，再改成动态的; </p></li><li><p>在js里直接声明变量，并给变量赋值，在逻辑脚本中使用，并渲染到dom;</p></li><li><p>将模拟数据编辑成json数据或者是零碎的js脚本中，通过请求，取回数据，并进行业务逻辑处理，渲染到dom</p></li><li><p>最理想化的</p></li></ol><ul><li><p>前后台在需求分解之后，一起定义好接口api，包含：请求url（项目前缀+具体的接口名称）、请求方式、请求参数、数据响应；</p></li><li><p>前端研发人员根据接口约定，模拟请求返回对应的数据，完成对应的交互；</p></li><li><p>后台人员根据接口约定，完成对应的api，并完成对应的自测；</p></li><li><p>待后台人员交付接口api后，前端人员直接修改接口项目前缀，切换到对应的环境，即可进入项目提测。</p></li></ul><h3 id="如何使用web框架快速搭建mockserve"><a href="#如何使用web框架快速搭建mockserve" class="headerlink" title="如何使用web框架快速搭建mockserve"></a>如何使用web框架快速搭建mockserve</h3><p>这个mockserve是基于 express+mock.js+nodemon 来构建的</p><p>Express 是一个基于 Node 平台的 Web 开发框架，使用它可以很方便的搭建本地Web 服务。用来部署我们的 Mock 数据，Express 可以通过 npm 来安装，其官网地址如下：<a href="http://www.expressjs.com.cn/">http://www.expressjs.com.cn/</a> 其中有详细安装方法</p><p>Mock.js 是一个模拟数据结构、生成随机数据的 JavaScript 库，有一套语法规则用来模拟结构和生成数据。其安装过程也很简单，官网地址：<a href="http://mockjs.com/">http://mockjs.com/</a></p><p>nodemon node进程自动重启，监听文件</p><h3 id="搭建步骤："><a href="#搭建步骤：" class="headerlink" title="搭建步骤："></a>搭建步骤：</h3><p>首先本地创建项目工程文件夹，名字随意 然后进入到创建的文件夹中</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> express_mockserve</span><br></pre></td></tr></table></figure><p>利用npm或者yarn 本地初始化工程</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn init</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm init</span><br></pre></td></tr></table></figure><p>安装相关依赖包依赖包</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install express mockjs nodemon</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn add express mockjs nodemon</span><br></pre></td></tr></table></figure><p>安装完成后，打开package.json文件，在script对象中加入下列代码</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;mock:serve&quot;</span>: <span class="string">&quot;nodemon express_mockserve/index.js --watch express_mockserve/*&quot;</span></span><br></pre></td></tr></table></figure><blockquote><p>作用：利用nodemon 自动启动node并监听目标文件更改，如果更改自动热更新</p></blockquote><p>然后创建<code>index.js</code> 工程启动文件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> app = express();</span><br><span class="line"><span class="keyword">var</span> data = &#123;</span><br><span class="line">    <span class="attr">name</span> : <span class="string">&quot;jack&quot;</span>,</span><br><span class="line">    <span class="attr">age</span> : <span class="number">25</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">&#x27;/mock&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req,res</span>) </span>&#123;</span><br><span class="line">    res.send(<span class="built_in">JSON</span>.stringify(data));</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">var</span> server = app.listen(<span class="number">8001</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上面的代码使用 Express 搭建了一个简单的本地服务器，在终端使用 Node 执行此 JavaScript 程序，在浏览器中输入如下地址，进行 GET 请求，就可以看到已经获取到本地服务器返回的数据。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://localhost:8001/mock</span><br></pre></td></tr></table></figure><p>下面借助 Mock.js 来随机生成模拟数据，修改上面代码如下</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> Mock = <span class="built_in">require</span>(<span class="string">&#x27;mockjs&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> app = express();</span><br><span class="line"><span class="keyword">var</span> data = Mock.mock(&#123;</span><br><span class="line"></span><br><span class="line">    <span class="string">&#x27;people|1-10&#x27;</span> : [&#123;</span><br><span class="line">        <span class="attr">name</span> : <span class="string">&quot;@cname&quot;</span>,</span><br><span class="line">        <span class="string">&#x27;age|10-40&#x27;</span> : <span class="number">0</span>,</span><br><span class="line">        <span class="comment">// 属性 id 是一个自增数，起始值为 1，每次增 1</span></span><br><span class="line">        <span class="string">&#x27;id|+1&#x27;</span>: <span class="number">1</span></span><br><span class="line">    &#125;]</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">&#x27;/people&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req,res</span>) </span>&#123;</span><br><span class="line">    res.send(<span class="built_in">JSON</span>.stringify(data));</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">var</span> server = app.listen(<span class="number">8001</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上面代码使用了 Mock.js 中生成随机数据的一些语法，重启Node服务，再次刷新浏览器，就会看到效果。。<br>具体的 Mock.js 模拟数据的语法和规则可以在 <a href="https://github.com/nuysoft/Mock/wiki/Getting-Started">https://github.com/nuysoft/Mock/wiki/Getting-Started</a> 查看</p><p>项目demo：<a href="https://github.com/greenhaha/exprssmockserve">地址</a></p><h3 id="关于express搭建mockserve跨域问题"><a href="#关于express搭建mockserve跨域问题" class="headerlink" title="关于express搭建mockserve跨域问题"></a>关于express搭建mockserve跨域问题</h3><p>如果express搭建mockserve产生跨域问题 通常有2中解决方案：</p><ol><li><p>安装解决跨域中间件 <code>cors</code><br>使用发放</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install cors --save-dev</span><br></pre></td></tr></table></figure><p>然后再工程的入口文件里 加入下列代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const cors = require(&#x27;cors&#x27;);</span><br><span class="line">app.use(cors());</span><br></pre></td></tr></table></figure></li><li><p>手动实现解决方案</p></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">app.use(<span class="function">(<span class="params">req, res, next</span>) =&gt;</span> &#123;</span><br><span class="line">res.header(<span class="string">&#x27;Access-Control-Allow-Origin&#x27;</span>, <span class="string">&#x27;*&#x27;</span>)</span><br><span class="line">res.header(<span class="string">&#x27;Access-Control-Allow-Headers&#x27;</span>, <span class="string">&#x27;Authorization,X-API-KEY, Origin, X-Requested-With, Content-Type, Accept, Access-Control-Request-Method&#x27;</span> )</span><br><span class="line">res.header(<span class="string">&#x27;Access-Control-Allow-Methods&#x27;</span>, <span class="string">&#x27;GET, POST, OPTIONS, PATCH, PUT, DELETE&#x27;</span>)</span><br><span class="line">res.header(<span class="string">&#x27;Allow&#x27;</span>, <span class="string">&#x27;GET, POST, PATCH, OPTIONS, PUT, DELETE&#x27;</span>)</span><br><span class="line">next();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>注：方案2中不同的值在解决跨域中起到不同的作用</p><ul><li>Access-Control-Allow-Origin<br><code>Access-Control-Allow-Origin</code> 是一个html5中添加的CORS(Cross-Origin Resource Sharing)头<br>跨域访问时，B站点 通过在响应头中添加 Access-Control-Allow-Origin:<a href="http://sitea/">http://siteA</a> 向浏览器表示该资源可被A站点正常访问使用。除非添加了Access-Control-Allow-Origin响应头，否则默认情况下一个站点的资源不允许来自于其他域的任何XMLHttpRequest请求。</li></ul><p>对于B站点任意页面或者资源，如果想要允许被A站点访问，则应在页面或者资源请求的响应中添加相应头： Access-Control-Allow-Origin: <a href="http://sitea.com/">http://siteA.com</a></p><ul><li><p>Simple请求<br>现代浏览器不会完全阻止跨域请求。如果A站点请求B站点的一个页面P，浏览器实际上会在网络级拉取页面P，然后检查页面P响应头中A站点是否在允许列表中。如果响应中没有声明A站点具有访问权限，则浏览器会触发XMLHttpRequest’s error事件，并且阻止响应数据的执行。</p></li><li><p>Non-Simple 请求<br>真实发生的网络级请求实际上会稍微复杂一点。如果一个请求是Non-Simple的，浏览器首先会发送一个不包含数据的OPTIONS http请求，以此来验证服务器是否接受该站点的相应请求（GET,POST,PUT..etg.），一个Simple的请求需要同时满足以下两点：</p><ul><li>只能使用HTTP的GET,POST或者HEAD方法</li><li>只能使用Simple的请求头：<ul><li>Accept</li><li>Accept-Language</li><li>Content-Language</li><li>Last-Event-ID</li><li>Content-Type (Simple的请求定义中，content-type只能是application/x-www-form-urlencoded, multipart/form-data,或者 text/plain)<br>不符合这种情况的请求则是一个Non-Simple的请求，除此之外的http方法和http头叫做Non-Simple方法和头</li></ul></li></ul></li></ul><p>如果服务端对OPTIONS预请求的响应中包含了恰当的Non-Simple响应头(Access-Control-Allow-Headers,Access-Control-Allow-Methods),并且响应头的值中包含了真实要发生的请求的Non-Simple请求头和方法，浏览器才会继续发送真正的Non-Simple请求。</p><ul><li>Access-Control-Allow-Headers<br>响应首部 <code>Access-Control-Allow-Headers</code> 用于 preflight request （预检请求）中，列出了将会在正式请求的 Access-Control-Request-Headers 字段中出现的首部信息。</li></ul><p>简单首部，如 simple headers、Accept、Accept-Language、Content-Language、Content-Type （只限于解析后的值为 application/x-www-form-urlencoded、multipart/form-data 或 text/plain 三种MIME类型（不包括参数）），它们始终是被支持的，不需要在这个首部特意列出。</p><ul><li><p>Access-Control-Allow-Methods<br>响应首部 <code>Access-Control-Allow-Methods</code> 在对 preflight request.（预检请求）的应答中明确了客户端所要访问的资源允许使用的方法或方法列表。</p></li><li><p>Allow<br>Allow 首部字段用于枚举资源所支持的 HTTP 方法的集合。</p></li></ul><p>若服务器返回状态码 405 Method Not Allowed，则该首部字段亦需要同时返回给客户端。如果 Allow  首部字段的值为空，说明资源不接受使用任何 HTTP 方法的请求。这是可能的，比如服务器需要临时禁止对资源的任何访问。</p><blockquote><p>为什么访问url 没有端口号也可以访问对应页面工程<br>只有IP地址只可以发链路层的PING包侦测地址是否可达，页面传输是应用层的HTTP协议，从TCP/IP网络层开始，高层次的协议通信是要有ip加端口号的。浏览器默认80端口，一般而言tomcat也不会直接面对用户，前面会加一层代理层（Apache nginx），代理层的默认端口就是80。</p></blockquote>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;</summary>
        
      
    
    
    
    <category term="文档教程" scheme="http://example.com/categories/%E6%96%87%E6%A1%A3%E6%95%99%E7%A8%8B/"/>
    
    
    <category term="Node" scheme="http://example.com/tags/Node/"/>
    
    <category term="JavaScript" scheme="http://example.com/tags/JavaScript/"/>
    
    <category term="mockserve" scheme="http://example.com/tags/mockserve/"/>
    
    <category term="API" scheme="http://example.com/tags/API/"/>
    
  </entry>
  
  <entry>
    <title>NPM与YARN</title>
    <link href="http://example.com/2021/07/04/yarn%E4%B8%8Enpm/"/>
    <id>http://example.com/2021/07/04/yarn%E4%B8%8Enpm/</id>
    <published>2021-07-04T14:12:22.000Z</published>
    <updated>2024-01-02T01:12:08.521Z</updated>
    
    <content type="html"><![CDATA[<h2 id="NPM"><a href="#NPM" class="headerlink" title="NPM"></a>NPM</h2><h3 id="什么是npm？"><a href="#什么是npm？" class="headerlink" title="什么是npm？"></a>什么是npm？</h3><p>npm（全称 Node Package Manager，即“node包管理器”）是Node.js默认的、用JavaScript编写的软件包管理系统</p><blockquote><p>相关历史<br>npm完全有JavaScript编写，最初由艾萨克·施吕特（Isaac Z. Schlueter）开发。艾萨克表示自己意识到“模块管理很糟糕”的问题，并看到了PHP的PEAR与Perl的CPAN等软件的缺点，于是编写了npm。（<a href="https://github.com/nodejs/node-v0.x-archive/issues/5132#issuecomment-15432598">参考内容</a>）<br><br>2020年3月16 日，GitHub CEO Nat Friedman 宣布 GitHub 已签署收购 NPM（npm 背后的公司）的协议，并表示 npm 加入 GitHub 后会继续免费提供公共软件注册中心服务。</p></blockquote><h3 id="相关运行机制"><a href="#相关运行机制" class="headerlink" title="相关运行机制"></a>相关运行机制</h3><p>npm会随着Node.js自动安装。npm模块仓库提供了一个名为“registry”的查询服务，用户可通过本地的npm命令下载并安装指定模块。此外用户也可以通过npm把自己设计的模块分发到registry上面。</p><p>registry上面的模块通常采用CommonJS格式，而且都包含一个JSON格式的元文件。</p><p>npm的模块以“先到先得”的原则注册，各模块作者不会发生混乱。然而一旦有人撤回自己发布的模块，那么不仅会使依赖那个模块的项目出现问题，还会带来安全风险。例如有一个模块叫做“left-pad”，其中只有一个字符串对齐的功能。但是，当作者把它从registry里面移除之后，许多模块便无法正确构建。</p><p>npm的registry没有审核机制，因此会存在一些低质量、不安全甚至有害的模块，不过npm服务器的管理员也可以删除有害模块并阻止不怀好意的用户。</p><p>另外也有人为npm制作了统计功能，这样可以让开发者了解各模块的使用情况，帮助他们选择合适的模块。</p><h3 id="依赖安装过程"><a href="#依赖安装过程" class="headerlink" title="依赖安装过程"></a>依赖安装过程</h3><p>① 发出 npm install 命令<br>② 查询node_modules目录之中是否已经存在指定模块，若存在，不再重新安装<br>③ 若不存在，npm 向 registry 查询模块压缩包的网址④ 下载压缩包，存放在根目录下的.npm目录里⑤ 解压压缩包到当前项目的node_modules目录注意： 一个模块安装以后，本地其实保存了两份。一份是.npm目录下的压缩包，另一份是node_modules目录下解压后的代码。但是，运行npm install 的时候，只会检查node_modules目录，而不会检查.npm目录。也就是说，如果一个模块在.npm下有压缩包，但是没有安装在node_modules目录中，npm 依然会从远程仓库下载一次新的压缩包。</p><h3 id="package-和-package-json文件"><a href="#package-和-package-json文件" class="headerlink" title="package 和 package.json文件"></a>package 和 package.json文件</h3><p>package（包）是用javascript代码编写的功能包 package.json文件是包的描述文件，在每个项目的根目录下面。</p><ul><li>描述包的信息(比如名称、版本、入口文件等)，以便发布到npm registry</li><li>描述项目所需的依赖包，方便通过npm install下载安装 package.json文件的字段详情介绍参考：<br><a href="https://javascript.ruanyifeng.com/nodejs/packagejson.html">https://javascript.ruanyifeng.com/nodejs/packagejson.html</a></li></ul><p>npm 共享 JS 代码的过程就是：<br><img src="https://greenhaha.oss-cn-beijing.aliyuncs.com/frontend/assets/img/package.jpg" alt="npm"></p><ol><li>一个统一的package代码仓库 (npm官网)</li><li>编写自己的package和package.json文件(参考npm官方文档介绍)</li><li>通过 npm publish 把package放到这个仓库里</li><li>其他人的项目里想要使用某些package就写到package.json文件中，然后运行npm install，就会自动将这些代码下载下来，统一放到node_modules目录中。</li></ol><h3 id="npm-常用命令"><a href="#npm-常用命令" class="headerlink" title="npm 常用命令"></a>npm 常用命令</h3><ul><li><p>查看当前npm版本： npm -v</p></li><li><p>安装包 </p></li><li><ul><li>npm install 包名 </li></ul></li><li><ul><li>npm install 包名 -g : 全局安装，安装后在命令行任意目录下可直接使用包命令</li></ul></li><li><p>更新包： npm install 包名@latest</p></li><li><p>卸载包： npm uninstall 包名</p></li><li><p>根据guide创建一个package.json文件： npm init</p></li><li><p>换源：npm –registry 源地址</p></li></ul><h2 id="YARN"><a href="#YARN" class="headerlink" title="YARN"></a>YARN</h2><h3 id="什么是yarn"><a href="#什么是yarn" class="headerlink" title="什么是yarn"></a>什么是yarn</h3><p>正如官网主页写的yarn是快速、可靠、安全的依赖管理工具</p><ul><li>快速： Yarn 缓存了每个下载过的包，所以再次使用时无需重复下载。 同时利用并行下载以最大化资源利用率，因此安装速度更快。</li><li>可靠：使用详细、简洁的锁文件格式和明确的安装算法，Yarn 能够保证在不同系统上无差异的工作。</li><li>安全： 在执行代码之前，Yarn 会通过算法校验每个安装包的完整性。</li></ul><p>而对于<a href="https://engineering.fb.com/2016/10/11/web/yarn-a-new-package-manager-for-javascript/">官方文档</a>中所说：<br>Yarn 是为了弥补 npm 的一些缺陷而出现的。</p><blockquote><p>Yarn is a new package manager that replaces the existing workflow for the npm client or other package managers while remaining compatible with the npm registry. It has the same feature set as existing workflows while operating faster, more securely, and more reliably. — (engineering.fb)[<a href="https://engineering.fb.com/2016/10/11/web/yarn-a-new-package-manager-for-javascript/]">https://engineering.fb.com/2016/10/11/web/yarn-a-new-package-manager-for-javascript/]</a><br>中文大意就是：yarn是一个新的包管理工具并取代现有npm端以及其他包管理器的现有工作流，并同时保持与 npm 注册表兼容。它具有与现有工作流程相同的功能等。</p></blockquote><h3 id="yarn-优点"><a href="#yarn-优点" class="headerlink" title="yarn 优点"></a>yarn 优点</h3><ul><li>速度快。速度快的主要原因：</li></ul><ol><li>并行安装：无论 npm 还是 Yarn 在执行包的安装时，都会执行下载任务。npm 是按照队列执行每个 package，也就是说必须要等到当前 package 安装完成之后，才能继续后面的安装。而 Yarn 是同步执行所有任务，提高了性能。</li><li>离线模式：如果之前已经安装过一个软件包，用Yarn再次安装时之间从缓存中获取，就不用像npm那样再从网络下载了。减少对网络的依赖防止了在网速不好的情况下下载出现问题或者缓慢等情况</li></ol><ul><li>安装版本统一：为了防止拉取到不同的版本，Yarn 有一个锁定文件 (lock file) 记录了被确切安装上的模块的版本号。每次只要新增了一个模块，Yarn 就会创建（或更新）yarn.lock 这个文件。这么做就保证了，每一次拉取同一个项目依赖时，使用的都是一样的模块版本。npm 其实也有办法实现处处使用相同版本的 packages，但需要开发者执行 npm shrinkwrap 命令。这个命令将会生成一个锁定文件，在执行 npm install 的时候，该锁定文件会先被读取，和 Yarn 读取 yarn.lock 文件一个道理。npm 和 Yarn 两者的不同之处在于，Yarn 默认会生成这样的锁定文件，而 npm 要通过 shrinkwrap 命令生成 npm-shrinkwrap.json 文件，只有当这个文件存在的时候，packages 版本信息才会被记录和更新。</li><li>更简洁的输出：npm 的输出信息比较冗长。在执行 npm install 的时候，命令行里会不断地打印出所有被安装上的依赖。相比之下，Yarn 简洁太多：默认情况下，结合了 emoji直观且直接地打印出必要的信息，也提供了一些命令供开发者查询额外的安装信息。</li><li>多注册来源处理：所有的依赖包，不管他被不同的库间接关联引用多少次，安装这个包时，只会从一个注册来源去装，要么是 npm 要么是 bower, 防止出现混乱不一致。</li><li>更好的语义化： yarn改变了一些npm命令的名称，比如 yarn add/remove，感觉上比 npm 原本的 install/uninstall 要更清晰。</li></ul><h3 id="安装过程的步骤"><a href="#安装过程的步骤" class="headerlink" title="安装过程的步骤"></a>安装过程的步骤</h3><ol><li>分析: Yarn 通过向每个注册库（registry）发出请求并递归查找每个依赖项来开始解析依赖项。</li><li>获取: 接下来，Yarn 在全局缓存目录中查找所需的包是否已经下载。如果没有，Yarn 会获取压缩包 并将其放在全局缓存中，这样它就可以脱机工作并且不需要多次下载依赖项。依赖项也可以作为压缩包 放置在源代码管理中，用于完全离线安装。</li><li>链接: 最后，Yarn 通过将全局缓存中所需的所有文件复制到本地node_modules目录中来将所有内容链接在一起。</li></ol><h3 id="yarn-与-npm-命令对比"><a href="#yarn-与-npm-命令对比" class="headerlink" title="yarn 与 npm 命令对比"></a>yarn 与 npm 命令对比</h3><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">npm install === yarn </span><br><span class="line">npm install xxx --save === yarn add xxx</span><br><span class="line">npm uninstall xxx --save === yarn remove xxx</span><br><span class="line">npm install xxx --save-dev === yarn add xxx --dev</span><br><span class="line">npm update --save === yarn upgrade</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;</summary>
        
      
    
    
    
    <category term="知识剖析" scheme="http://example.com/categories/%E7%9F%A5%E8%AF%86%E5%89%96%E6%9E%90/"/>
    
    
    <category term="Node" scheme="http://example.com/tags/Node/"/>
    
    <category term="JavaScript" scheme="http://example.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>vue 高阶内容</title>
    <link href="http://example.com/2021/07/04/%E9%AB%98%E9%98%B6%E8%B5%84%E6%96%991/"/>
    <id>http://example.com/2021/07/04/%E9%AB%98%E9%98%B6%E8%B5%84%E6%96%991/</id>
    <published>2021-07-04T14:12:22.000Z</published>
    <updated>2024-01-02T01:12:08.529Z</updated>
    
    <content type="html"><![CDATA[<h1 id="vue-高阶内容"><a href="#vue-高阶内容" class="headerlink" title="vue 高阶内容"></a>vue 高阶内容</h1><h2 id="vuejs"><a href="#vuejs" class="headerlink" title="vuejs"></a>vuejs</h2><p>vue.js 有个几个核心思：</p><ul><li>虚拟dom </li><li>响应式数据</li><li>组件通信</li></ul><h3 id="虚拟DOM（Virtual-DOM）"><a href="#虚拟DOM（Virtual-DOM）" class="headerlink" title="虚拟DOM（Virtual-DOM）"></a>虚拟<code>DOM</code>（Virtual-DOM）</h3><h4 id="真实DOM与渲染流程"><a href="#真实DOM与渲染流程" class="headerlink" title="真实DOM与渲染流程"></a>真实<code>DOM</code>与渲染流程</h4><p>首先要想了解虚拟DOM，就需要了解什么是真实DOM；<br>如下图为<code>webkit</code>渲染引擎工作流程（概括）</p><p><img src="https://greenhaha.oss-cn-beijing.aliyuncs.com/frontend/assets/img/%E7%9C%9F%E5%AE%9Edom%E6%B8%B2%E6%9F%93%E6%B5%81%E7%A8%8B.jpg" alt="webkit渲染流程"></p><p>无论是什么浏览器的内核引擎，基本的渲染工作流程分为5个步骤：<br><br>创建DOM树 —&gt; 创建style rules（常见css 样式树） —&gt; 构建Render 树  —&gt; 布局Layout  —&gt; Painting</p><ul><li>第一步，构建DOM树：用HTML解析器解析HTML 标签等相关元素，构建出一颗DOM树</li><li>第二步，生成样式表：用css解析器，分析css文件和元素上inline样式（行内样式），生成页面的样式表；</li><li>第三部，构建Render树：将DOM树和样式树关联以来，构建出一颗render树（Attachment）。每个DOM节点都有一个attach方法，接受样式信息，返回一个render对象，这些render对象最终会被构建成一颗render树</li><li>第四步，确定节点坐标：根绝render树结构，为每个render树上的节点确定一个在显示器上的精确坐标</li><li>第五步，绘制页面：根据render树与节点坐标，然后调用每个节点的paint方法，将他们绘制出来</li></ul><blockquote><ul><li><code>DOM</code>树的构建是文档加载完成开始吗？<br><br>  构建<code>DOM</code>树是一个渐进式的构成，为了给用户一个更好的体验，渲染引擎会将内容尽快的显示出来而不是等待所有HTML文档解析完成后才开始构建<code>render</code>树和布局</li><li><code>render</code>树是<code>DOM</code>树和<code>CSS</code>样式表构建完成后开始构建的吗？<br><br>  因为浏览器的解析是渐进式的过程，所有这3个过程在实际进行的时候并不是完全独立的，会有交叉的过程，会边加载，边解析，边渲染</li><li><code>CSS</code>的解析注意点？<br><br>  <code>CSS</code>的解析是从右往左解析嵌套的样式越多，解析的越慢</li><li><code>JS</code>操作真实<code>DOM</code>代价？<br><br>  原生<code>JS</code>操作<code>DOM</code>时，浏览器会按照上面的构建顺序进行构建，当操作了10个<code>DOM</code>节点的时候，浏览器在获取到第一个<code>DOM</code>节点时会直接进行上述的构建顺序构建，并不会获知后面的9个需要变更的<code>DOM</code>节点，当第一个执行完成后依次进行剩下的9个构建，造成了性能浪费，即使计算器硬件一直在迭代，操作的DOM的代价也是很昂贵的，频繁的操作会造成页面的卡顿，影响用的体验</li></ul></blockquote><h4 id="Virtual-DOM基础"><a href="#Virtual-DOM基础" class="headerlink" title="Virtual-DOM基础"></a><code>Virtual-DOM</code>基础</h4><h5 id="虚拟DOM的好处"><a href="#虚拟DOM的好处" class="headerlink" title="虚拟DOM的好处"></a>虚拟<code>DOM</code>的好处</h5><p>虚拟<code>DOM</code>是为了解决浏览器性能问题而设计出来的。如果一次操作更新10个<code>DOM</code>的动作，虚拟<code>DOM</code>不会立即操作<code>DOM</code>，而是将这10次更新的<code>diff</code>内容保存到本地一个<code>JS</code>对象中，最终将这个<code>JS</code>对象一次性<code>attach</code>到<code>DOM</code>树上，再进行后续操作，避免大量无所谓的计算量。所以用<code>JS</code>对象模拟<code>DOM</code>节点的好处就是页面的更新可以先全部反映在<code>JS</code>对象（虚拟<code>DOM</code>）上，操作内存中的<code>JS</code>对象的速度显然要更快，等更新完成后，再将最终<code>JS</code>对象映射到真实<code>DOM</code>，有浏览器去绘制</p><h4 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h4><blockquote><ul><li>如何用<code>JS</code>对象模拟<code>DOM</code>树<br>这是一个真实的<code>DOM</code>树</li></ul></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;virtual-dom&quot;&gt;</span><br><span class="line">&lt;ul id=&quot;list&quot;&gt;</span><br><span class="line">  &lt;li class=&quot;item&quot;&gt;Item 1&lt;/li&gt;</span><br><span class="line">  &lt;li class=&quot;item&quot;&gt;Item 2&lt;/li&gt;</span><br><span class="line">  &lt;li class=&quot;item&quot;&gt;Item 3&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line">&lt;div&gt;Hello World&lt;/div&gt;</span><br><span class="line">&lt;/div&gt; </span><br><span class="line"></span><br></pre></td></tr></table></figure><p>用<code>JavaScript</code>来表示一个DOM节点很容易，需要记住节点的类型、属性、还有子节点：<br><code>element.js</code> 表示节点对象的代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Element virdual-dom 对象定义</span><br><span class="line"> * @param &#123;String&#125; tagName - dom 元素名称</span><br><span class="line"> * @param &#123;Object&#125; props - dom 属性</span><br><span class="line"> * @param &#123;Array&lt;Element|String&gt;&#125; - 子节点</span><br><span class="line"> */</span><br><span class="line">function Element(tagName, props, children) &#123;</span><br><span class="line">    this.tagName = tagName</span><br><span class="line">    this.props = props</span><br><span class="line">    this.children = children</span><br><span class="line">    // dom 元素的 key 值，用作唯一标识符</span><br><span class="line">    if(props.key)&#123;</span><br><span class="line">       this.key = props.key</span><br><span class="line">    &#125;</span><br><span class="line">    var count = 0</span><br><span class="line">    children.forEach(function (child, i) &#123;</span><br><span class="line">        if (child instanceof Element) &#123;</span><br><span class="line">            count += child.count</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            children[i] = &#x27;&#x27; + child</span><br><span class="line">        &#125;</span><br><span class="line">        count++</span><br><span class="line">    &#125;)</span><br><span class="line">    // 子元素个数</span><br><span class="line">    this.count = count</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function createElement(tagName, props, children)&#123;</span><br><span class="line"> return new Element(tagName, props, children);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module.exports = createElement;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>更具<code>element</code>对象的设定，则上面的<code>DOM</code>结构就可以简单表示为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var el = require(&quot;./element.js&quot;)</span><br><span class="line">var ul = el(&#x27;div&#x27;, &#123;id:&#x27;virtual-dom&#x27;&#125;,[</span><br><span class="line">    el(&#x27;ul&#x27;, &#123;id:&#x27;list&#x27;&#125;, [</span><br><span class="line">        el(&#x27;li&#x27;, &#123;class:&#x27;item&#x27;&#125;, [&#x27;Item 1&#x27;]),</span><br><span class="line">        el(&#x27;li&#x27;, &#123;class:&#x27;item&#x27;&#125;, [&#x27;Item 2&#x27;]),</span><br><span class="line">        el(&#x27;li&#x27;, &#123;class:&#x27;item&#x27;&#125;, [&#x27;Item 3&#x27;])</span><br><span class="line">    ]),</span><br><span class="line">    el(&#x27;div&#x27;, &#123;&#125;, [&#x27;Hello World&#x27;])</span><br><span class="line">])</span><br></pre></td></tr></table></figure><p>现在<code>ul</code>就是我们用<code>JavaScript</code>对象表示的DOM结构，输出查看<code>ul</code>对应的数据结构：<br><img src="https://greenhaha.oss-cn-beijing.aliyuncs.com/frontend/assets/img/ul%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.jpg" alt="ul数据结构"></p><blockquote><ul><li>渲染用<code>JS</code>表示的<code>DOM</code>对象<br>由于这是<code>JS</code>表示的<code>DOM</code>对象,在浏览器中是无法表示的，因此需要将<code>ul</code>渲染成页面上真实的<code>DOM</code>结构需要进行渲染函数渲染：</li></ul></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * render 将virdual-dom 对象渲染为实际 DOM 元素</span><br><span class="line"> */</span><br><span class="line">Element.prototype.render = function () &#123;</span><br><span class="line">    var el = document.createElement(this.tagName)</span><br><span class="line">    var props = this.props</span><br><span class="line">    // 设置节点的DOM属性</span><br><span class="line">    for (var propName in props) &#123;</span><br><span class="line">        var propValue = props[propName]</span><br><span class="line">        el.setAttribute(propName, propValue)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    var children = this.children || []</span><br><span class="line">    children.forEach(function (child) &#123;</span><br><span class="line">        var childEl = (child instanceof Element)</span><br><span class="line">            ? child.render() // 如果子节点也是虚拟DOM，递归构建DOM节点</span><br><span class="line">            : document.createTextNode(child) // 如果字符串，只构建文本节点</span><br><span class="line">        el.appendChild(childEl)</span><br><span class="line">    &#125;)</span><br><span class="line">    return el</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>我们通过查看以上<code>render</code>方法,会根据<code>tagName</code>构建一个真正的<code>DOM</code>节点，然后设置这个节点的属性，最后递归的把自己的子节点也构建起来.<br>我们将构建好的<code>DOM</code>结构添加到页面<code>body</code>上面，如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ulRoot = ul.render();</span><br><span class="line">document.body.appendChild(ulRoot); </span><br><span class="line"></span><br></pre></td></tr></table></figure><p>真正渲染到<code>body</code>中真正的<code>DOM</code>结构<br><br><img src="https://greenhaha.oss-cn-beijing.aliyuncs.com/frontend/assets/img/body.jpg" alt="ul真实DOM结构"></p><blockquote><ul><li>比较两颗虚拟<code>DOM</code>树的差异-<code>diff</code> 算法</li></ul></blockquote><p>diff算法用来比较两颗V-dom树的差异。如果要对2颗树完全比较，那么diff算法的事件发展度为<code>O(n^3)</code>, 但是对于前端来说，很少会进行跨越层级的移动<code>DOM</code>元素，所以<code>V-dom</code>只会对同一个层级的元素进行对比。如图所示，<code>div</code>只会和同级的<code>div</code>对比，第二层级的只会跟第二层级的对比，因此复杂度就降为了<code>O(n)</code><br><img src="https://greenhaha.oss-cn-beijing.aliyuncs.com/frontend/assets/img/diff%E6%AF%94%E8%BE%83%E5%9B%BE.jpg" alt="diff算法"></p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;</summary>
        
      
    
    
    
    <category term="知识剖析" scheme="http://example.com/categories/%E7%9F%A5%E8%AF%86%E5%89%96%E6%9E%90/"/>
    
    
    <category term="Node" scheme="http://example.com/tags/Node/"/>
    
    <category term="JavaScript" scheme="http://example.com/tags/JavaScript/"/>
    
    <category term="vue" scheme="http://example.com/tags/vue/"/>
    
    <category term="vdom" scheme="http://example.com/tags/vdom/"/>
    
  </entry>
  
  <entry>
    <title>react-router基础知识</title>
    <link href="http://example.com/2021/06/30/react-router%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <id>http://example.com/2021/06/30/react-router%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</id>
    <published>2021-06-30T12:34:00.000Z</published>
    <updated>2024-01-02T01:12:08.509Z</updated>
    
    <content type="html"><![CDATA[<h1 id="react-router"><a href="#react-router" class="headerlink" title="react-router"></a>react-router</h1><p><img src="https://www.zoo.team/images/upload/upload_fc4d71102131b3c8094572ecd4641111.jpg" alt="router history 核心流程"></p><h2 id="router和route"><a href="#router和route" class="headerlink" title="router和route"></a>router和route</h2><p>react-router主要是用于Url跳转，其核心概念即为Router和Route。</p><p>Router相当于一个容器，用于包裹Route，一个Route即为一个Url。Route里面会包裹一个组件。当在浏览器里输入Url时，就会跳转到相应的Route并显示相关组件。<br><br>一个Router里面可以包含多个Route的伪代码为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;Router&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">      &lt;Route /&gt;</span><br><span class="line">      &lt;Route /&gt;</span><br><span class="line">      &lt;Route /&gt;</span><br><span class="line">  &lt;/div</span><br><span class="line">&lt;Router&gt;</span><br></pre></td></tr></table></figure><blockquote><p>Router要求子组件只能有一个。</p></blockquote><p>Router和History有三个种类型：</p><ul><li>HashHistory和HashRouter</li><li>BrowerHistory和BrowerRouter</li><li>createMemoryHistory和MemoryRouter</li></ul><p>BrowerHistory和HashHistory主要区别在于Url格式：</p><p>使用hashHistory,浏览器的url是这样的：/#/user/liuna?_k=adseis<br>使用browserHistory,浏览器的url是这样的：/user/liuna</p><p>这样看起来当然是browerHistory更好一些，但是它需要server端支持。</p><p>使用hashHistory时，因为有 # 的存在，浏览器不会发送request，react-router 自己根据 url 去 render 相应的模块。</p><ul><li>hashroter<br>一个<code>&lt;Router&gt;</code>使用该URL（即哈希部分window.location.hash），以确保URL与页面UI保持同步。<br>并且官网推荐使用<code>&lt;BrowserHistory&gt;</code></li></ul><blockquote><p>IMPORTANT NOTE: Hash history does not support location.key or location.state. In previous versions we attempted to shim the behavior but there were edge-cases we couldn’t solve. Any code or plugin that needs this behavior won’t work. As this technique is only intended to support legacy browsers, we encourage you to configure your server to work with <BrowserHistory> instead.</p></blockquote><p>eg:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;HashRouter</span><br><span class="line">  basename=&#123;optionalString&#125;</span><br><span class="line">  getUserConfirmation=&#123;optionalFunc&#125;</span><br><span class="line">  hashType=&#123;optionalString&#125;</span><br><span class="line">&gt;</span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">App</span> /&gt;</span></span></span><br><span class="line">&lt;/HashRouter&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="为什么react-router的官方文档推荐使用browserHistory？"><a href="#为什么react-router的官方文档推荐使用browserHistory？" class="headerlink" title="为什么react-router的官方文档推荐使用browserHistory？"></a>为什么react-router的官方文档推荐使用browserHistory？</h3><p>首先 browserHistory 其实使用的是 HTML5 的 History API，浏览器提供相应的接口来修改浏览器的历史记录；而 hashHistory 是通过改变地址后面的 hash 来改变浏览器的历史记录；</p><p>History API 提供了 pushState() 和 replaceState() 方法来增加或替换历史记录。而 hash 没有相应的方法，hash 仅仅是通过使用hashchange方法来监听hash的变化，所以并没有替换历史记录的功能。</p><p>另一个原因是 hash 部分并不会被浏览器发送到服务端，也就是说不管是请求 <a href="http://domain.com/index.html#foo">http://domain.com/index.html#foo</a> 还是 <a href="http://domain.com/index.html#bar">http://domain.com/index.html#bar</a> ，服务只知道请求了 index.html 并不知道 hash 部分的细节。而 History API 需要服务端支持，这样服务端能获取请求细节。</p><p>*BrowserRouter<br>基于H5 History接口的路由<br>eg</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;BrowserRouter</span><br><span class="line">  basename=&#123;optionalString&#125;    </span><br><span class="line">  forceRefresh=&#123;optionalBool&#125;   </span><br><span class="line">  getUserConfirmation=&#123;optionalFunc&#125;</span><br><span class="line">  keyLength=&#123;optionalNumber&#125;  </span><br><span class="line">&gt;</span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">App</span> /&gt;</span></span></span><br><span class="line">&lt;/BrowserRouter&gt;</span><br></pre></td></tr></table></figure><ul><li><p>Link<br>声明式路由组件</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Link to=<span class="string">&quot;/about&quot;</span>&gt;About&lt;/Link&gt;</span><br></pre></td></tr></table></figure></li><li><p>to 导向哪个路由，可以为字符串，也可以为一个对象或者函数</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;Link to=<span class="string">&quot;/courses?sort=name&quot;</span> /&gt;</span><br><span class="line"></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">Link</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">   <span class="attr">to</span>=<span class="string">&#123;&#123;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">     <span class="attr">pathname:</span> &quot;/<span class="attr">courses</span>&quot;,    // 路径</span></span></span><br><span class="line"><span class="tag"><span class="xml">     <span class="attr">search:</span> &quot;?<span class="attr">sort</span>=<span class="string">name</span>&quot;,  // 查询参数</span></span></span><br><span class="line"><span class="tag"><span class="xml">     <span class="attr">hash:</span> &quot;#<span class="attr">the-hash</span>&quot;,   // <span class="attr">hash</span>值</span></span></span><br><span class="line"><span class="tag"><span class="xml">     <span class="attr">state:</span> &#123; <span class="attr">fromDashboard:</span> <span class="attr">true</span> &#125;  // 持久化到<span class="attr">location</span>的状态数据</span></span></span><br><span class="line"><span class="tag"><span class="xml">   &#125;&#125;</span></span></span><br><span class="line"><span class="tag"><span class="xml"> /&gt;</span></span></span><br></pre></td></tr></table></figure><p>一个函数，当前位置作为参数传递给它，并且应该以字符串或对象的形式返回位置表示</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;Link to=&#123;<span class="function"><span class="params">location</span> =&gt;</span> (&#123; ...location, <span class="attr">pathname</span>: <span class="string">&quot;/courses&quot;</span> &#125;)&#125; /&gt;</span><br><span class="line"></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">Link</span> <span class="attr">to</span>=<span class="string">&#123;location</span> =&gt;</span> `$&#123;location.pathname&#125;?sort=name`&#125; /&gt;</span></span><br></pre></td></tr></table></figure><p>其他可用属性</p></li><li><p>replace: 当为true时，单击该链接将替换历史堆栈中的当前条目，而不是添加一个新条目。</p></li><li><p>innerRef 值为函数</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;Link</span><br><span class="line">  to=<span class="string">&quot;/&quot;</span></span><br><span class="line">  innerRef=&#123;<span class="function"><span class="params">node</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// node指向挂载的dom元素, 卸载时候为null</span></span><br><span class="line">  &#125;&#125;</span><br><span class="line">/&gt;</span><br></pre></td></tr></table></figure><p>值为Ref对象</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> anchorRef = React.createRef()</span><br><span class="line"></span><br><span class="line">&lt;Link to=<span class="string">&quot;/&quot;</span> innerRef=&#123;anchorRef&#125; /&gt;</span><br></pre></td></tr></table></figure></li><li><p>component 定制化自己的导航组件</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> FancyLink = React.forwardRef(<span class="function">(<span class="params">props, ref</span>) =&gt;</span> (</span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">a</span> <span class="attr">ref</span>=<span class="string">&#123;ref&#125;</span> &#123;<span class="attr">...props</span>&#125;&gt;</span>  &#123;props.children&#125;<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span></span><br><span class="line">))</span><br><span class="line"></span><br><span class="line">&lt;Link to=<span class="string">&quot;/&quot;</span> component=&#123;FancyLink&#125; /&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>NavLink<br>是 Link 的一个特殊版本，当呈现的元素与当前URL匹配时，它将向该元素添加样式属性。</p></li></ul><p>activeClassName 当元素处于active状态时，类将提供该class。默认的给定class是active。这将与className样式叠加</p><p>activeStyle 内嵌方式声明active状态样式</p><p>exact 布尔类型， 为true是路径完全匹配才会添加active class</p><p>strict 路径匹配是否严格， 为true的话结尾的斜杠会被考虑</p><p>isActive函数， 可以自定义active class添加逻辑</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;NavLink</span><br><span class="line">  to=<span class="string">&quot;/events/123&quot;</span></span><br><span class="line">  isActive=&#123;<span class="function">(<span class="params">match, location</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!match) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// only consider an event active if its event id is an odd number</span></span><br><span class="line">    <span class="keyword">const</span> eventID = <span class="built_in">parseInt</span>(match.params.eventID);</span><br><span class="line">    <span class="keyword">return</span> !<span class="built_in">isNaN</span>(eventID) &amp;&amp; eventID % <span class="number">2</span> === <span class="number">1</span>;</span><br><span class="line">  &#125;&#125;</span><br><span class="line">&gt;</span><br><span class="line">  Event <span class="number">123</span></span><br><span class="line">&lt;/NavLink&gt;</span><br></pre></td></tr></table></figure><ul><li><p>Redirect<br>重定向</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;Route exact path=<span class="string">&quot;/&quot;</span>&gt;</span><br><span class="line">  &#123;loggedIn ? <span class="xml"><span class="tag">&lt;<span class="name">Redirect</span> <span class="attr">to</span>=<span class="string">&quot;/dashboard&quot;</span> /&gt;</span></span> : <span class="xml"><span class="tag">&lt;<span class="name">PublicHomePage</span> /&gt;</span></span>&#125;</span><br><span class="line">&lt;/Route&gt;</span><br></pre></td></tr></table></figure><p>to也可以为对象</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;Redirect</span><br><span class="line">  to=&#123;&#123;</span><br><span class="line">    <span class="attr">pathname</span>: <span class="string">&quot;/login&quot;</span>,</span><br><span class="line">    <span class="attr">search</span>: <span class="string">&quot;?utm=your+face&quot;</span>,</span><br><span class="line">    <span class="attr">state</span>: &#123; <span class="attr">referrer</span>: currentLocation &#125;</span><br><span class="line">  &#125;&#125;</span><br><span class="line">/&gt;</span><br></pre></td></tr></table></figure><p>push属性: 当为真时，重定向将把一个新的条目推送到历史中，而不是取代当前的条目。 from属性: 要重定向的路径名。路径-regexp@^1.7.0能够理解的任何有效URL路径。在to中为模式提供了所有匹配的URL参数。必须包含to中使用的所有参数。不被to使用的其他参数将被忽略。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;Switch&gt;</span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">Redirect</span> <span class="attr">from</span>=<span class="string">&quot;/old-path&quot;</span> <span class="attr">to</span>=<span class="string">&quot;/new-path&quot;</span> /&gt;</span></span></span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;/new-path&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">Place</span> /&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">Route</span>&gt;</span></span></span><br><span class="line">&lt;/Switch&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Redirect with matched parameters</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">Switch</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">Redirect</span> <span class="attr">from</span>=<span class="string">&quot;/users/:id&quot;</span> <span class="attr">to</span>=<span class="string">&quot;/users/profile/:id&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;/users/profile/:id&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">Profile</span> /&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">Route</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">Switch</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>exact属性， 路径是否完全匹配<br>strict属性： 路径匹配是否严格，区分斜杠<br>sensitive属性: 路径匹配是否大小写敏感</p></li><li><p>route<br>path（string）: 路由匹配路径。（没有path属性的Route 总是会 匹配）；<br>exact（bool）：为true时，则要求路径与location.pathname必须完全匹配；<br>strict（bool）：true的时候，有结尾斜线的路径只能匹配有斜线的location.pathname；</p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;Router&gt;</span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">Route</span> <span class="attr">exact</span> <span class="attr">path</span>=<span class="string">&quot;/&quot;</span> <span class="attr">component</span>=<span class="string">&#123;Home&#125;/</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;/news&quot;</span> <span class="attr">component</span>=<span class="string">&#123;NewsFeed&#125;/</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/Router&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果应用的地址是/,那么相应的UI会类似这个样子：</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">Home</span>/&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果应用的地址是/news,那么相应的UI就会成为这个样子：</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">NewsFeed</span>/&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure><ul><li><p>Switch</p></li><li><p>使用场景: 只要有一个 <code>path</code>匹配上了对应的组件, 后续就不会再进行匹配了</p></li><li><p>我们来看下面的路由规则：</p><ul><li>当我们匹配到某一个路径时，我们会发现有一些问题</li><li>比如 /about 路径匹配到的同时，/:userid也被匹配到了，并且最后的一个NoMatch组件总是被匹配到<br><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/741d953942e14e3787c7353fbfa79f70~tplv-k3u1fbpfcp-zoom-1.image"></li></ul></li><li><p>原因是什么呢？默认情况下，react-router中只要是路径被匹配到的Route对应的组件「都会被渲染」</p><ul><li>但是实际开发中, 我们希望有一种排他的思想</li><li>只要匹配到了第一个, 后面就不应该继续匹配了</li><li>这个时候我们可以使用Switch来将所有Route组件进行包裹<br><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5ed2ff8df0a4438c9de616e3e34f1126~tplv-k3u1fbpfcp-zoom-1.image"></li></ul></li></ul>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;</summary>
        
      
    
    
    
    <category term="知识剖析" scheme="http://example.com/categories/%E7%9F%A5%E8%AF%86%E5%89%96%E6%9E%90/"/>
    
    
    <category term="JavaScript" scheme="http://example.com/tags/JavaScript/"/>
    
    <category term="浏览器" scheme="http://example.com/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
    <category term="react" scheme="http://example.com/tags/react/"/>
    
    <category term="react-router" scheme="http://example.com/tags/react-router/"/>
    
  </entry>
  
  <entry>
    <title>浏览器历史堆栈</title>
    <link href="http://example.com/2021/06/20/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8E%86%E5%8F%B2%E5%A0%86%E6%A0%88/"/>
    <id>http://example.com/2021/06/20/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8E%86%E5%8F%B2%E5%A0%86%E6%A0%88/</id>
    <published>2021-06-20T12:35:00.000Z</published>
    <updated>2024-01-02T01:12:08.529Z</updated>
    
    <content type="html"><![CDATA[<h1 id="浏览器历史记录"><a href="#浏览器历史记录" class="headerlink" title="浏览器历史记录"></a>浏览器历史记录</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><ol><li>浏览器历史记录管理栈</li><li>栈中指针指向的页面</li><li>如何生成一条历史记录<br> 1）点击页面中有a标签的href<br> 2）执行location.href = ‘xxx’(location.replace(‘xxx’)生成一条记录取代当前指针所指向的记录)<br> 3）表单提交跳转（注意只能跳到当前窗口）<br> 4）简单粗暴的方法，直接在当前页面的地址栏中输入地址<br> 5）使用pushState方法可以不刷新页面就可以生成一条历史记录，页面URL发生改变</li><li>如何在浏览器中获取当前页面历史记录状态<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">window.history</span><br><span class="line">如下图所示</span><br><span class="line">length:1  // 表示当前页面中会话历史元素的数目，当打开一个标签页时就会自动生成一个历史记录</span><br><span class="line">scrollRestoration:&quot;auto&quot; // 允许web应用程序在历史导航上显示的设置默认滚动恢复行为。此属性可以是自动的(auto)或者是手动的(manual)。</span><br><span class="line">这是一个实验的属性，在IE和Safari下不支持。</span><br><span class="line">state:null // 返回一个表示历史堆栈顶部的状态的值。这是一种可以不必等待popstate事件而查看状态的方式。</span><br><span class="line">指针指向的记录如果state不为null，则显示存进去的state。</span><br></pre></td></tr></table></figure><img src="https://greenhaha.oss-cn-beijing.aliyuncs.com/frontend/assets/img/history.png" alt="history"></li></ol><h2 id="浏览器对历史记录管理的策略"><a href="#浏览器对历史记录管理的策略" class="headerlink" title="浏览器对历史记录管理的策略"></a>浏览器对历史记录管理的策略</h2><p>每次添加新的历史记录的时候，都会在栈的最顶端<br>在测试的时候在当前页面点击打开测试页面的时候都会生成一条历史记录，新的历史记录会压入栈顶。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;demo1.html&quot;</span>&gt;</span>demo1<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line"> <span class="comment">&lt;!--通过location.href=&quot;demo2.html&quot;改变页面地址：--&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">onclick</span>=<span class="string">&quot;changTo(2);&quot;</span>&gt;</span>href=&quot;demo2.html&quot;<span class="tag">&lt;/<span class="name">button</span>&gt;</span>     </span><br><span class="line"> <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;demo3.html&quot;</span> <span class="attr">method</span>=<span class="string">&quot;get&quot;</span> <span class="attr">class</span>=<span class="string">&quot;dib&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> &gt;</span>demo3.html<span class="tag">&lt;/<span class="name">button</span>&gt;</span><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line"> <span class="comment">&lt;!--通过pushState来改变页面地址：--&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">onclick</span>=<span class="string">&quot;push4()&quot;</span>&gt;</span>pushState&quot;demo4.html&quot;<span class="tag">&lt;/<span class="name">button</span>&gt;</span>   </span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">changTo</span>(<span class="params">index</span>) </span>&#123;</span><br><span class="line"> location.href = <span class="string">&#x27;demo&#x27;</span> + index + <span class="string">&#x27;.html&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span>  <span class="title">push4</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> history.pushState(<span class="string">&#x27;hello&#x27;</span>, <span class="string">&#x27;&#x27;</span>, <span class="string">&#x27;/demo4.html&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>点击demo1,demo2,demo3,demo4，然后再点击demo3,demo2,demo1生成的历史记录如下图</p><p><img src="https://greenhaha.oss-cn-beijing.aliyuncs.com/frontend/assets/img/historylist.png" alt="historylist"></p><p>使用history API操作栈指针来获取历史页面</p><p>指针所在的位置会获取当前页面的state，<br>history.back() : 返回上一页<br>history.forword() ： 跳转到前一页<br>history.go(n) ： n可以为正数也可为负数，代表当前指针是向前移动还是向后移动几个位置。如果n大于或小于历史记录的数目时，指针不会发生任何变化。</p><p>下面图片的操作步骤为：先back() =&gt; go(-2) =&gt; go(-2) =&gt; go(2)</p><p><img src="https://greenhaha.oss-cn-beijing.aliyuncs.com/frontend/assets/img/historylist2.png" alt="history2"></p><p>如果此时在demo3的位置点击demo1，历史记录栈会如下所示：<br>历史记录都是插入在栈指针所在位置的后面，前面的记录会被自动删除</p><p><img src="https://greenhaha.oss-cn-beijing.aliyuncs.com/frontend/assets/img/historylist3.png" alt="historylist3"></p><p>历史记录超过了浏览器限制的最大条数（比如chrome、firfox为50条，IE超过了100），栈顶进入一条历史记录，则栈的底端移出去一条。</p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;</summary>
        
      
    
    
    
    <category term="知识剖析" scheme="http://example.com/categories/%E7%9F%A5%E8%AF%86%E5%89%96%E6%9E%90/"/>
    
    
    <category term="浏览器" scheme="http://example.com/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
    <category term="history" scheme="http://example.com/tags/history/"/>
    
  </entry>
  
  <entry>
    <title>vue初级知识</title>
    <link href="http://example.com/2021/06/20/vue%E5%88%9D%E7%BA%A7%E7%9F%A5%E8%AF%86/"/>
    <id>http://example.com/2021/06/20/vue%E5%88%9D%E7%BA%A7%E7%9F%A5%E8%AF%86/</id>
    <published>2021-06-20T12:26:22.000Z</published>
    <updated>2024-01-02T01:12:08.514Z</updated>
    
    <content type="html"><![CDATA[<h1 id="VUE-初级知识"><a href="#VUE-初级知识" class="headerlink" title="VUE 初级知识"></a>VUE 初级知识</h1><h2 id="什么是渐进式框架"><a href="#什么是渐进式框架" class="headerlink" title="什么是渐进式框架"></a>什么是渐进式框架</h2><p><img src="https://greenhaha.oss-cn-beijing.aliyuncs.com/frontend/assets/img/%E6%B8%90%E8%BF%9B%E5%BC%8F%E6%A1%86%E6%9E%B6.png" alt="渐进式框架"><br><br>“渐进式框架”也非常简单，就是用你x想用或者能用的功能特性，你不想用的部分功能可以先不用。<br>VUE不强求你一次性接受并使用它的全部功能特性。</p><h2 id="什么是MVVM响应式编程模型"><a href="#什么是MVVM响应式编程模型" class="headerlink" title="什么是MVVM响应式编程模型"></a>什么是MVVM响应式编程模型</h2><p><img src="https://greenhaha.oss-cn-beijing.aliyuncs.com/frontend/assets/img/MVVM%E6%A8%A1%E5%9E%8B.png" alt="MVVM模型"></p><p>MVVM：页面输入改变数据，数据改变影响页面数据展示与渲染</p><p>M（model）：普通的javascript数据对象</p><p>V（view）：前端展示页面</p><p>VM（ViewModel）：用于双向绑定数据与页面，可以理解为vue的实例</p><p>“响应式”，是指当数据改变后，Vue 会通知到使用该数据的代码。例如，视图渲染中使用了数据，数据改变后，视图也会自动更新。</p><h2 id="什么是vue"><a href="#什么是vue" class="headerlink" title="什么是vue"></a>什么是vue</h2><p>Vue是一套用于构建用户界面的渐进式框架。与其它大型框架不同的是，Vue 被设计为可以自底向上逐层应用。Vue 的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合。另一方面，当与现代化的工具链以及各种<a href="https://github.com/vuejs/awesome-vue#libraries--plugins">支持类库</a>结合使用时，Vue 也完全能够为复杂的单页应用提供驱动。</p><h3 id="声明式渲染"><a href="#声明式渲染" class="headerlink" title="声明式渲染"></a>声明式渲染</h3><p>Vue.js 的核心是一个允许采用简洁的模板语法来声明式地将数据渲染进 DOM 的系统：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  &#123;&#123; message &#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> app = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  <span class="attr">el</span>: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">  <span class="attr">data</span>: &#123;</span><br><span class="line">    <span class="attr">message</span>: <span class="string">&#x27;Hello Vue!&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>我们已经成功创建了第一个 Vue 应用！看起来这跟渲染一个字符串模板非常类似，但是 Vue 在背后做了大量工作。现在数据和 DOM 已经被建立了关联，所有东西都是响应式的。我们要怎么确认呢？打开你的浏览器的 JavaScript 控制台 (就在这个页面打开)，并修改 <code>app.message</code> 的值，你将看到上例相应地更新。</p><p>注意我们不再和 HTML 直接交互了。一个 Vue 应用会将其挂载到一个 DOM 元素上 (对于这个例子是 <code>#app</code>) 然后对其进行完全控制。那个 HTML 是我们的入口，但其余都会发生在新创建的 Vue 实例内部</p><h3 id="组件-component"><a href="#组件-component" class="headerlink" title="组件(component)"></a>组件(component)</h3><p>组件(Component)是是一个含义很大的概念，一般是指软件系统的一部分，承担了特定的职责，可以独立于整个系统进行开发和测试，一个良好设计的组件应该可以在不同的软件系统中被使用(可复用)。<br>现在流行的react 和vue 都是组件框架。</p><ul><li>基本的例子</li></ul><p>这里有一个 Vue 组件的示例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个名为 button-counter 的新组件</span></span><br><span class="line">Vue.component(<span class="string">&#x27;button-counter&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">data</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">count</span>: <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">template</span>: <span class="string">&#x27;&lt;button v-on:click=&quot;count++&quot;&gt;You clicked me &#123;&#123; count &#125;&#125; times.&lt;/button&gt;&#x27;</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>组件是可复用的 Vue 实例，且带有一个名字：在这个例子中是 <button-counter>。我们可以在一个通过 new Vue 创建的 Vue 根实例中，把这个组件作为自定义元素来使用：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;components-demo&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button-counter</span>&gt;</span><span class="tag">&lt;/<span class="name">button-counter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123; <span class="attr">el</span>: <span class="string">&#x27;#components-demo&#x27;</span> &#125;)</span><br></pre></td></tr></table></figure><p>因为组件是可复用的 Vue 实例，所以它们与 new Vue 接收相同的选项，例如 data、computed、watch、methods 以及生命周期钩子等。仅有的例外是像 el 这样根实例特有的选项。</p><h3 id="模版语法"><a href="#模版语法" class="headerlink" title="模版语法"></a>模版语法</h3><p>Vue.js 使用了基于 HTML 的模板语法，允许开发者声明式地将 DOM 绑定至底层 Vue 实例的数据。所有 Vue.js 的模板都是合法的 HTML，所以能被遵循规范的浏览器和 HTML 解析器解析。</p><p>在底层的实现上，Vue 将模板编译成虚拟 DOM 渲染函数。结合响应系统，Vue 能够智能地计算出最少需要重新渲染多少组件，并把 DOM 操作次数减到最少。</p><p>如果你熟悉虚拟 DOM 并且偏爱 JavaScript 的原始力量，你也可以不用模板，直接写渲染 (render) 函数，使用可选的 JSX 语法。</p><h4 id="文本"><a href="#文本" class="headerlink" title="文本"></a>文本</h4><p>数据绑定最常见的形式就是使用<a href="https://github.com/janl/mustache.js">“Mustache”语法</a> (双大括号) 的文本插值：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">span</span>&gt;</span>Message: &#123;&#123; msg &#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Mustache 标签将会被替代为对应数据对象上 msg property 的值。无论何时，绑定的数据对象上 msg property 发生了改变，插值处的内容都会更新。</p><p>通过使用 v-once 指令，你也能执行一次性地插值，当数据改变时，插值处的内容不会更新。但请留心这会影响到该节点上的其它数据绑定：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">v-once</span>&gt;</span>这个将不会改变: &#123;&#123; msg &#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="原始HTML"><a href="#原始HTML" class="headerlink" title="原始HTML"></a>原始HTML</h4><p>双大括号会将数据解释为普通文本，而非 HTML 代码。为了输出真正的 HTML，你需要使用 v-html 指令：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Using mustaches: &#123;&#123; rawHtml &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Using v-html directive: <span class="tag">&lt;<span class="name">span</span> <span class="attr">v-html</span>=<span class="string">&quot;rawHtml&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这个 <code>span</code> 的内容将会被替换成为 property 值 <code>rawHtml</code>，直接作为 HTML——会忽略解析 property 值中的数据绑定。注意，你不能使用 <code>v-html</code> 来复合局部模板，因为 Vue 不是基于字符串的模板引擎。反之，对于用户界面 (UI)，组件更适合作为可重用和可组合的基本单位。</p><h4 id="Attribute"><a href="#Attribute" class="headerlink" title="Attribute"></a>Attribute</h4><p>Mustache 语法不能作用在 HTML attribute 上，遇到这种情况应该使用 v-bind 指令：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:id</span>=<span class="string">&quot;dynamicId&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>对于布尔 attribute (它们只要存在就意味着值为 true)，v-bind 工作起来略有不同，在这个例子中：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">v-bind:disabled</span>=<span class="string">&quot;isButtonDisabled&quot;</span>&gt;</span>Button<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如果 <code>isButtonDisabled</code> 的值是 <code>null</code>、<code>undefined</code> 或 <code>false</code>，则 <code>disabled</code> <code>attribute</code> 甚至不会被包含在渲染出来的 <code>&lt;button&gt; </code>元素中。</p><h4 id="使用JavaScript表达式"><a href="#使用JavaScript表达式" class="headerlink" title="使用JavaScript表达式"></a>使用JavaScript表达式</h4><p>在我们的模板中，我们一直都只绑定简单的 property 键值。但实际上，对于所有的数据绑定，Vue.js 都提供了完全的 JavaScript 表达式支持.</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123; number + 1 &#125;&#125;</span><br><span class="line"></span><br><span class="line">&#123;&#123; ok ? &#x27;YES&#x27; : &#x27;NO&#x27; &#125;&#125;</span><br><span class="line"></span><br><span class="line">&#123;&#123; message.split(&#x27;&#x27;).reverse().join(&#x27;&#x27;) &#125;&#125;</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:id</span>=<span class="string">&quot;&#x27;list-&#x27; + id&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这些表达式会在所属 Vue 实例的数据作用域下作为 JavaScript 被解析。有个限制就是，每个绑定都只能包含单个表达式，所以下面的例子都不会生效。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 这是语句，不是表达式 --&gt;</span></span><br><span class="line">&#123;&#123; var a = 1 &#125;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 流控制也不会生效，请使用三元表达式 --&gt;</span></span><br><span class="line">&#123;&#123; if (ok) &#123; return message &#125; &#125;&#125;</span><br></pre></td></tr></table></figure><h3 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h3><p>指令（Directives）是带有<code>v-</code>前缀的特殊attribute。指令attribute的值预期是单个JavaScript表达式（<code>v-for</code>是例外）。<br>指令的职责是，当表达式的值改变时，将其产生的连带影响，响应式地作用于 DOM。回顾我们在介绍中看到的例子：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">v-if</span>=<span class="string">&quot;seen&quot;</span>&gt;</span>在你看到我了<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这里，v-if 指令将根据表达式 seen 的值(<code>true</code> or <code>false</code>)的真假来插入/移除 <p> 元素。</p><h3 id="VUE常用指令"><a href="#VUE常用指令" class="headerlink" title="VUE常用指令"></a><code>VUE</code>常用指令</h3><ul><li>v-text<blockquote><p>v-text 等同于 innerText</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 数据插值 : 把数据插入到指定位置 ,并且不会覆盖原有的内容 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123;name&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>+++++n&#123;&#123;name&#125;&#125;+++++<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 数据插值 : 不会解析HMTL标签 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123;span&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- v-text 直接渲染数据, 并且会覆盖原有的数据 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">v-text</span>=<span class="string">&quot;name&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">v-text</span>=<span class="string">&quot;name&quot;</span>&gt;</span>++++++++++<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- v-text 不会渲染 HTML 标签 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">v-text</span>=<span class="string">&quot;span&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">        <span class="attr">el</span>: <span class="string">&quot;#app&quot;</span>,</span></span><br><span class="line"><span class="javascript">        <span class="attr">data</span>: (&#123;</span></span><br><span class="line"><span class="javascript">            <span class="attr">name</span>: <span class="string">&quot;张三&quot;</span>,</span></span><br><span class="line"><span class="javascript">            <span class="attr">span</span>: <span class="string">&quot;&lt;span&gt; 我是span标签 &lt;/span&gt;&quot;</span></span></span><br><span class="line"><span class="javascript">        &#125;)</span></span><br><span class="line"><span class="javascript">    &#125;)</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li>v-html<blockquote><p>v-html 等同于 innerHTML</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 数据插值 : 把数据插入到指定位置 ,并且不会覆盖原有的内容 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123;name&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>+++++n&#123;&#123;name&#125;&#125;+++++<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 数据插值 : 不会解析HMTL标签 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123;span&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- v-html 会覆盖原有数据, 并且可以渲染数据和html标签 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">v-html</span>=<span class="string">&quot;name&quot;</span>&gt;</span>+++++++++<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">v-html</span>=<span class="string">&quot;span&quot;</span>&gt;</span>+++++++++<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">        <span class="attr">el</span>: <span class="string">&quot;#app&quot;</span>,</span></span><br><span class="line"><span class="javascript">        <span class="attr">data</span>: (&#123;</span></span><br><span class="line"><span class="javascript">            <span class="attr">name</span>: <span class="string">&quot;张三&quot;</span>,</span></span><br><span class="line"><span class="javascript">            <span class="attr">span</span>: <span class="string">&quot;&lt;span&gt; 我是span标签 &lt;/span&gt;&quot;</span></span></span><br><span class="line"><span class="javascript">        &#125;)</span></span><br><span class="line"><span class="javascript">    &#125;)</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li>v-show</li></ul><p>源码路径：src/platforms/web/runtime/directives/show.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* @flow */</span></span><br><span class="line"><span class="comment">// 过度动画 在进入和离开的时候有一定过渡效果</span></span><br><span class="line"><span class="keyword">import</span> &#123; enter, leave &#125; <span class="keyword">from</span> <span class="string">&#x27;../modules/transition&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// recursively search for possible transition defined inside the component root 定位元素即效果作用的目标元素</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">locateNode</span> (<span class="params">vnode: VNode</span>): <span class="title">VNodeWithData</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> vnode.componentInstance &amp;&amp; (!vnode.data || !vnode.data.transition)</span><br><span class="line">    ? locateNode(vnode.componentInstance._vnode)</span><br><span class="line">    : vnode</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 对目标元素绑定方法，利用v-dom中element.js 中获取到的元素对象 添加隐藏与显示样式控制</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  bind (el: any, &#123; value &#125;: VNodeDirective, <span class="attr">vnode</span>: VNodeWithData) &#123;</span><br><span class="line">    vnode = locateNode(vnode)</span><br><span class="line">    <span class="keyword">const</span> transition = vnode.data &amp;&amp; vnode.data.transition</span><br><span class="line">    <span class="keyword">const</span> originalDisplay = el.__vOriginalDisplay =</span><br><span class="line">      el.style.display === <span class="string">&#x27;none&#x27;</span> ? <span class="string">&#x27;&#x27;</span> : el.style.display</span><br><span class="line">    <span class="keyword">if</span> (value &amp;&amp; transition) &#123;</span><br><span class="line">      vnode.data.show = <span class="literal">true</span></span><br><span class="line">      enter(vnode, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        el.style.display = originalDisplay</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      el.style.display = value ? originalDisplay : <span class="string">&#x27;none&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  update (el: any, &#123; value, oldValue &#125;: VNodeDirective, <span class="attr">vnode</span>: VNodeWithData) &#123;</span><br><span class="line">    <span class="comment">/* istanbul ignore if */</span></span><br><span class="line">    <span class="keyword">if</span> (!value === !oldValue) <span class="keyword">return</span></span><br><span class="line">    vnode = locateNode(vnode)</span><br><span class="line">    <span class="keyword">const</span> transition = vnode.data &amp;&amp; vnode.data.transition</span><br><span class="line">    <span class="keyword">if</span> (transition) &#123;</span><br><span class="line">      vnode.data.show = <span class="literal">true</span></span><br><span class="line">      <span class="keyword">if</span> (value) &#123;</span><br><span class="line">        enter(vnode, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">          el.style.display = el.__vOriginalDisplay</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        leave(vnode, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">          el.style.display = <span class="string">&#x27;none&#x27;</span></span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      el.style.display = value ? el.__vOriginalDisplay : <span class="string">&#x27;none&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  unbind (</span><br><span class="line">    el: any,</span><br><span class="line">    <span class="attr">binding</span>: VNodeDirective,</span><br><span class="line">    <span class="attr">vnode</span>: VNodeWithData,</span><br><span class="line">    <span class="attr">oldVnode</span>: VNodeWithData,</span><br><span class="line">    <span class="attr">isDestroy</span>: boolean</span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!isDestroy) &#123;</span><br><span class="line">      el.style.display = el.__vOriginalDisplay</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>带有 v-show 的元素始终会被渲染并保留在 DOM 中。v-show 只是简单地切换元素的 CSS property display</p><ul><li>v-if</li></ul><p>因为 v-if 是一个指令，所以必须将它添加到一个元素上。但是如果想切换多个元素呢？此时可以把一个 <code>&lt;template&gt;</code> 元素当做不可见的包裹元素，并在上面使用 v-if。最终的渲染结果将不包含 <code>&lt;template&gt;</code> 元素。<br><br>原理：Vue进行了如下转化template —&gt; ast算法（抽象语法树） —&gt; render函数，最后根据生成的render函数来生成相应的DOM，这里就不拓展讲了。在生成ast和render函数的时候，Vue对v-if这一类指令进行了解析。<br>判断对应的templage中代码块是否显在render函数中进行渲染挂在到真实DOM中<br>详细介绍：v-if 实现原理篇</p><ul><li>v-if-else-if</li></ul><p>使用 v-else 指令来表示 v-if 的“else 块”：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-if</span>=<span class="string">&quot;Math.random() &gt; 0.5&quot;</span>&gt;</span></span><br><span class="line">  Now you see me</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-else</span>&gt;</span></span><br><span class="line">  Now you don&#x27;t</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>v-else 元素必须紧跟在带 v-if 或者 v-else-if 的元素的后面，否则它将不会被识别。</p><p>v-else-if，顾名思义，充当 v-if 的“else-if 块”，可以连续使用：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-if</span>=<span class="string">&quot;type === &#x27;A&#x27;&quot;</span>&gt;</span></span><br><span class="line">  A</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-else-if</span>=<span class="string">&quot;type === &#x27;B&#x27;&quot;</span>&gt;</span></span><br><span class="line">  B</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-else-if</span>=<span class="string">&quot;type === &#x27;C&#x27;&quot;</span>&gt;</span></span><br><span class="line">  C</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-else</span>&gt;</span></span><br><span class="line">  Not A/B/C</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>类似于 v-else，v-else-if 也必须紧跟在带 v-if 或者 v-else-if 的元素之后。</p><ul><li>v-for</li></ul><p>v-for 指令基于一个数组来渲染一个列表。v-for 指令需要使用 item in items 形式的特殊语法，其中 items 是源数据数组，而 item 则是被迭代的数组元素的别名。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">&quot;example-1&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;item in items&quot;</span> <span class="attr">:key</span>=<span class="string">&quot;item.message&quot;</span>&gt;</span></span><br><span class="line">    &#123;&#123; item.message &#125;&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> example1 = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  <span class="attr">el</span>: <span class="string">&#x27;#example-1&#x27;</span>,</span><br><span class="line">  <span class="attr">data</span>: &#123;</span><br><span class="line">    <span class="attr">items</span>: [</span><br><span class="line">      &#123; <span class="attr">message</span>: <span class="string">&#x27;Foo&#x27;</span> &#125;,</span><br><span class="line">      &#123; <span class="attr">message</span>: <span class="string">&#x27;Bar&#x27;</span> &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>在 <code>v-for</code> 块中，我们可以访问所有父作用域的 property。<code>v-for</code> 还支持一个可选的第二个参数，即当前项的索引。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">&quot;example-2&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;(item, index) in items&quot;</span>&gt;</span></span><br><span class="line">    &#123;&#123; parentMessage &#125;&#125; - &#123;&#123; index &#125;&#125; - &#123;&#123; item.message &#125;&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> example2 = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  <span class="attr">el</span>: <span class="string">&#x27;#example-2&#x27;</span>,</span><br><span class="line">  <span class="attr">data</span>: &#123;</span><br><span class="line">    <span class="attr">parentMessage</span>: <span class="string">&#x27;Parent&#x27;</span>,</span><br><span class="line">    <span class="attr">items</span>: [</span><br><span class="line">      &#123; <span class="attr">message</span>: <span class="string">&#x27;Foo&#x27;</span> &#125;,</span><br><span class="line">      &#123; <span class="attr">message</span>: <span class="string">&#x27;Bar&#x27;</span> &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>更多详细内容：v-for 实现原理与介绍</p><ul><li>v-on</li></ul><p>缩写：@</p><p>预期：Function | Inline Statement | Object</p><p>参数：event</p><p>修饰符：</p><ul><li><code>.stop</code> - 调用 <code>event.stopPropagation()</code>。</li><li><code>.prevent</code> - 调用 <code>event.preventDefault()</code>。</li><li><code>.capture</code> - 添加事件侦听器时使用 capture 模式。</li><li><code>.self</code> - 只当事件是从侦听器绑定的元素本身触发时才触发回调。</li><li><code>.&#123;keyCode | keyAlias&#125;</code> - 只当事件是从特定键触发时才触发回调。</li><li><code>.native</code> - 监听组件根元素的原生事件。</li><li><code>.once</code> - 只触发一次回调。</li><li><code>.left</code> - (2.2.0) 只当点击鼠标左键时触发。</li><li><code>.right</code> - (2.2.0) 只当点击鼠标右键时触发。</li><li><code>.middle</code> - (2.2.0) 只当点击鼠标中键时触发。</li><li><code>.passive</code> - (2.3.0) 以 <code>&#123; passive: true &#125;</code> 模式添加侦听器</li></ul><ul><li>用法：</li></ul><p>绑定事件监听器。事件类型由参数指定。表达式可以是一个方法的名字或一个内联语句，如果没有修饰符也可以省略。</p><p>用在普通元素上时，只能监听原生 DOM 事件。用在自定义元素组件上时，也可以监听子组件触发的自定义事件。</p><p>在监听原生 DOM 事件时，方法以事件为唯一的参数。如果使用内联语句，语句可以访问一个 <code>$event</code> property：<code>v-on:click=&quot;handle(&#39;ok&#39;, $event)&quot;</code>。</p><p>从 2.4.0 开始，v-on 同样支持不带参数绑定一个事件/监听器键值对的对象。注意当使用对象语法时，是不支持任何修饰器的。</p><ul><li>v-bind</li></ul><p>缩写：:</p><p>预期：any (with argument) | Object (without argument)</p><p>参数：attrOrProp (optional)</p><p>修饰符：</p><ul><li>.prop - 作为一个 DOM property 绑定而不是作为 attribute 绑定。(差别在哪里？)</li><li>.camel - (2.1.0+) 将 kebab-case attribute 名转换为 camelCase。(从 2.1.0 开始支持)</li><li>.sync (2.3.0+) 语法糖，会扩展成一个更新父组件绑定值的 v-on 侦听器。</li></ul><ul><li>用法：</li></ul><p>动态地绑定一个或多个 attribute，或一个组件 prop 到表达式。</p><p>在绑定 class 或 style attribute 时，支持其它类型的值，如数组或对象。可以通过下面的教程链接查看详情。</p><p>在绑定 prop 时，prop 必须在子组件中声明。可以用修饰符指定不同的绑定类型。</p><p>没有参数时，可以绑定到一个包含键值对的对象。注意此时 class 和 style 绑定不支持数组和对象。</p><ul><li>v-model</li></ul><p><code>v-model</code> 指令在表单 <code>&lt;input&gt;</code>、<code>&lt;textarea&gt;</code> 及 <code>&lt;select&gt;</code> 元素上创建双向数据绑定。它会根据控件类型自动选取正确的方法来更新元素。尽管有些神奇，但 v-model 本质上不过是语法糖。它负责监听用户的输入事件以更新数据，并对一些极端场景进行一些特殊处理。</p><blockquote><p>想要组件 v-model生效 它必须:<br><br>「接收一个value属性」<br><br>「在value值改变时 触发input事件」</p></blockquote><p>注意⚠️</p><blockquote><p>v-model即我们常说的双向绑定，但一定不能跟数据响应原理混为一谈，因为数据响应式是通过数据的改变去驱动视图渲染，而双向绑定除了可以数据驱动DOM渲染，DOM的变化反过来也可以影响数据，是一个双向的关系。</p></blockquote><p><img src="https://greenhaha.oss-cn-beijing.aliyuncs.com/frontend/assets/img/MVVM%E6%A8%A1%E5%9E%8B.png" alt="数据响应式"></p><ul><li>v-cloak</li></ul><p><code>vue</code>如果在网络不好的情况下,在渲染生命式模版的时候比如<code>&#123;&#123;data&#125;&#125;</code>。在浏览器上会显示字符串 。会降低用户体验</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">    <span class="selector-attr">[v-cloak]</span> &#123;</span></span><br><span class="line"><span class="css">    <span class="comment">/* v-cloak 必须配合这个style 进行隐藏 */</span></span></span><br><span class="line"><span class="css">        <span class="attribute">display</span>: none;</span></span><br><span class="line"><span class="css">    &#125;</span></span><br><span class="line"><span class="css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">v-cloak</span>&gt;</span>&#123;&#123; name &#125;&#125; <span class="tag">&lt;<span class="name">span</span>&gt;</span>如果网络差,我则不会显示<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; name &#125;&#125; <span class="tag">&lt;<span class="name">span</span>&gt;</span>无论网络状态如何 ,我都会显示<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;vue.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">        <span class="attr">el</span>: <span class="string">&quot;#app&quot;</span>,</span></span><br><span class="line"><span class="javascript">        <span class="attr">data</span>: (&#123;</span></span><br><span class="line"><span class="javascript">            <span class="attr">name</span>: <span class="string">&quot;张三&quot;</span>,</span></span><br><span class="line"><span class="javascript">        &#125;)</span></span><br><span class="line"><span class="javascript">    &#125;)</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>v-once<blockquote><p>默认情况下, <code>vue</code>事件是可以重复触发的,但是在特定的情况下, 我们只想要事件执行一次.所以就有了<code>v-once</code></p></blockquote></li></ul>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;</summary>
        
      
    
    
    
    <category term="知识剖析" scheme="http://example.com/categories/%E7%9F%A5%E8%AF%86%E5%89%96%E6%9E%90/"/>
    
    
    <category term="JavaScript" scheme="http://example.com/tags/JavaScript/"/>
    
    <category term="HTML" scheme="http://example.com/tags/HTML/"/>
    
    <category term="Vue" scheme="http://example.com/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>vue-router剖析</title>
    <link href="http://example.com/2021/06/04/vue-router/"/>
    <id>http://example.com/2021/06/04/vue-router/</id>
    <published>2021-06-04T14:12:22.000Z</published>
    <updated>2024-01-02T01:12:08.513Z</updated>
    
    <content type="html"><![CDATA[<h1 id="vue-router剖析"><a href="#vue-router剖析" class="headerlink" title="vue-router剖析"></a>vue-router剖析</h1><h2 id="什么是路由"><a href="#什么是路由" class="headerlink" title="什么是路由"></a>什么是路由</h2><p>路由最开始出现在后端。以前用模版开发时或者老系统开发或者做php开发时经常会看到这种url</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://wwww.aaaa.edu.cn/bbs/forum.php</span><br></pre></td></tr></table></figure><p>有时还会有带<code>.asp</code>或<code>.html</code>的路径，这就是所谓的SSR(Server Side Render)，通过服务端渲染，直接返回页面。</p><blockquote><p>服务端渲染（SSR）<br>SSR是Server Side Render简称；页面上的内容是通过服务端渲染生成的，浏览器直接显示服务端返回的html就可以了。</p></blockquote><p>其响应过程为：<br>1.浏览器发出请求</p><p>2.服务器监听到80端口（或443）有请求过来，并解析url路径</p><p>3.根据服务器的路由配置，返回相应信息（可以是 html 字串，也可以是 json 数据，图片等）</p><p>4.浏览器根据数据包的<code>Content-Type</code>来决定如何解析数据<br>路由就是用来跟后端服务器进行交互的一种方式，通过不同的路径，来请求不同的资源，请求不同的页面是路由的其中一种功能。</p><p>前端路由的诞生：<br>前端路由的出现要从ajax开始。</p><p>Ajax，全称 Asynchronous JavaScript And XML，是浏览器用来实现异步加载的一种技术方案。在 90s 年代初，大多数的网页都是通过直接返回 HTML 的，用户的每次更新操作都需要重新刷新页面。及其影响交互体验，随着网络的发展，迫切需要一种方案来改善这种情况。<br>1996，微软首先提出 iframe 标签，iframe 带来了异步加载和请求元素的概念，随后在 1998 年，微软的 Outloook Web App 团队提出 Ajax 的基本概念（XMLHttpRequest的前身），并在 IE5 通过 ActiveX 来实现了这项技术。在微软实现这个概念后，其他浏览器比如 Mozilia，Safari，Opera 相继以 XMLHttpRequest 来实现 Ajax。（  兼容问题从此出现，话说微软命名真喜欢用X，MFC源码一大堆。。）不过在 IE7 发布时，微软选择了妥协，兼容了 XMLHttpRequest 的实现。<br>有了 Ajax 后，用户交互就不用每次都刷新页面，体验带来了极大的提升。<br>但真正让这项技术发扬光大的，(｡･∀･)ﾉﾞ还是后来的 Google Map，它的出现向人们展现了 Ajax 的真正魅力，释放了众多开发人员的想象力，让其不仅仅局限于简单的数据和页面交互，为后来异步交互体验方式的繁荣发展带来了根基。<br>而异步交互体验的更高级版本就是 SPA（那么问个问题，异步交互最高级的体验是什么？会在文末揭晓）—— 单页应用。<br>单页应用不仅仅是在页面交互是无刷新的，连页面跳转都是无刷新的，为了实现单页应用，所以就有了前端路由。单页应用的概念是伴随着 MVVM 出现的。最早由微软提出，然后他们在浏览器端用 <code>Knockoutjs</code> 实现。但这项技术的强大之处并未当时的开发者体会到，可能是因为 <code>Knockoutjs</code> 实现过于复杂，导致没有大面积的扩散。<br>同样，这次接力的选手依然是 Google。Google 通过 Angularjs 将 MVVM 及单页应用发扬光大，让前端开发者能够开发出更加大型的应用，职能变得更大了。（不得不感慨，微软 跟 Google 都是伟大的公司）。随后都是大家都知道的故事，前端圈开始得到了爆发式的发展，陆续出现了很多优秀的框架。</p><h3 id="前端路由原理"><a href="#前端路由原理" class="headerlink" title="前端路由原理"></a>前端路由原理</h3><p>对于vue-router和react-router等前端路由来看，其实原理很简单<br>本质上就是检测url 的变化，截获url地址，然后解析来匹配路由规则。但是这时就会有一些疑问：</p><ul><li>url每次变化都会刷新页面吗？</li><li>页面刷新，javascript怎么检测和获取url？</li></ul><p>对于这2个问题，在很早之前，开发者就想到解决办法：通过hash来实现路由<br>url中hash就类似与下列</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://segmentfault.com/a/1190000011956628#articleHeader2</span><br></pre></td></tr></table></figure><h4 id="hash模式"><a href="#hash模式" class="headerlink" title="hash模式"></a>hash模式</h4><p>这种 <code>#</code>。后面 hash 值的变化，并不会导致浏览器向服务器发出请求，浏览器不发出请求，也就不会刷新页面。另外每次 hash 值的变化，还会触发 <code>hashchange</code> 这个事件，通过这个事件我们就可以知道 hash 值发生了哪些变化.</p><p>对于hash模式实现路由流程如下：<br><img src="https://greenhaha.oss-cn-beijing.aliyuncs.com/frontend/assets/img/routerhash.jpeg" alt="router-hash"></p><p>hash实现方式不需要服务器的支持</p><p>而对于vue-router来说</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// this is delayed until the app mounts</span></span><br><span class="line"><span class="comment">// to avoid the hashchange listener being fired too early</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 添加 url hash 变化的监听器</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">setupListeners () &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.listeners.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> router = <span class="built_in">this</span>.router</span><br><span class="line">    <span class="keyword">const</span> expectScroll = router.options.scrollBehavior</span><br><span class="line">    <span class="keyword">const</span> supportsScroll = supportsPushState &amp;&amp; expectScroll</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (supportsScroll) &#123;</span><br><span class="line">      <span class="built_in">this</span>.listeners.push(setupScroll())</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> handleRoutingEvent = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> current = <span class="built_in">this</span>.current</span><br><span class="line">      <span class="keyword">if</span> (!ensureSlash()) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * transitionTo: </span></span><br><span class="line"><span class="comment">        * 匹配路由</span></span><br><span class="line"><span class="comment">        * 并通过路由配置，把新的页面 render 到 ui-view 的节点</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">      <span class="built_in">this</span>.transitionTo(getHash(), <span class="function"><span class="params">route</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (supportsScroll) &#123;</span><br><span class="line">          handleScroll(<span class="built_in">this</span>.router, route, current, <span class="literal">true</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!supportsPushState) &#123;</span><br><span class="line">          replaceHash(route.fullPath)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> eventType = supportsPushState ? <span class="string">&#x27;popstate&#x27;</span> : <span class="string">&#x27;hashchange&#x27;</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 每当 hash 变化时就解析路径</span></span><br><span class="line"><span class="comment">    * 匹配路由</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">window</span>.addEventListener(</span><br><span class="line">      eventType,</span><br><span class="line">      handleRoutingEvent</span><br><span class="line">    )</span><br><span class="line">    <span class="built_in">this</span>.listeners.push(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">window</span>.removeEventListener(eventType, handleRoutingEvent)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>检测到hash发生变化后通过替换dom形式来实现页面变换</p><h4 id="history模式"><a href="#history模式" class="headerlink" title="history模式"></a>history模式</h4><p>当html5发布后针对与url对象，新增了<code>pushState，</code> 和 <code>replaceState</code><br>通过这两个 API 可以改变 url 地址且不会发送请求。同时还有 <code>onpopstate</code> 事件。通过这些就能用另一种方式来实现前端路由了，但原理都是跟 hash 实现相同的。用了 HTML5 的实现，单页路由的 url 就不会多出一个<code>#</code>，变得更加美观。但因为没有 <code>#</code> 号，所以当用户刷新页面之类的操作时，浏览器还是会给服务器发送请求。为了避免出现这种情况，所以这个实现需要服务器的支持，需要把所有路由都重定向到根页面。具体可以见：[HTML5 histroy 模式](<a href="https://router.vuejs.org/zh/guide/essentials/history-mode.html">HTML5 History 模式</a>)<br><img src="https://greenhaha.oss-cn-beijing.aliyuncs.com/frontend/assets/img/routerhistory.jpeg" alt="router-history"></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* @flow */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">HTML5History</span> <span class="keyword">extends</span> <span class="title">History</span> </span>&#123;</span><br><span class="line">  <span class="attr">_startLocation</span>: string</span><br><span class="line"></span><br><span class="line">  <span class="title">constructor</span> (<span class="params">router: Router, base: ?string</span>) &#123;</span><br><span class="line">    <span class="built_in">super</span>(router, base)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">this</span>._startLocation = getLocation(<span class="built_in">this</span>.base)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  setupListeners () &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.listeners.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> router = <span class="built_in">this</span>.router</span><br><span class="line">    <span class="keyword">const</span> expectScroll = router.options.scrollBehavior</span><br><span class="line">    <span class="keyword">const</span> supportsScroll = supportsPushState &amp;&amp; expectScroll</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (supportsScroll) &#123;</span><br><span class="line">      <span class="built_in">this</span>.listeners.push(setupScroll())</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> handleRoutingEvent = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> current = <span class="built_in">this</span>.current</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Avoiding first `popstate` event dispatched in some browsers but first</span></span><br><span class="line">      <span class="comment">// history route not updated since async guard at the same time.</span></span><br><span class="line">      <span class="keyword">const</span> location = getLocation(<span class="built_in">this</span>.base)</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span>.current === START &amp;&amp; location === <span class="built_in">this</span>._startLocation) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="built_in">this</span>.transitionTo(location, <span class="function"><span class="params">route</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (supportsScroll) &#123;</span><br><span class="line">          handleScroll(router, route, current, <span class="literal">true</span>)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 原理还是跟 hash 实现一样</span></span><br><span class="line"><span class="comment">    * 通过监听 popstate 事件</span></span><br><span class="line"><span class="comment">    * 匹配路由，然后更新页面 DOM</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="built_in">window</span>.addEventListener(<span class="string">&#x27;popstate&#x27;</span>, handleRoutingEvent)</span><br><span class="line">    <span class="built_in">this</span>.listeners.push(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">window</span>.removeEventListener(<span class="string">&#x27;popstate&#x27;</span>, handleRoutingEvent)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  go (n: number) &#123;</span><br><span class="line">    <span class="built_in">window</span>.history.go(n)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  push (location: RawLocation, onComplete?: <span class="built_in">Function</span>, onAbort?: <span class="built_in">Function</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; <span class="attr">current</span>: fromRoute &#125; = <span class="built_in">this</span></span><br><span class="line">    <span class="built_in">this</span>.transitionTo(location, <span class="function"><span class="params">route</span> =&gt;</span> &#123;</span><br><span class="line">      pushState(cleanPath(<span class="built_in">this</span>.base + route.fullPath))</span><br><span class="line">      handleScroll(<span class="built_in">this</span>.router, route, fromRoute, <span class="literal">false</span>)</span><br><span class="line">      onComplete &amp;&amp; onComplete(route)</span><br><span class="line">    &#125;, onAbort)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  replace (location: RawLocation, onComplete?: <span class="built_in">Function</span>, onAbort?: <span class="built_in">Function</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; <span class="attr">current</span>: fromRoute &#125; = <span class="built_in">this</span></span><br><span class="line">    <span class="built_in">this</span>.transitionTo(location, <span class="function"><span class="params">route</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// replaceState 跟 pushState 的区别在于，不会记录到历史栈</span></span><br><span class="line">      replaceState(cleanPath(<span class="built_in">this</span>.base + route.fullPath))</span><br><span class="line">      handleScroll(<span class="built_in">this</span>.router, route, fromRoute, <span class="literal">false</span>)</span><br><span class="line">      onComplete &amp;&amp; onComplete(route)</span><br><span class="line">    &#125;, onAbort)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ensureURL (push?: boolean) &#123;</span><br><span class="line">    <span class="keyword">if</span> (getLocation(<span class="built_in">this</span>.base) !== <span class="built_in">this</span>.current.fullPath) &#123;</span><br><span class="line">      <span class="keyword">const</span> current = cleanPath(<span class="built_in">this</span>.base + <span class="built_in">this</span>.current.fullPath)</span><br><span class="line">      push ? pushState(current) : replaceState(current)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  getCurrentLocation (): string &#123;</span><br><span class="line">    <span class="keyword">return</span> getLocation(<span class="built_in">this</span>.base)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">getLocation</span> (<span class="params">base: string</span>): <span class="title">string</span> </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> path = <span class="built_in">window</span>.location.pathname</span><br><span class="line">  <span class="keyword">const</span> pathLowerCase = path.toLowerCase()</span><br><span class="line">  <span class="keyword">const</span> baseLowerCase = base.toLowerCase()</span><br><span class="line">  <span class="comment">// base=&quot;/a&quot; shouldn&#x27;t turn path=&quot;/app&quot; into &quot;/a/pp&quot;</span></span><br><span class="line">  <span class="comment">// https://github.com/vuejs/vue-router/issues/3555</span></span><br><span class="line">  <span class="comment">// so we ensure the trailing slash in the base</span></span><br><span class="line">  <span class="keyword">if</span> (base &amp;&amp; ((pathLowerCase === baseLowerCase) ||</span><br><span class="line">    (pathLowerCase.indexOf(cleanPath(baseLowerCase + <span class="string">&#x27;/&#x27;</span>)) === <span class="number">0</span>))) &#123;</span><br><span class="line">    path = path.slice(base.length)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> (path || <span class="string">&#x27;/&#x27;</span>) + <span class="built_in">window</span>.location.search + <span class="built_in">window</span>.location.hash</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>对于vue-router来说上面的两种模式其实是依赖与浏览器环境。而对于实际开发过程中，往往出现另外一种情况：<br>就是针对于服务端渲染情况下，不存在浏览器api环境中，如果需要路由该怎么办？</p><h4 id="abstract模式"><a href="#abstract模式" class="headerlink" title="abstract模式"></a>abstract模式</h4><p>abstract模式是使用一个不依赖于浏览器的浏览历史虚拟管理后端。支持所有 JavaScript 运行环境，如 Node.js 服务器端。</p><p>对于abstract根据平台差异可以看出，在 Weex 环境中只支持使用 abstract 模式。 不过，vue-router 自身会对环境做校验，如果发现没有浏览器的 API，vue-router 会自动强制进入 abstract 模式，所以 在使用 vue-router 时只要不写 mode 配置即可，默认会在浏览器环境中使用 hash 模式，在移动端原生环境中使用 abstract 模式。 （当然，你也可以明确指定在所有情况下都使用 abstract 模式）</p><p>而对于vue-router中<code>abstract.js</code> 中<code>AbstractHistory</code>是个比较特别的实现，因为它不是浏览器环境，所以它没有<code>window.history</code>，它不需要再去考虑<code>popstate </code> <code>hashchange</code>事件，不需要去管浏览器的地址栏，但是它需要自己管理路由历史记录。所在<code>AbstractHistory</code>里面，设置了stack数组来存储访问的路由对象，设置了一个index实例属性，来表示当前访问的路由位置。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* @flow */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> type Router <span class="keyword">from</span> <span class="string">&#x27;../index&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; History &#125; <span class="keyword">from</span> <span class="string">&#x27;./base&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; NavigationFailureType, isNavigationFailure &#125; <span class="keyword">from</span> <span class="string">&#x27;../util/errors&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractHistory</span> <span class="keyword">extends</span> <span class="title">History</span> </span>&#123;</span><br><span class="line">  <span class="attr">index</span>: number</span><br><span class="line">  <span class="attr">stack</span>: <span class="built_in">Array</span>&lt;Route&gt;</span><br><span class="line"></span><br><span class="line">  <span class="title">constructor</span> (<span class="params">router: Router, base: ?string</span>) &#123;</span><br><span class="line">    <span class="built_in">super</span>(router, base)</span><br><span class="line">    <span class="built_in">this</span>.stack = []</span><br><span class="line">    <span class="built_in">this</span>.index = -<span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  push (location: RawLocation, onComplete?: <span class="built_in">Function</span>, onAbort?: <span class="built_in">Function</span>) &#123;</span><br><span class="line">    <span class="built_in">this</span>.transitionTo(</span><br><span class="line">      location,</span><br><span class="line">      <span class="function"><span class="params">route</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.stack = <span class="built_in">this</span>.stack.slice(<span class="number">0</span>, <span class="built_in">this</span>.index + <span class="number">1</span>).concat(route)</span><br><span class="line">        <span class="built_in">this</span>.index++</span><br><span class="line">        onComplete &amp;&amp; onComplete(route)</span><br><span class="line">      &#125;,</span><br><span class="line">      onAbort</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  replace (location: RawLocation, onComplete?: <span class="built_in">Function</span>, onAbort?: <span class="built_in">Function</span>) &#123;</span><br><span class="line">    <span class="built_in">this</span>.transitionTo(</span><br><span class="line">      location,</span><br><span class="line">      <span class="function"><span class="params">route</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.stack = <span class="built_in">this</span>.stack.slice(<span class="number">0</span>, <span class="built_in">this</span>.index).concat(route)</span><br><span class="line">        onComplete &amp;&amp; onComplete(route)</span><br><span class="line">      &#125;,</span><br><span class="line">      onAbort</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  go (n: number) &#123;</span><br><span class="line">    <span class="keyword">const</span> targetIndex = <span class="built_in">this</span>.index + n</span><br><span class="line">    <span class="keyword">if</span> (targetIndex &lt; <span class="number">0</span> || targetIndex &gt;= <span class="built_in">this</span>.stack.length) &#123;</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> route = <span class="built_in">this</span>.stack[targetIndex]</span><br><span class="line">    <span class="built_in">this</span>.confirmTransition(</span><br><span class="line">      route,</span><br><span class="line">      <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> prev = <span class="built_in">this</span>.current</span><br><span class="line">        <span class="built_in">this</span>.index = targetIndex</span><br><span class="line">        <span class="built_in">this</span>.updateRoute(route)</span><br><span class="line">        <span class="built_in">this</span>.router.afterHooks.forEach(<span class="function"><span class="params">hook</span> =&gt;</span> &#123;</span><br><span class="line">          hook &amp;&amp; hook(route, prev)</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (isNavigationFailure(err, NavigationFailureType.duplicated)) &#123;</span><br><span class="line">          <span class="built_in">this</span>.index = targetIndex</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  getCurrentLocation () &#123;</span><br><span class="line">    <span class="keyword">const</span> current = <span class="built_in">this</span>.stack[<span class="built_in">this</span>.stack.length - <span class="number">1</span>]</span><br><span class="line">    <span class="keyword">return</span> current ? current.fullPath : <span class="string">&#x27;/&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ensureURL () &#123;</span><br><span class="line">    <span class="comment">// noop</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h6 id="go的处理"><a href="#go的处理" class="headerlink" title="go的处理"></a>go的处理</h6><p>不同于Html5History HashHistory可以直接使用window.history.go来实现go这个方法，AbstractHistory必须自己来实现go方法。不过看go的代码，不太明白一点：为什么不直接用transitionTo这个统一的路由跳转入口，而是要使用更加底层的confirmTranstion方法。</p><p>这行代码:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (isExtendedError(NavigationDuplicated, err)) &#123;</span><br><span class="line">  <span class="built_in">this</span>.index = targetIndex</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>找到这行代码的添加的原因了： <a href="https://github.com/vuejs/vue-router/pull/2771">bug fix</a>、<a href="https://github.com/vuejs/vue-router/issues/2607">issue</a></p><blockquote><p>This PR provides a fix to the issue #2607.<br>Reproduction link<br><a href="https://jsfiddle.net/Rocka/bhu5vkn8/3/">https://jsfiddle.net/Rocka/bhu5vkn8/3/</a><br>In abstract mode, if you try to navigate through your history with the same routes appearing consecutively in your stack history, the history index remains unchanged.<br>In History or Hash mode, this issue does not appear because history navigation is handled by the browser and not by vue-router. In all modes, we do not want to re-render a page if the current route and the next route are identical. However, in the case of abstract mode, we still need to update the history index whenever the current and next routes are the same since AbstractHistory handles its own history stack.</p></blockquote><p>go里面的处理有一点是对的，就是不改变stack数组的内容，只调整访问的指针index。这是与浏览器历史记录管理的特点相符的.</p><h6 id="replace处理"><a href="#replace处理" class="headerlink" title="replace处理"></a>replace处理</h6><p>replace方法看起来对于历史记录的管理，跟浏览器的管理方式不同，就是它会删除掉当前记录之后的记录，而不是仅仅替换当前记录，这一点在注释中有说明。</p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;</summary>
        
      
    
    
    
    <category term="知识剖析" scheme="http://example.com/categories/%E7%9F%A5%E8%AF%86%E5%89%96%E6%9E%90/"/>
    
    
    <category term="Node" scheme="http://example.com/tags/Node/"/>
    
    <category term="JavaScript" scheme="http://example.com/tags/JavaScript/"/>
    
    <category term="vue" scheme="http://example.com/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>Node与V8</title>
    <link href="http://example.com/2021/05/16/node%E6%B5%85%E8%B0%88/"/>
    <id>http://example.com/2021/05/16/node%E6%B5%85%E8%B0%88/</id>
    <published>2021-05-16T14:12:22.000Z</published>
    <updated>2024-01-02T01:12:08.508Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Node与V8"><a href="#Node与V8" class="headerlink" title="Node与V8"></a>Node与V8</h1><h2 id="Node"><a href="#Node" class="headerlink" title="Node"></a>Node</h2><h3 id="node-js-是什么？"><a href="#node-js-是什么？" class="headerlink" title="node.js 是什么？"></a>node.js 是什么？</h3><p>Node.js 是能够在服务器端运行的JavaScript的开放源代码，跨平台运行环境。Node.js采用Google V8 运行代码。<br>利用事件驱动，非阻塞和异步输入输出模型等技术来提高性能。可优化应用程序的传输量和规模。</p><blockquote><p>术语：<br><strong>事件驱动</strong>：现代系统都是主程序启动完毕后，对每个收到的请求开启一个进程，然后根据不同的技术有不同的处理方式。典型的实现就是：针对一个请求开启一个线程，一步接着一步执行任务操作。如果操作缓慢则后续的操作就会挂起。直到所有操作完成，返回结果。对于Node.js中，所有的操作都注册为一个事件，等待主程序或者外部请求来触发。<br>运行时：Node.js 运行时是指所有这些代码（上述所有组件，包括底层和上层）提供给 Node.js 应用程序执行的环境<br><strong>I/O</strong>：输入/输入 基本上代指那些主要由计算机 I/O 子系统处理的操作。重 I/O 操作（I/O-bound operations）通常会牵涉到磁盘或驱动器访问，例如数据库访问或文件系统相关操作。它们的区分是根据系统哪部分性能对这个操作有最大的影响。比如对于某项操作而言，CPU 运算能力提高可以带来最大的提升，这项操作就属于重 CPU 操作。<br><strong>非阻塞/异步</strong>：当一项请求发来，应用程序会处理这个请求。其他操作需要等这个请求完成后才能执行。对于这种情况，Node.js采用另一种方式，不再为每个请求开启一个新的线程，而是将所有请求都在单一的主线程中处理。对于其他操作，比如：处理请求–请求中包含的I/O操作文件系统访问，数据库读写等都是转发给libuv管理的工作线程去执行，也就是请求中I/O操作是异步的，并非是主线程上进行。这个方法从而不会导致主线程堵塞。所有耗时的任务处理都分配到其他工作线程中。而我们需要面对的只有唯一主线程。所有libuv管理的工作线程都和唯一主线程隔离开。在这个架构之上重 I/O 操作变得格外高效，那些重 CPU、重内存的也一样。</p></blockquote><h3 id="node的内部结构"><a href="#node的内部结构" class="headerlink" title="node的内部结构"></a>node的内部结构</h3><p><img src="https://greenhaha.oss-cn-beijing.aliyuncs.com/frontend/assets/img/node.png" alt="node 内部结构"></p><p>V8: V8是一个开源JavaScript引擎。用C++实现，chrome中集成的JavaScript引擎就是V8引擎。在V8运行之前就会将JavaScript编译成机器代码，而非字节码或者是解释执行它，以提升性能与运行速度。这也是为什么JavaScript程序和V8引擎的速度媲美二进制编译。<br>（<a href="https://stackoverflow.com/questions/40994/is-google-chromes-v8-engine-really-that-good/41932#41932">速度有多快</a>）</p><p>libuv: 提供异步功能的C库。它在运行时负责一个事件循环(Event Loop),一个线程池 文件系统I/O，DNS相关的网络I/O，以及管理进程相关的函数等一些重要内容。</p><p>其他 C/C++ 组件和库：如 c-ares、crypto (OpenSSL)、http-parser 以及 zlib。这些依赖提供了对系统底层功能的访问，包括网络、压缩、加密等。</p><p>应用/模块（Application/Modules）：所有的JavaScript代码（可以理解为应用层）。JavaScript编写的应用程序，Node.js 核心模块，npm安装的相关依赖包，一节自己写的所有模块代码。</p><p>C/C++ Binding（绑定）：根据字面意思就可以理解为代码的粘合作用，JavaScript代码如何能与C/C++代码中相互调用，离不开Binding。Binding能够将不同语言并定在一起相互调用。Binding的实现方式就是将Node.js那些C/C++写的库暴露给JavaScript环境中。目的之一就是可以进行代码的复用，无需为了考虑其他语言环境，很多机制与实现已经很成熟，只需要桥接一下就可以了。另外一个就是性能：C/C++ 这样的系统编程语言通常都比其他高阶语言（Python、JavaScript、Ruby 等等）性能更高。所以把主要消耗 CPU 的操作以 C/C++ 代码来执行更加明智</p><p>C/C++ Addons：binding仅仅只是起到把上层应用程序与底层核心库（c-ares、crypto (OpenSSL)、http-parser 以及 zlib）桥接作用，但是如果在某些情况下，应用程序会需要第三方或者自己编写的 C/C++ 库的话，那么就需要Addons来将应用程序与第三方库或者自己的的C/C++ 库进行桥接（粘合）</p><h4 id="运行机制"><a href="#运行机制" class="headerlink" title="运行机制"></a>运行机制</h4><p>mbq打了一个很有形象的比方：</p><blockquote><p>I have come up with an analogy; web application should be as a restaurant. You have waiters (web server) and cooks (workers). Waiters are in contact with clients and do simple tasks like providing menu or explaining if some dish is vegetarian. On the other hand they delegate harder tasks to the kitchen. Because waiters are doing only simple things they respond quick, and cooks can concentrate on their job.</p></blockquote><p>也可以将Nodejs应用程序比较汉堡店，高水平前台服务员（唯一主线程）在柜台接受订单<br></p><ul><li>当有很多顾客到来的的时候，顾客就会排队（进入事件队列）等待接待。<br></li><li>每当服务员接待一个顾客的时候，服务员会将订单告诉经理（libuv）。经理会安排相应的专职人员去制作汉堡（工作线程和系统特性）。<br></li><li>专职人员会使用不同的材料与机器（底层 C/C++ 组件）按照订单要求制作汉堡。通常会有4个专职人员在岗待命（线程池），订单较多的情况下可以安排更多人（不过需要提前安排，无法进行临时通知）。<br></li><li>前台服务员在将订单交给经理后无需等待汉堡制作完成，可以直接接待下一个顾客。（事件循环放到调用堆栈的另一个事件）。你可以把当前调用堆栈里的事件看成是站在柜台前正在接受服务的顾客.<br></li><li>当汉堡制作完成后，会发送到顾客队列最后位置。当它移动到柜台前服务员会叫相应顾客名称取餐。<br><img src="https://greenhaha.oss-cn-beijing.aliyuncs.com/frontend/assets/img/shangdian.png" alt="商店"></li></ul><h2 id="V8"><a href="#V8" class="headerlink" title="V8"></a>V8</h2><blockquote><p>术语：<br>AST语法树：在计算机科学中，抽象语法树（Abstract Syntax Tree，AST），或简称语法树（Syntax tree），是源代码语法结构的一种抽象表示。它以树状的形式表现编程语言的语法结构，树上的每个节点都表示源代码中的一种结构。<br>机器码：机器语言（machine language）是一种指令集的体系。这种指令集称为机器代码（machine code），是电脑的CPU可直接解读的资料。<br>字节码：字节码（英语：Bytecode）通常指的是已经经过编译，但与特定机器代码无关，需要解释器转译后才能成为机器代码的中间代码。字节码通常不像源码一样可以让人阅读，而是编码后的数值常量、引用、指令等构成的序列。<br>JIT:在计算机技术中，即时编译（英语：just-in-time compilation，缩写为JIT；又译及时编译、实时编译），也称为动态翻译或运行时编译，是一种执行计算机代码的方法，这种方法涉及在程序执行过程中（在运行期）而不是在执行之前进行编译。通常，这包括源代码或更常见的字节码到机器码的转换，然后直接执行。</p></blockquote><h3 id="什么是V8？"><a href="#什么是V8？" class="headerlink" title="什么是V8？"></a>什么是V8？</h3><p>v8: 是Google 的开源高性能的由C++编写的JavaScript和webAssembly引擎。它实现了<code>ECMAScript</code>和<code>WebAssembly</code>并在多个不同平台中运行。V8可以独立运行也可以嵌套在任何C++应用程序中。</p><blockquote><p>V8 is Google’s open source high-performance JavaScript and WebAssembly engine, written in C++. It is used in Chrome and in Node.js, among others. It implements ECMAScript and WebAssembly, and runs on Windows 7 or later, macOS 10.12+, and Linux systems that use x64, IA-32, ARM, or MIPS processors. V8 can run standalone, or can be embedded into any C++ application.  –<a href="https://v8.dev/">v8官网</a></p></blockquote><p>V8只是JavaScript引擎的一种，常说的JavaScript引擎有很多中：</p><ol><li>JavaScriptCore 代表浏览器Safari</li><li>Rhino 代表浏览器Mozilla Firefox</li><li>Chakra 代表浏览器Internet Explorer(IE)</li><li>V8 代表浏览器 Chrome 开源，用 C++ 实现的</li></ol><h3 id="解释器和编译器"><a href="#解释器和编译器" class="headerlink" title="解释器和编译器"></a>解释器和编译器</h3><ul><li>编译型语言在程序执行之前，需要经过编译器的编译过程，并且编译之后会直接保留机器能读懂的二进制文件，这样每次运行程序时，都可以直接运行该二进制文件，而不需要再次重新编译了。</li><li>而由解释型语言编写的程序，在每次运行时都需要通过解释器对程序进行动态解释和执行。<br><img src="https://greenhaha.oss-cn-beijing.aliyuncs.com/frontend/assets/img/%E8%A7%A3%E9%87%8A%E5%99%A8.png"><br>大致流程：</li></ul><ol><li>在编译型语言的编译过程中，编译器首先会依次对源代码进行词法分析、语法分析，生成抽象语法树（AST），然后是优化代码，最后再生成处理器能够理解的机器码。如果编译成功，将会生成一个可执行的文件。但如果编译过程发生了语法或者其他的错误，那么编译器就会抛出异常，最后的二进制文件也不会生成成功。</li><li>在解释型语言的解释过程中，同样解释器也会对源代码进行词法分析、语法分析，并生成抽象语法树（AST），不过它会再基于抽象语法树生成字节码，最后再根据字节码来执行程序、输出结果。</li></ol><h3 id="V8内部中JavaScript执行过程："><a href="#V8内部中JavaScript执行过程：" class="headerlink" title="V8内部中JavaScript执行过程："></a>V8内部中JavaScript执行过程：</h3><p><img src="https://greenhaha.oss-cn-beijing.aliyuncs.com/frontend/assets/img/v8js.png" alt="V8 javascript"></p><ol><li>Js代码转换成AST语法树表示</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数</span></span><br><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">greet</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="string">&quot;wlove&quot;</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">// AST树 json</span></span><br><span class="line"> &#123;<span class="string">&quot;type&quot;</span>:<span class="string">&quot;Program&quot;</span>,<span class="string">&quot;start&quot;</span>:<span class="number">0</span>,<span class="string">&quot;end&quot;</span>:<span class="number">47</span>,<span class="string">&quot;body&quot;</span>:[&#123;<span class="string">&quot;type&quot;</span>:<span class="string">&quot;FunctionDeclaration&quot;</span>,<span class="string">&quot;start&quot;</span>:<span class="number">0</span>,<span class="string">&quot;end&quot;</span>:<span class="number">46</span>,<span class="string">&quot;id&quot;</span>:&#123;<span class="string">&quot;type&quot;</span>:<span class="string">&quot;Identifier&quot;</span>,<span class="string">&quot;start&quot;</span>:<span class="number">9</span>,<span class="string">&quot;end&quot;</span>:<span class="number">14</span>,<span class="string">&quot;name&quot;</span>:<span class="string">&quot;greet&quot;</span>&#125;,<span class="string">&quot;expression&quot;</span>:<span class="literal">false</span>,<span class="string">&quot;generator&quot;</span>:<span class="literal">false</span>,<span class="string">&quot;async&quot;</span>:<span class="literal">false</span>,<span class="string">&quot;params&quot;</span>:[],<span class="string">&quot;body&quot;</span>:&#123;<span class="string">&quot;type&quot;</span>:<span class="string">&quot;BlockStatement&quot;</span>,<span class="string">&quot;start&quot;</span>:<span class="number">17</span>,<span class="string">&quot;end&quot;</span>:<span class="number">46</span>,<span class="string">&quot;body&quot;</span>:[&#123;<span class="string">&quot;type&quot;</span>:<span class="string">&quot;ExpressionStatement&quot;</span>,<span class="string">&quot;start&quot;</span>:<span class="number">23</span>,<span class="string">&quot;end&quot;</span>:<span class="number">44</span>,<span class="string">&quot;expression&quot;</span>:&#123;<span class="string">&quot;type&quot;</span>:<span class="string">&quot;CallExpression&quot;</span>,<span class="string">&quot;start&quot;</span>:<span class="number">23</span>,<span class="string">&quot;end&quot;</span>:<span class="number">43</span>,<span class="string">&quot;callee&quot;</span>:&#123;<span class="string">&quot;type&quot;</span>:<span class="string">&quot;MemberExpression&quot;</span>,<span class="string">&quot;start&quot;</span>:<span class="number">23</span>,<span class="string">&quot;end&quot;</span>:<span class="number">34</span>,<span class="string">&quot;object&quot;</span>:&#123;<span class="string">&quot;type&quot;</span>:<span class="string">&quot;Identifier&quot;</span>,<span class="string">&quot;start&quot;</span>:<span class="number">23</span>,<span class="string">&quot;end&quot;</span>:<span class="number">30</span>,<span class="string">&quot;name&quot;</span>:<span class="string">&quot;console&quot;</span>&#125;,<span class="string">&quot;property&quot;</span>:&#123;<span class="string">&quot;type&quot;</span>:<span class="string">&quot;Identifier&quot;</span>,<span class="string">&quot;start&quot;</span>:<span class="number">31</span>,<span class="string">&quot;end&quot;</span>:<span class="number">34</span>,<span class="string">&quot;name&quot;</span>:<span class="string">&quot;log&quot;</span>&#125;,<span class="string">&quot;computed&quot;</span>:<span class="literal">false</span>,<span class="string">&quot;optional&quot;</span>:<span class="literal">false</span>&#125;,<span class="string">&quot;arguments&quot;</span>:[&#123;<span class="string">&quot;type&quot;</span>:<span class="string">&quot;Literal&quot;</span>,<span class="string">&quot;start&quot;</span>:<span class="number">35</span>,<span class="string">&quot;end&quot;</span>:<span class="number">42</span>,<span class="string">&quot;value&quot;</span>:<span class="string">&quot;wlove&quot;</span>,<span class="string">&quot;raw&quot;</span>:<span class="string">&quot;\&quot;wlove\&quot;&quot;</span>&#125;],<span class="string">&quot;optional&quot;</span>:<span class="literal">false</span>&#125;&#125;]&#125;&#125;],<span class="string">&quot;sourceType&quot;</span>:<span class="string">&quot;module&quot;</span>&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://greenhaha.oss-cn-beijing.aliyuncs.com/frontend/assets/img/AST%E8%AF%AD%E6%B3%95%E6%A0%91.png" alt="AST树"></p><ol start="2"><li><p>AST转换成字节码<br>之前的V8直接是转换机器码。但是机器码占空间很大，如果v8 缓存机制将 所有 js 代码编译成机器码缓存下来，这样会导致缓存占用的内存、磁盘空间很大。而且退出 Chrome 再打开时序列化、反序列化缓存时间成本也很高。在时间,空间成本都很高的情况下 引入了字节码。</p></li><li><p>字节码解释器<code>TurboFan</code>内部也存在很多工作内容:</p></li></ol><ul><li>字节码处理程序生成</li><li>字节码生成</li><li>解释器寄存器分配</li><li>Context链</li><li>异常处理</li><li>JS代码解释执行</li></ul><ol start="4"><li><p>JIT (Just In Time) 混合使用编译器和解释器的技术。编译器启动速度慢，执行速度快。解释器的启动速度快，执行速度慢。而JIT技术就是取俩者之长 (Ignition(字节码解释器) + TurboFan (JIT编译器) 的组合;</p></li><li><p>虚拟机(垃圾回收,内存管理等)<br><img src="https://greenhaha.oss-cn-beijing.aliyuncs.com/frontend/assets/img/%E8%99%9A%E6%8B%9F%E6%9C%BA.png" alt="虚拟机"></p></li></ol><p>V8 使用了分代和大数据的内存分配，在回收内存时使用精简整理的算法标记未引用的对象，然后消除没有标记的对象，最后整理和压缩那些还未保存的对象，即可完成垃圾回收。<br><strong>内存分配</strong>:</p><ul><li>年轻分代：为新创建的对象分配内存空间，经常需要进行垃圾回收。为方便年轻分代中的内容回收，可再将年轻分代分为两半，一半用来分配，另一半在回收时负责将之前还需要保留的对象复制过来。</li><li>年老分代：根据需要将年老的对象、指针、代码等数据保存起来，较少地进行垃圾回收。</li><li>大对象：为那些需要使用较多内存对象分配内存，当然同样可能包含数据和代码等分配的内存，一个页面只分配一个对象。</li></ul><p><strong>内存(垃圾)回收</strong>:</p><ol><li>年轻分代中的对象垃圾回收主要通过Scavenge算法进行垃圾回收。</li><li>因考虑在年老分代中存活对象居多,所以主要采用了Mark-Sweep（标记清除）标记清除和Mark-Compact（标记整理）相结合的方式进行垃圾回收。</li></ol><h3 id="V8引擎的内部结构"><a href="#V8引擎的内部结构" class="headerlink" title="V8引擎的内部结构"></a>V8引擎的内部结构</h3><p>V8是一个很复杂的项目，它有很多子模块构成，其中有4个模块尤为重要：</p><ul><li><blockquote><p>Parser：负责将 JavaScript 源码转换为 Abstract Syntax Tree (AST)<br><br>  确切的说，在“Parser”将 JavaScript 源码转换为 AST前，还有一个叫”Scanner“的过程，具体流程如下：<br>  <img src="https://greenhaha.oss-cn-beijing.aliyuncs.com/frontend/assets/img/parser.png" alt="parser"></p></blockquote></li><li><blockquote><p>Ignition：interpreter，即解释器，负责将 AST 转换为 Bytecode，解释执行 Bytecode；同时收集 TurboFan 优化编译所需的信息，比如函数参数的类型；解释器执行时主要有四个模块，内存中的字节码、寄存器、栈、堆.<br><br>通常有两种类型的解释器，基于栈 (Stack-based)和基于寄存器 (Register-based)，基于栈的解释器使用栈来保存函数参数、中间运算结果、变量等；基于寄存器的虚拟机则支持寄存器的指令操作，使用寄存器来保存参数、中间计算结果。通常，基于栈的虚拟机也定义了少量的寄存器，基于寄存器的虚拟机也有堆栈，其区别体现在它们提供的指令集体系。大多数解释器都是基于栈的，比如 Java 虚拟机，.Net 虚拟机，还有早期的 V8 虚拟机。基于堆栈的虚拟机在处理函数调用、解决递归问题和切换上下文时简单明快。而现在的 V8 虚拟机则采用了基于寄存器的设计，它将一些中间数据保存到寄存器中。<br>基于寄存器的解释器架构：<br><img src="https://greenhaha.oss-cn-beijing.aliyuncs.com/frontend/assets/img/ignition.jpeg" alt="ignition"><br>资料参考：<a href="https://time.geekbang.org/column/article/224908">解释器是如何解释执行字节码的？</a></p></blockquote></li><li><p>TurboFan：compiler，即编译器，利用 Ignition 所收集的类型信息，将 Bytecode 转换为优化的汇编代码；</p></li><li><p>Orinoco：garbage collector，垃圾回收模块，负责将程序不再需要的内存空间回收</p></li></ul><p>Parser，Ignition 以及 TurboFan 可以将 JS 源码编译为汇编代码，其流程图如下：<br><img src="https://greenhaha.oss-cn-beijing.aliyuncs.com/frontend/assets/img/ignition-turbofan-pipeline.jpeg" alt="ignition-turbofan-pipeline"></p><p>简单地说，Parser 将 JS 源码转换为 AST，然后 Ignition 将 AST 转换为 Bytecode，最后 TurboFan 将 Bytecode 转换为经过优化的 Machine Code(实际上是汇编代码)。</p><ul><li>如果函数没有被调用，则 V8 不会去编译它。</li><li>如果函数只被调用 1 次，则 Ignition 将其编译 Bytecode 就直接解释执行了。TurboFan 不会进行优化编译，因为它需要 Ignition 收集函数执行时的类型信息。这就要求函数至少需要执行 1 次，TurboFan 才有可能进行优化编译。</li><li>如果函数被调用多次，则它有可能会被识别为热点函数，且 Ignition 收集的类型信息证明可以进行优化编译的话，这时 TurboFan 则会将 Bytecode 编译为 Optimized Machine Code（已优化的机器码），以提高代码的执行性能。<br><br>图片中的红色虚线是逆向的，也就是说 Optimized Machine Code 会被还原为 Bytecode，这个过程叫做 Deoptimization。这是因为 Ignition 收集的信息可能是错误的，比如 add 函数的参数之前是整数，后来又变成了字符串。生成的 Optimized Machine Code 已经假定 add 函数的参数是整数，那当然是错误的，于是需要进行 Deoptimization。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">add(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">add(<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2&#x27;</span>);</span><br></pre></td></tr></table></figure><p>在运行 C、C++以及 Java 等程序之前，需要进行编译，不能直接执行源码；但对于 JavaScript 来说，我们可以直接执行源码(比如：node test.js)，它是在运行的时候先编译再执行，这种方式被称为即时编译(Just-in-time compilation)，简称为 JIT。因此，V8 也属于 JIT 编译器。</p><blockquote><p>资料拓展参考：<a href="https://www.cnblogs.com/fundebug/archive/2019/07/16/how-does-v8-work.html">V8 引擎是如何工作的？</a></p></blockquote>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;</summary>
        
      
    
    
    
    <category term="知识剖析" scheme="http://example.com/categories/%E7%9F%A5%E8%AF%86%E5%89%96%E6%9E%90/"/>
    
    
    <category term="Node" scheme="http://example.com/tags/Node/"/>
    
    <category term="JavaScript" scheme="http://example.com/tags/JavaScript/"/>
    
    <category term="v8" scheme="http://example.com/tags/v8/"/>
    
  </entry>
  
  <entry>
    <title>v8 如何工作</title>
    <link href="http://example.com/2021/04/15/V8%E8%AF%A6%E8%B0%88/"/>
    <id>http://example.com/2021/04/15/V8%E8%AF%A6%E8%B0%88/</id>
    <published>2021-04-15T14:12:22.000Z</published>
    <updated>2024-01-02T01:12:08.502Z</updated>
    
    <content type="html"><![CDATA[<h1 id="v8-如何工作"><a href="#v8-如何工作" class="headerlink" title="v8 如何工作"></a>v8 如何工作</h1><h2 id="V8如何执行一段JavaScript代码"><a href="#V8如何执行一段JavaScript代码" class="headerlink" title="V8如何执行一段JavaScript代码"></a>V8如何执行一段JavaScript代码</h2><ul><li><p>在 V8 出现之前，所有的 JavaScript 虚拟机所采用的都是解释执行的方式，这是 JavaScript 执行速度过慢的一个主要原因。而 V8 率先引入了即时编译（JIT）的双轮驱动的设计（混合使用编译器和解释器的技术），这是一种权衡策略，混合编译执行和解释执行这两种手段，给 JavaScript 的执行速度带来了极大的提升。V8 出现之后，各大厂商也都在自己的 JavaScript 虚拟机中引入了 JIT 机制，所以目前市面上 JavaScript 虚拟机都有着类似的架构。另外，V8 也是早于其他虚拟机引入了惰性编译、内联缓存、隐藏类等机制，进一步优化了 JavaScript 代码的编译执行效率。</p></li><li><p>V8 执行一段 JavaScript 的流程图：<br><img src="https://greenhaha.oss-cn-beijing.aliyuncs.com/frontend/assets/img/v8javascript.jpeg" alt="V8 执行一段 JavaScript"></p><blockquote><p><a href="https://time.geekbang.org/column/article/211682">V8 是如何执行一段 JavaScript 代码的？</a></p></blockquote></li><li><p>V8 本质上是一个虚拟机，因为计算机只能识别二进制指令，所以要让计算机执行一段高级语言通常有两种手段：</p><ul><li>第一种是将高级代码转换为二进制代码，再让计算机去执行；</li><li>另外一种方式是在计算机安装一个解释器，并由解释器来解释执行。</li></ul></li><li><p>解释执行和编译执行都有各自的优缺点，解释执行启动速度快，但是执行时速度慢，而编译执行启动速度慢，但是执行速度快。为了充分地利用解释执行和编译执行的优点，规避其缺点，V8 采用了一种权衡策略，在启动过程中采用了解释执行的策略，但是如果某段代码的执行频率超过一个值，那么 V8 就会采用优化编译器将其编译成执行效率更加高效的机器代码。</p></li></ul><p>总结来说V8 执行一段 JavaScript 代码所经历的主要流程包括：</p><ul><li>初始化基础环境；</li><li>解析源码生成 AST 和作用域；</li><li>依据 AST 和作用域生成字节码；</li><li>解释执行字节码；</li><li>监听热点代码；</li><li>优化热点代码为二进制的机器代码；</li><li>反优化生成的二进制机器代码。</li></ul><h3 id="一等公民与闭包"><a href="#一等公民与闭包" class="headerlink" title="一等公民与闭包"></a>一等公民与闭包</h3><p>一等公民的定义： </p><ul><li>在编程语言中，一等公民可以作为函数参数，可以作为函数返回值，也可以赋值给变量。</li><li>如果某个编程语言的函数，可以和这个语言的数据类型做一样的事情，我们就把这个语言中的函数称为一等公民。</li><li>对于 JavaScript 来说，函数可以赋值给变量，也可以作为函数参数，还可以作为函数返回值，因此 JavaScript 中函数是一等公民。</li></ul><p>动态作用域与静态作用域</p><ul><li>如果一门语言的作用域是静态作用域，那么符号之间的引用关系能够根据程序代码在编译时就确定清楚，在运行时不会变。某个函数是在哪声明的，就具有它所在位置的作用域。它能够访问哪些变量，那么就跟这些变量绑定了，在运行时就一直能访问这些变量。即静态作用域可以由程序代码决定，在编译时就能完全确定。大多数语言都是静态作用域的。</li><li>动态作用域（Dynamic Scope）。也就是说，变量引用跟变量声明不是在编译时就绑定死了的。在运行时，它是在运行环境中动态地找一个相同名称的变量。在 macOS 或 Linux 中用的 bash 脚本语言，就是动态作用域的。</li></ul><p>闭包的三个基础特性：</p><ul><li>JavaScript 语言允许在函数内部定义新的函数</li><li>可以在内部函数中访问父函数中定义的变量</li><li>因为 JavaScript 中的函数是一等公民，所以函数可以作为另外一个函数的返回值</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 闭包（静态作用域，一等公民，调用栈的矛盾体）</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> d = <span class="number">20</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">inner</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> c = a + b + d;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> f = foo();</span><br></pre></td></tr></table></figure><blockquote><p>参考资料： <a href="https://segmentfault.com/a/1190000021586767">闭包</a></p></blockquote><p>惰性解析：<br>所谓惰性解析是指解析器在解析的过程中，如果遇到函数声明，那么会跳过函数内部的代码，并不会为其生成 AST 和字节码，而仅仅生成顶层代码的 AST 和字节码。</p><ul><li>在编译 JavaScript 代码的过程中，V8 并不会一次性将所有的 JavaScript 解析为中间代码，这主要是基于以下两点：<ul><li>首先，如果一次解析和编译所有的 JavaScript 代码，过多的代码会增加编译时间，这会严重影响到首次执行 JavaScript 代码的速度，让用户感觉到卡顿。因为有时候一个页面的 JavaScript 代码很大，如果要将所有的代码一次性解析编译完成，那么会大大增加用户的等待时间；</li><li>其次，解析完成的字节码和编译之后的机器代码都会存放在内存中，如果一次性解析和编译所有 JavaScript 代码，那么这些中间代码和机器代码将会一直占用内存。</li></ul></li><li>基于以上的原因，所有主流的 JavaScript 虚拟机都实现了惰性解析。</li><li>闭包给惰性解析带来的问题：上文的 d 不能随着 foo 函数的执行上下文被销毁掉。</li></ul><p>预解析器：<br>V8 引入预解析器，比如当解析顶层代码的时候，遇到了一个函数，那么预解析器并不会直接跳过该函数，而是对该函数做一次快速的预解析。</p><ul><li>判断当前函数是不是存在一些语法上的错误，发现了语法错误，那么就会向 V8 抛出语法错误；</li><li>检查函数内部是否引用了外部变量，如果引用了外部的变量，预解析器会将栈中的变量复制到堆中，在下次执行到该函数的时候，直接使用堆中的引用，这样就解决了闭包所带来的问题。</li></ul><h3 id="V8-内部是如何存储对象的：快属性和慢属性"><a href="#V8-内部是如何存储对象的：快属性和慢属性" class="headerlink" title="V8 内部是如何存储对象的：快属性和慢属性"></a>V8 内部是如何存储对象的：快属性和慢属性</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// test.js</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>[<span class="number">200</span>] = <span class="string">&#x27;test-200&#x27;</span>;</span><br><span class="line">  <span class="built_in">this</span>[<span class="number">1</span>] = <span class="string">&#x27;test-1&#x27;</span>;</span><br><span class="line">  <span class="built_in">this</span>[<span class="number">100</span>] = <span class="string">&#x27;test-100&#x27;</span>;</span><br><span class="line">  <span class="built_in">this</span>[<span class="string">&#x27;B&#x27;</span>] = <span class="string">&#x27;bar-B&#x27;</span>;</span><br><span class="line">  <span class="built_in">this</span>[<span class="number">50</span>] = <span class="string">&#x27;test-50&#x27;</span>;</span><br><span class="line">  <span class="built_in">this</span>[<span class="number">9</span>] = <span class="string">&#x27;test-9&#x27;</span>;</span><br><span class="line">  <span class="built_in">this</span>[<span class="number">8</span>] = <span class="string">&#x27;test-8&#x27;</span>;</span><br><span class="line">  <span class="built_in">this</span>[<span class="number">3</span>] = <span class="string">&#x27;test-3&#x27;</span>;</span><br><span class="line">  <span class="built_in">this</span>[<span class="number">5</span>] = <span class="string">&#x27;test-5&#x27;</span>;</span><br><span class="line">  <span class="built_in">this</span>[<span class="string">&#x27;D&#x27;</span>] = <span class="string">&#x27;bar-D&#x27;</span>;</span><br><span class="line">  <span class="built_in">this</span>[<span class="string">&#x27;C&#x27;</span>] = <span class="string">&#x27;bar-C&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> bar = <span class="keyword">new</span> Foo();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (key <span class="keyword">in</span> bar) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`index:<span class="subst">$&#123;key&#125;</span>  value:<span class="subst">$&#123;bar[key]&#125;</span>`</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出：</span></span><br><span class="line"><span class="comment">// index:1  value:test-1</span></span><br><span class="line"><span class="comment">// index:3  value:test-3</span></span><br><span class="line"><span class="comment">// index:5  value:test-5</span></span><br><span class="line"><span class="comment">// index:8  value:test-8</span></span><br><span class="line"><span class="comment">// index:9  value:test-9</span></span><br><span class="line"><span class="comment">// index:50  value:test-50</span></span><br><span class="line"><span class="comment">// index:100  value:test-100</span></span><br><span class="line"><span class="comment">// index:200  value:test-200</span></span><br><span class="line"><span class="comment">// index:B  value:bar-B</span></span><br><span class="line"><span class="comment">// index:D  value:bar-D</span></span><br><span class="line"><span class="comment">// index:C  value:bar-C</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在 ECMAScript 规范中定义了数字属性应该按照索引值大小升序排列，字符串属性根据创建时的顺序升序排列。在这里我们把对象中的数字属性称为排序属性，在 V8 中被称为 elements，字符串属性就被称为常规属性，在 V8 中被称为 properties。在 V8 内部，为了有效地提升存储和访问这两种属性的性能，分别使用了两个线性数据结构来分别保存排序属性和常规属性。同时 v8 将部分常规属性直接存储到对象本身，我们把这称为对象内属性 (in-object properties)，不过对象内属性的数量是固定的，默认是 10 个。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params">property_num, element_num</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//添加可索引属性</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; element_num; i++) &#123;</span><br><span class="line">    <span class="built_in">this</span>[i] = <span class="string">`element<span class="subst">$&#123;i&#125;</span>`</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//添加常规属性</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; property_num; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> ppt = <span class="string">`property<span class="subst">$&#123;i&#125;</span>`</span>;</span><br><span class="line">    <span class="built_in">this</span>[ppt] = ppt;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> bar = <span class="keyword">new</span> Foo(<span class="number">10</span>, <span class="number">10</span>);</span><br></pre></td></tr></table></figure><p>可以通过 Chrome 开发者工具的 Memory 标签，捕获查看当前的内存快照。通过增大第一个参数来查看存储变化。（Console面板运行以上代码，打开Memory面板，通过点击<code>Take heap snapshot</code>记录内存快照，点击快照，筛选出Foo进行查看。可参考使用 <a href="https://zhuanlan.zhihu.com/p/80792297">chrome-devtools Memory</a> 面板了解Memory面板。）</p><p>  我们将保存在线性数据结构中的属性称之为“快属性”，因为线性数据结构中只需要通过索引即可以访问到属性，虽然访问线性结构的速度快，但是如果从线性结构中添加或者删除大量的属性时，则执行效率会非常低，这主要因为会产生大量时间和内存开销。因此，如果一个对象的属性过多时，V8 就会采取另外一种存储策略，那就是“慢属性”策略，但慢属性的对象内部会有独立的非线性数据结构 (字典) 作为属性存储容器。所有的属性元信息不再是线性存储的，而是直接保存在属性字典中。</p><p>v8 属性存储：<br><img src="https://greenhaha.oss-cn-beijing.aliyuncs.com/frontend/assets/img/properties.jpeg" alt="v8 属性"></p><p>总结：</p><p>  因为 JavaScript 中的对象是由一组组属性和值组成的，所以最简单的方式是使用一个字典来保存属性和值，但是由于字典是非线性结构，所以如果使用字典，读取效率会大大降低。为了提升查找效率，V8 在对象中添加了两个隐藏属性，排序属性和常规属性，element 属性指向了 elements 对象，在 elements 对象中，会按照顺序存放排序属性。properties 属性则指向了 properties 对象，在 properties 对象中，会按照创建时的顺序保存常规属性。</p><p>  通过引入这两个属性，加速了 V8 查找属性的速度，为了更加进一步提升查找效率，V8 还实现了内置内属性的策略，当常规属性少于一定数量时，V8 就会将这些常规属性直接写进对象中，这样又节省了一个中间步骤。</p><p>  但是如果对象中的属性过多时，或者存在反复添加或者删除属性的操作，那么 V8 就会将线性的存储模式降级为非线性的字典存储模式，这样虽然降低了查找速度，但是却提升了修改对象的属性的速度。</p><blockquote><p>参考资料： <a href="https://time.geekbang.org/column/article/213250">快属性与慢属性：V8 是如何提升对象访问速度的？</a></p></blockquote><h2 id="堆空间和栈空间"><a href="#堆空间和栈空间" class="headerlink" title="堆空间和栈空间"></a>堆空间和栈空间</h2><p>栈空间</p><ul><li>现代语言都是基于函数的，每个函数在执行过程中，都有自己的生命周期和作用域，当函数执行结束时，其作用域也会被销毁，因此，我们会使用栈这种数据结构来管理函数的调用过程，我们也把管理函数调用过程的栈结构称之为调用栈。</li><li>栈空间主要是用来管理 JavaScript 函数调用的，栈是内存中连续的一块空间，同时栈结构是“先进后出”的策略。在函数调用过程中，涉及到上下文相关的内容都会存放在栈上，比如原生类型、引用到的对象的地址、函数的执行状态、this 值等都会存在在栈上。当一个函数执行结束，那么该函数的执行上下文便会被销毁掉。</li><li>栈空间的最大的特点是空间连续，所以在栈中每个元素的地址都是固定的，因此栈空间的查找效率非常高，但是通常在内存中，很难分配到一块很大的连续空间，因此，V8 对栈空间的大小做了限制，如果函数调用层过深，那么 V8 就有可能抛出栈溢出的错误。</li><li>栈的优势和缺点：<ul><li>栈的结构非常适合函数调用过程。</li><li>在栈上分配资源和销毁资源的速度非常快，这主要归结于栈空间是连续的，分配空间和销毁空间只需要移动下指针就可以了。</li><li>虽然操作速度非常快，但是栈也是有缺点的，其中最大的缺点也是它的优点所造成的，那就是栈是连续的，所以要想在内存中分配一块连续的大空间是非常难的，因此栈空间是有限的。</li></ul></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (n === <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> n * factorial(n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(factorial(<span class="number">50000</span>));</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>堆空间</p><ul><li>堆空间是一种树形的存储结构，用来存储对象类型的离散的数据，JavaScript 中除了原生类型的数据，其他的都是对象类型，诸如函数、数组，在浏览器中还有 window 对象、document 对象等，这些都是存在堆空间的。</li><li>宿主在启动 V8 的过程中，会同时创建堆空间和栈空间，再继续往下执行，产生的新数据都会存放在这两个空间中。</li></ul><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>继承就是一个对象可以访问另外一个对象中的属性和方法，在 JavaScript 中，我们通过原型和原型链的方式来实现了继承特性。</p><p>  JavaScript 的每个对象都包含了一个隐藏属性 <code>__proto__ </code>，我们就把该隐藏属性 <code>__proto__</code> 称之为该对象的原型 (prototype)，<code>__proto__ </code>指向了内存中的另外一个对象，我们就把 <code>__proto__</code> 指向的对象称为该对象的原型对象，那么该对象就可以直接访问其原型对象的方法或者属性。</p><p>  JavaScript 中的继承非常简洁，就是每个对象都有一个原型属性，该属性指向了原型对象，查找属性的时候，JavaScript 虚拟机会沿着原型一层一层向上查找，直至找到正确的属性。</p><p>隐藏属性<code>__proto__</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> animal = &#123;</span><br><span class="line">  <span class="attr">type</span>: <span class="string">&#x27;Default&#x27;</span>,</span><br><span class="line">  <span class="attr">color</span>: <span class="string">&#x27;Default&#x27;</span>,</span><br><span class="line">  <span class="attr">getInfo</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`Type is: <span class="subst">$&#123;<span class="built_in">this</span>.type&#125;</span>，color is <span class="subst">$&#123;<span class="built_in">this</span>.color&#125;</span>.`</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> dog = &#123;</span><br><span class="line">  <span class="attr">type</span>: <span class="string">&#x27;Dog&#x27;</span>,</span><br><span class="line">  <span class="attr">color</span>: <span class="string">&#x27;Black&#x27;</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>利用<code>__proto__</code>实现继承：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dog.__proto__ = animal;</span><br><span class="line">dog.getInfo();</span><br></pre></td></tr></table></figure><p>通常隐藏属性是不能使用 JavaScript 来直接与之交互的。虽然现代浏览器都开了一个口子，让 JavaScript 可以访问隐藏属性 <code>__proto__</code>，但是在实际项目中，我们不应该直接通过 <code>__proto__</code> 来访问或者修改该属性，其主要原因有两个：</p><p>首先，这是隐藏属性，并不是标准定义的;<br>其次，使用该属性会造成严重的性能问题。因为 JavaScript 通过隐藏类优化了很多原有的对象结构，所以通过直接修改<code>__proto__</code>会直接破坏现有已经优化的结构，触发 V8 重构该对象的隐藏类！</p><h4 id="构造函数是怎么创建对象的？"><a href="#构造函数是怎么创建对象的？" class="headerlink" title="构造函数是怎么创建对象的？"></a>构造函数是怎么创建对象的？</h4><p>  在 JavaScript 中，使用 new 加上构造函数的这种组合来创建对象和实现对象的继承。不过使用这种方式隐含的语义过于隐晦。其实是 JavaScript 为了吸引 Java 程序员、在语法层面去蹭 Java 热点，所以就被硬生生地强制加入了非常不协调的关键字 new。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">DogFactory</span>(<span class="params">type, color</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.type = type;</span><br><span class="line">  <span class="built_in">this</span>.color = color;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> dog = <span class="keyword">new</span> DogFactory(<span class="string">&#x27;Dog&#x27;</span>, <span class="string">&#x27;Black&#x27;</span>);</span><br></pre></td></tr></table></figure><p>其实当 V8 执行上面这段代码时，V8 在背后悄悄地做了以下几件事情：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> dog = &#123;&#125;;</span><br><span class="line">dog.__proto__ = DogFactory.prototype;</span><br><span class="line">DogFactory.call(dog, <span class="string">&#x27;Dog&#x27;</span>, <span class="string">&#x27;Black&#x27;</span>);</span><br></pre></td></tr></table></figure><h3 id="机器码、字节码"><a href="#机器码、字节码" class="headerlink" title="机器码、字节码"></a>机器码、字节码</h3><p>V8 为什么要引入字节码</p><ul><li><p>早期的 V8 为了提升代码的执行速度，直接将 JavaScript 源代码编译成了没有优化的二进制机器代码，如果某一段二进制代码执行频率过高，那么 V8 会将其标记为热点代码，热点代码会被优化编译器优化，优化后的机器代码执行效率更高。</p></li><li><p>随着移动设备的普及，V8 团队逐渐发现将 JavaScript 源码直接编译成二进制代码存在两个致命的问题：</p><ul><li>时间问题：编译时间过久，影响代码启动速度；</li><li>空间问题：缓存编译后的二进制代码占用更多的内存。</li></ul></li><li><p>这两个问题无疑会阻碍 V8 在移动设备上的普及，于是 V8 团队大规模重构代码，引入了中间的字节码。字节码的优势有如下三点：</p><ul><li>解决启动问题：生成字节码的时间很短；</li><li>解决空间问题：字节码虽然占用的空间比原始的 JavaScript 多，但是相较于机器代码，字节码还是小了太多，缓存字节码会大大降低内存的使用。</li><li>代码架构清晰：采用字节码，可以简化程序的复杂度，使得 V8 移植到不同的 CPU 架构平台更加容易。</li></ul></li><li><p>Bytecode 某种程度上就是汇编语言，只是它没有对应特定的 CPU，或者说它对应的是虚拟的 CPU。这样的话，生成 Bytecode 时简单很多，无需为不同的 CPU 生产不同的代码。要知道，V8 支持 9 种不同的 CPU，引入一个中间层 Bytecode，可以简化 V8 的编译流程，提高可扩展性。</p></li><li><p>如果我们在不同硬件上去生成 Bytecode，会发现生成代码的指令是一样的。</p></li></ul><p>如何查看字节码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// test.js</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> z = x + y;</span><br><span class="line">  <span class="keyword">return</span> z;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="number">1</span>, <span class="number">2</span>));</span><br></pre></td></tr></table></figure><p>运行<code>./d8 ./test.js --print-bytecode</code>:</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[generated bytecode <span class="keyword">for</span> function: add (<span class="number">0</span>x01000824fe59 &lt;SharedFunctionInfo add&gt;)]</span><br><span class="line">Parameter count <span class="number">3</span> #三个参数，包括了显式地传入的 x 和 y，还有一个隐式地传入的 this</span><br><span class="line">Register count <span class="number">1</span></span><br><span class="line">Frame size <span class="number">8</span></span><br><span class="line">         <span class="number">0</span>x10008250026 @    <span class="number">0</span> : <span class="number">25</span> <span class="number">02</span>             Ldar a1 #将a1寄存器中的值加载到累加器中，LoaD Accumulator from Register</span><br><span class="line">         <span class="number">0</span>x10008250028 @    <span class="number">2</span> : <span class="number">34</span> <span class="number">03</span> <span class="number">00</span>          Add a0, [<span class="number">0</span>]</span><br><span class="line">         <span class="number">0</span>x1000825002b @    <span class="number">5</span> : <span class="number">26</span> fb             Star r0 #Store Accumulator to Register，把累加器中的值保存到r0寄存器中</span><br><span class="line">         <span class="number">0</span>x1000825002d @    <span class="number">7</span> : aa                Return  #结束当前函数的执行，并将控制权传回给调用方</span><br><span class="line">Constant pool (size = <span class="number">0</span>)</span><br><span class="line">Handler Table (size = <span class="number">0</span>)</span><br><span class="line">Source Position Table (size = <span class="number">0</span>)</span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure><h5 id="常用字节码指令"><a href="#常用字节码指令" class="headerlink" title="常用字节码指令:"></a>常用字节码指令:</h5><ul><li><p>Ldar：表示将寄存器中的值加载到累加器中，你可以把它理解为 LoaD Accumulator from Register，就是把某个寄存器中的值，加载到累加器中。</p></li><li><p>Star：表示 Store Accumulator Register， 你可以把它理解为 Store Accumulator to Register，就是把累加器中的值保存到某个寄存器中</p></li><li><p>Add：Add a0, [0]是从 a0 寄存器加载值并将其与累加器中的值相加，然后将结果再次放入累加器。</p><blockquote><p>add a0 后面的[0]称之为 feedback vector slot，又叫反馈向量槽，它是一个数组，解释器将解释执行过程中的一些数据类型的分析信息都保存在这个反馈向量槽中了，目的是为了给 TurboFan 优化编译器提供优化信息，很多字节码都会为反馈向量槽提供运行时信息。</p></blockquote></li><li><p>LdaSmi：将小整数（Smi）加载到累加器寄存器中</p></li><li><p>Return：结束当前函数的执行，并将控制权传回给调用方。返回的值是累加器中的值。<br><img src="https://greenhaha.oss-cn-beijing.aliyuncs.com/frontend/assets/img/bytecode-ignition.jpeg" alt="bytecode-ignition"></p><blockquote><p><a href="https://github.com/v8/v8/blob/master/src/interpreter/bytecodes.h">V8 中的字节码指令集</a> | <a href="https://zhuanlan.zhihu.com/p/28590489">理解 V8 的字节码「译」</a></p></blockquote></li></ul><h3 id="隐藏类和内联缓存"><a href="#隐藏类和内联缓存" class="headerlink" title="隐藏类和内联缓存"></a>隐藏类和内联缓存</h3><p>JavaScript 是一门动态语言，其执行效率要低于静态语言，V8 为了提升 JavaScript 的执行速度，借鉴了很多静态语言的特性，比如实现了 JIT 机制，为了提升对象的属性访问速度而引入了隐藏类，为了加速运算而引入了内联缓存。</p><p>将静态的特性引入到 V8</p><ul><li>V8 采用的一个思路就是将 JavaScript 中的对象静态化，也就是 V8 在运行 JavaScript 的过程中，会假设 JavaScript 中的对象是静态的。</li><li>具体地讲，V8 对每个对象做如下两点假设：<ul><li>对象创建好了之后就不会添加新的属性；</li><li>对象创建好了之后也不会删除属性。</li></ul></li><li>符合这两个假设之后，V8 就可以对 JavaScript 中的对象做深度优化了。V8 会为每个对象创建一个隐藏类，对象的隐藏类中记录了该对象一些基础的布局信息，包括以下两点：<ul><li>对象中所包含的所有的属性；</li><li>每个属性相对于对象的偏移量。</li></ul></li><li>有了隐藏类之后，那么当 V8 访问某个对象中的某个属性时，就会先去隐藏类中查找该属性相对于它的对象的偏移量，有了偏移量和属性类型，V8 就可以直接去内存中取出对应的属性值，而不需要经历一系列的查找过程，那么这就大大提升了 V8 查找对象的效率。</li><li>在 V8 中，把隐藏类又称为 map，每个对象都有一个 map 属性，其值指向内存中的隐藏类；</li><li>map 描述了对象的内存布局，比如对象都包括了哪些属性，这些数据对应于对象的偏移量是多少。<blockquote><p>为什么静态语言的效率更高?<br>  静态语言中，如 C++ 在声明一个对象之前需要定义该对象的结构，代码在执行之前需要先被编译，编译的时候，每个对象的形状都是固定的，也就是说，在代码的执行过程中是无法被改变的。可以直接通过偏移量查询来查询对象的属性值，这也就是静态语言的执行效率高的一个原因。<br>  JavaScript 在运行时，对象的属性是可以被修改的，所以当 V8 使用了一个对象时，比如使用了 obj.x 的时候，它并不知道该对象中是否有 x，也不知道 x 相对于对象的偏移量是多少，也就是说 V8 并不知道该对象的具体的形状。那么，当在 JavaScript 中要查询对象 obj 中的 x 属性时，V8 会按照具体的规则一步一步来查询，这个过程非常的慢且耗时。</p></blockquote></li></ul><h5 id="多个对象共用一个隐藏类"><a href="#多个对象共用一个隐藏类" class="headerlink" title="多个对象共用一个隐藏类"></a>多个对象共用一个隐藏类</h5><ul><li>在 V8 中，每个对象都有一个 map 属性，该属性值指向该对象的隐藏类。不过如果两个对象的形状是相同的，V8 就会为其复用同一个隐藏类，这样有两个好处：<ul><li>减少隐藏类的创建次数，也间接加速了代码的执行速度；</li><li>减少了隐藏类的存储空间。</li></ul></li><li>那么，什么情况下两个对象的形状是相同的，要满足以下两点：<ul><li>相同的属性名称；</li><li>相等的属性个数。<h5 id="重新构建隐藏类"><a href="#重新构建隐藏类" class="headerlink" title="重新构建隐藏类"></a>重新构建隐藏类</h5></li></ul></li><li>给一个对象添加新的属性，删除新的属性，或者改变某个属性的数据类型都会改变这个对象的形状，那么势必也就会触发 V8 为改变形状后的对象重建新的隐藏类。</li><li>每次给对象添加了一个新属性之后，该对象的隐藏类的地址都会改变，这也就意味着隐藏类也随着改变了；如果删除对象的某个属性，那么对象的形状也就随着发生了改变，这时 V8 也会重建该对象的隐藏类；</li><li>最佳实践<ul><li>使用字面量初始化对象时，要保证属性的顺序是一致的；</li><li>尽量使用字面量一次性初始化完整对象属性；</li><li>尽量避免使用 delete 方法。</li></ul></li></ul><h5 id="通过内联缓存来提升函数执行效率"><a href="#通过内联缓存来提升函数执行效率" class="headerlink" title="通过内联缓存来提升函数执行效率"></a>通过内联缓存来提升函数执行效率</h5><p>  虽然隐藏类能够加速查找对象的速度，但是在 V8 查找对象属性值的过程中，依然有查找对象的隐藏类和根据隐藏类来查找对象属性值的过程。如果一个函数中利用了对象的属性，并且这个函数会被多次执行：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loadX</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> obj.x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="number">3</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> obj1 = &#123; <span class="attr">x</span>: <span class="number">3</span>, <span class="attr">y</span>: <span class="number">6</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> obj2 = &#123; <span class="attr">x</span>: <span class="number">3</span>, <span class="attr">y</span>: <span class="number">6</span>, <span class="attr">z</span>: <span class="number">8</span> &#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">90000</span>; i++) &#123;</span><br><span class="line">  <span class="comment">// 对比时间差异</span></span><br><span class="line">  <span class="built_in">console</span>.time(<span class="string">`---<span class="subst">$&#123;i&#125;</span>----`</span>)</span><br><span class="line">  loadX(obj);</span><br><span class="line">  <span class="built_in">console</span>.timeEnd(<span class="string">`---<span class="subst">$&#123;i&#125;</span>----`</span>)</span><br><span class="line">  loadX(obj1);</span><br><span class="line">  <span class="comment">// 产生多态</span></span><br><span class="line">  loadX(obj2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="通常-V8-获取-obj-x-的流程："><a href="#通常-V8-获取-obj-x-的流程：" class="headerlink" title="通常 V8 获取 obj.x 的流程："></a>通常 V8 获取 obj.x 的流程：</h5><ul><li>找对象 obj 的隐藏类；</li><li>再通过隐藏类查找 x 属性偏移量；</li><li>然后根据偏移量获取属性值，在这段代码中 loadX 函数会被反复执行，那么获取 obj.x 的流程也需要反复被执行；</li></ul><h5 id="内联缓存及其原理："><a href="#内联缓存及其原理：" class="headerlink" title="内联缓存及其原理："></a>内联缓存及其原理：</h5><ul><li>函数 loadX 在一个 for 循环里面被重复执行了很多次，因此 V8 会想尽一切办法来压缩这个查找过程，以提升对象的查找效率。这个加速函数执行的策略就是内联缓存 (Inline Cache)，简称为 IC；</li><li>IC 的原理：在 V8 执行函数的过程中，会观察函数中一些调用点 (CallSite) 上的关键中间数据，然后将这些数据缓存起来，当下次再次执行该函数的时候，V8 就可以直接利用这些中间数据，节省了再次获取这些数据的过程，因此 V8 利用 IC，可以有效提升一些重复代码的执行效率。</li><li>IC 会为每个函数维护一个反馈向量 (FeedBack Vector)，反馈向量记录了函数在执行过程中的一些关键的中间数据。</li><li>反馈向量其实就是一个表结构，它由很多项组成的，每一项称为一个插槽 (Slot)，V8 会依次将执行 loadX 函数的中间数据写入到反馈向量的插槽中。</li><li>当 V8 再次调用 loadX 函数时，比如执行到 loadX 函数中的 return obj.x 语句时，它就会在对应的插槽中查找 x 属性的偏移量，之后 V8 就能直接去内存中获取 obj.x 的属性值了。这样就大大提升了 V8 的执行效率。</li></ul><h5 id="单态、多态和超态："><a href="#单态、多态和超态：" class="headerlink" title="单态、多态和超态："></a>单态、多态和超态：</h5><ul><li>如果一个插槽中只包含 1 个隐藏类，那么我们称这种状态为单态 (monomorphic)；</li><li>如果一个插槽中包含了 2 ～ 4 个隐藏类，那我们称这种状态为多态 (polymorphic)；</li><li>如果一个插槽中超过 4 个隐藏类，那我们称这种状态为超态 (magamorphic)。</li><li>单态的性能优于多态和超态，所以我们需要稍微避免多态和超态的情况。要避免多态和超态，那么就尽量默认所有的对象属性是不变的，比如你写了一个 loadX(obj) 的函数，那么当传递参数时，尽量不要使用多个不同形状的 obj 对象。<h5 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h5>  V8 引入了内联缓存（IC），IC 会监听每个函数的执行过程，并在一些关键的地方埋下监听点，这些包括了加载对象属性 (Load)、给对象属性赋值 (Store)、还有函数调用 (Call)，V8 会将监听到的数据写入一个称为反馈向量 (FeedBack Vector) 的结构中，同时 V8 会为每个执行的函数维护一个反馈向量。有了反馈向量缓存的临时数据，V8 就可以缩短对象属性的查找路径，从而提升执行效率。但是针对函数中的同一段代码，如果对象的隐藏类是不同的，那么反馈向量也会记录这些不同的隐藏类，这就出现了多态和超态的情况。我们在实际项目中，要尽量避免出现多态或者超态的情况。</li></ul><h3 id="异步编程与消息队列"><a href="#异步编程与消息队列" class="headerlink" title="异步编程与消息队列"></a>异步编程与消息队列</h3><h4 id="V8-是如何执行回调函数的"><a href="#V8-是如何执行回调函数的" class="headerlink" title="V8 是如何执行回调函数的"></a>V8 是如何执行回调函数的</h4><p>回调函数有两种类型：同步回调和异步回调，同步回调函数是在执行函数内部被执行的，而异步回调函数是在执行函数外部被执行的。<br>通用 UI 线程宏观架构：<br><img src="https://greenhaha.oss-cn-beijing.aliyuncs.com/frontend/assets/img/v8-ui.jpeg" alt="V8-ui"></p><p>UI 线程提供一个消息队列，并将待执行的事件添加到消息队列中，然后 UI 线程会不断循环地从消息队列中取出事件、执行事件。关于异步回调，这里也有两种不同的类型，其典型代表是 setTimeout 和 XMLHttpRequest：</p><ul><li>setTimeout 的执行流程其实是比较简单的，在 setTimeout 函数内部封装回调消息，并将回调消息添加进消息队列，然后主线程从消息队列中取出回调事件，并执行回调函数。</li><li>XMLHttpRequest 稍微复杂一点，因为下载过程需要放到单独的一个线程中去执行，所以执行 XMLHttpRequest.send 的时候，宿主会将实际请求转发给网络线程，然后 send 函数退出，主线程继续执行下面的任务。网络线程在执行下载的过程中，会将一些中间信息和回调函数封装成新的消息，并将其添加进消息队列中，然后主线程从消息队列中取出回调事件，并执行回调函数。</li></ul><h4 id="宏任务和微任务"><a href="#宏任务和微任务" class="headerlink" title="宏任务和微任务"></a>宏任务和微任务</h4><ul><li>调用栈：调用栈是一种数据结构，用来管理在主线程上执行的函数的调用关系。主线程在执行任务的过程中，如果函数的调用层次过深，可能造成栈溢出的错误，我们可以使用 setTimeout 来解决栈溢出的问题。setTimeout 的本质是将同步函数调用改成异步函数调用，这里的异步调用是将回调函数封装成宏任务，并将其添加进消息队列中，然后主线程再按照一定规则循环地从消息队列中读取下一个宏任务。</li><li>宏任务：就是指消息队列中的等待被主线程执行的事件。每个宏任务在执行时，V8 都会重新创建栈，然后随着宏任务中函数调用，栈也随之变化，最终，当该宏任务执行结束时，整个栈又会被清空，接着主线程继续执行下一个宏任务。</li><li>微任务：你可以把微任务看成是一个需要异步执行的函数，执行时机是在主函数执行结束之后、当前宏任务结束之前。</li><li>JavaScript 中之所以要引入微任务，主要是由于主线程执行消息队列中宏任务的时间颗粒度太粗了，无法胜任一些对精度和实时性要求较高的场景，微任务可以在实时性和效率之间做一个有效的权衡。另外使用微任务，可以改变我们现在的异步编程模型，使得我们可以使用同步形式的代码来编写异步调用。</li><li>微任务是基于消息队列、事件循环、UI 主线程还有堆栈而来的，然后基于微任务，又可以延伸出协程、Promise、Generator、await/async 等现代前端经常使用的一些技术。<br><img src="https://greenhaha.oss-cn-beijing.aliyuncs.com/frontend/assets/img/microtask.jpeg" alt="microtask"><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不会使浏览器卡死</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(foo, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">foo();</span><br></pre></td></tr></table></figure><img src="https://greenhaha.oss-cn-beijing.aliyuncs.com/frontend/assets/img/stack.jpeg" alt="stack"><br>微任务：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 浏览器console控制台可使浏览器卡死（无法响应鼠标事件等）</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve().then(foo);</span><br><span class="line">&#125;</span><br><span class="line">foo();</span><br></pre></td></tr></table></figure></li><li>如果当前的任务中产生了一个微任务，通过 Promise.resolve() 或者 Promise.reject() 都会触发微任务，触发的微任务不会在当前的函数中被执行，所以执行微任务时，不会导致栈的无限扩张；</li><li>和异步调用不同，微任务依然会在当前任务执行结束之前被执行，这也就意味着在当前微任务执行结束之前，消息队列中的其他任务是不可能被执行的。因此在函数内部触发的微任务，一定比在函数内部触发的宏任务要优先执行。</li><li>微任务依然是在当前的任务中执行的，所以如果在微任务中循环触发新的微任务，那么将导致消息队列中的其他任务没有机会被执行。</li></ul><p>前端异步编程方案史<br><img src="https://greenhaha.oss-cn-beijing.aliyuncs.com/frontend/assets/img/async.jpeg" alt="async"></p><ul><li>Callback 模式的异步编程模型需要实现大量的回调函数，大量的回调函数会打乱代码的正常逻辑，使得代码变得不线性、不易阅读，这就是我们所说的回调地狱问题。</li><li>Promise 能很好地解决回调地狱的问题，我们可以按照线性的思路来编写代码，这个过程是线性的，非常符合人的直觉。</li><li>但是这种方式充满了 Promise 的 then() 方法，如果处理流程比较复杂的话，那么整段代码将充斥着大量的 then，语义化不明显，代码不能很好地表示执行流程。我们想要通过线性的方式来编写异步代码，要实现这个理想，最关键的是要能实现函数暂停和恢复执行的功能。而生成器就可以实现函数暂停和恢复，我们可以在生成器中使用同步代码的逻辑来异步代码 (实现该逻辑的核心是协程)。</li><li>但是在生成器之外，我们还需要一个触发器来驱动生成器的执行。前端的最终方案就是 async/await，async 是一个可以暂停和恢复执行的函数，在 async 函数内部使用 await 来暂停 async 函数的执行，await 等待的是一个 Promise 对象，如果 Promise 的状态变成 resolve 或者 reject，那么 async 函数会恢复执行。因此，使用 async/await 可以实现以同步的方式编写异步代码这一目标。和生成器函数一样，使用了 async 声明的函数在执行时，也是一个单独的协程，我们可以使用 await 来暂停该协程，由于 await 等待的是一个 Promise 对象，我们可以 resolve 来恢复该协程。</li></ul><blockquote><p>协程是一种比线程更加轻量级的存在。你可以把协程看成是跑在线程上的任务，一个线程上可以存在多个协程，但是在线程上同时只能执行一个协程。比如，当前执行的是 A 协程，要启动 B 协程，那么 A 协程就需要将主线程的控制权交给 B 协程，这就体现在 A 协程暂停执行，B 协程恢复执行；同样，也可以从 B 协程中启动 A 协程。通常，如果从 A 协程启动 B 协程，我们就把 A 协程称为 B 协程的父协程。</p></blockquote><blockquote><p>正如一个进程可以拥有多个线程一样，一个线程也可以拥有多个协程。每一时刻，该线程只能执行其中某一个协程。最重要的是，协程不是被操作系统内核所管理，而完全是由程序所控制（也就是在用户态执行）。这样带来的好处就是性能得到了很大的提升，不会像线程切换那样消耗资源。</p></blockquote><blockquote><p>资料拓展：<a href="https://www.ruanyifeng.com/blog/2015/05/co.html">co 函数库的含义和用法</a></p></blockquote><h3 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h3><h6 id="垃圾数据"><a href="#垃圾数据" class="headerlink" title="垃圾数据"></a>垃圾数据</h6><p>  从“GC Roots”对象出发，遍历 GC Root 中的所有对象，如果通过 GC Roots 没有遍历到的对象，则这些对象便是垃圾数据。V8 会有专门的垃圾回收器来回收这些垃圾数据。</p><h6 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h6><p>垃圾回收大致可以分为以下几个步骤：</p><ul><li><p>第一步，通过 GC Root 标记空间中活动对象和非活动对象。目前 V8 采用的可访问性（reachability）算法来判断堆中的对象是否是活动对象。具体地讲，这个算法是将一些 GC Root 作为初始存活的对象的集合，从 GC Roots 对象出发，遍历 GC Root 中的所有对象：</p><ul><li>通过 GC Root 遍历到的对象，我们就认为该对象是可访问的（reachable），那么必须保证这些对象应该在内存中保留，我们也称可访问的对象为活动对象；</li><li>通过 GC Roots 没有遍历到的对象，则是不可访问的（unreachable），那么这些不可访问的对象就可能被回收，我们称不可访问的对象为非活动对象。</li><li>在浏览器环境中，GC Root 有很多，通常包括了以下几种 (但是不止于这几种)：<ul><li>全局的 window 对象（位于每个 iframe 中）；</li><li>文档 DOM 树，由可以通过遍历文档到达的所有原生 DOM 节点组成；</li><li>存放栈上变量。</li></ul></li></ul></li><li><p>第二步，回收非活动对象所占据的内存。其实就是在所有的标记完成之后，统一清理内存中所有被标记为可回收的对象。</p></li><li><p>第三步，做内存整理。一般来说，频繁回收对象后，内存中就会存在大量不连续空间，我们把这些不连续的内存空间称为内存碎片。当内存中出现了大量的内存碎片之后，如果需要分配较大的连续内存时，就有可能出现内存不足的情况，所以最后一步需要整理这些内存碎片。但这步其实是可选的，因为有的垃圾回收器不会产生内存碎片(比如副垃圾回收器)。</p></li></ul><h4 id="垃圾回收-1"><a href="#垃圾回收-1" class="headerlink" title="垃圾回收"></a>垃圾回收</h4><ul><li><p>V8 依据代际假说，将堆内存划分为新生代和老生代两个区域，新生代中存放的是生存时间短的对象，老生代中存放生存时间久的对象。代际假说有两个特点：</p><ul><li>第一个是大部分对象都是“朝生夕死”的，也就是说大部分对象在内存中存活的时间很短，比如函数内部声明的变量，或者块级作用域中的变量，当函数或者代码块执行结束时，作用域中定义的变量就会被销毁。因此这一类对象一经分配内存，很快就变得不可访问；</li><li>第二个是不死的对象，会活得更久，比如全局的 window、DOM、Web API 等对象。</li></ul></li><li><p>为了提升垃圾回收的效率，V8 设置了两个垃圾回收器，主垃圾回收器和副垃圾回收器。</p><ul><li>主垃圾回收器负责收集老生代中的垃圾数据，副垃圾回收器负责收集新生代中的垃圾数据。</li><li>副垃圾回收器采用了 Scavenge 算法，是把新生代空间对半划分为两个区域（有些地方也称作 From 和 To 空间），一半是对象区域，一半是空闲区域。新的数据都分配在对象区域，等待对象区域快分配满的时候，垃圾回收器便执行垃圾回收操作，之后将存活的对象从对象区域拷贝到空闲区域，并将两个区域互换。<ul><li>这种角色翻转的操作还能让新生代中的这两块区域无限重复使用下去。</li><li>副垃圾回收器每次执行清理操作时，都需要将存活的对象从对象区域复制到空闲区域，复制操作需要时间成本，如果新生区空间设置得太大了，那么每次清理的时间就会过久，所以为了执行效率，一般新生区的空间会被设置得比较小。</li><li>副垃圾回收器还会采用对象晋升策略，也就是移动那些经过两次垃圾回收依然还存活的对象到老生代中。</li></ul></li><li>主垃圾回收器回收器主要负责老生代中的垃圾数据的回收操作，会经历标记、清除和整理过程。<ul><li>主垃圾回收器主要负责老生代中的垃圾回收。除了新生代中晋升的对象，一些大的对象会直接被分配到老生代里。</li><li>老生代中的对象有两个特点：一个是对象占用空间大；另一个是对象存活时间长。<h5 id="Stop-The-World"><a href="#Stop-The-World" class="headerlink" title="Stop-The-World"></a>Stop-The-World</h5>  由于 JavaScript 是运行在主线程之上的，因此，一旦执行垃圾回收算法，都需要将正在执行的 JavaScript 脚本暂停下来，待垃圾回收完毕后再恢复脚本执行。我们把这种行为叫做全停顿（Stop-The-World）。</li></ul></li></ul></li><li><p>V8 最开始的垃圾回收器有两个特点：</p><ul><li>第一个是垃圾回收在主线程上执行，</li><li>第二个特点是一次执行一个完整的垃圾回收流程。</li></ul></li><li><p>由于这两个原因，很容易造成主线程卡顿，所以 V8 采用了很多优化执行效率的方案。</p><ul><li><p>第一个方案是并行回收，在执行一个完整的垃圾回收过程中，垃圾回收器会使用多个辅助线程来并行执行垃圾回收。</p></li><li><p>第二个方案是增量式垃圾回收，垃圾回收器将标记工作分解为更小的块，并且穿插在主线程不同的任务之间执行。采用增量垃圾回收时，垃圾回收器没有必要一次执行完整的垃圾回收过程，每次执行的只是整个垃圾回收过程中的一小部分工作。</p></li><li><p>第三个方案是并发回收，回收线程在执行 JavaScript 的过程，辅助线程能够在后台完成的执行垃圾回收的操作。</p><blockquote><p>资料参考：<a href="https://www.oschina.net/translate/v8-javascript-engine">深入解读 V8 引擎的「并发标记」技术</a></p></blockquote></li><li><p>主垃圾回收器就综合采用了所有的方案（并发标记，增量标记，辅助清理），副垃圾回收器也采用了部分方案。</p></li></ul></li></ul>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;</summary>
        
      
    
    
    
    <category term="知识剖析" scheme="http://example.com/categories/%E7%9F%A5%E8%AF%86%E5%89%96%E6%9E%90/"/>
    
    
    <category term="Node" scheme="http://example.com/tags/Node/"/>
    
    <category term="JavaScript" scheme="http://example.com/tags/JavaScript/"/>
    
    <category term="v8" scheme="http://example.com/tags/v8/"/>
    
  </entry>
  
  <entry>
    <title>react基础知识</title>
    <link href="http://example.com/2021/03/15/react%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <id>http://example.com/2021/03/15/react%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</id>
    <published>2021-03-15T12:34:00.000Z</published>
    <updated>2024-01-02T01:12:08.509Z</updated>
    
    <content type="html"><![CDATA[<h1 id="react-基础知识"><a href="#react-基础知识" class="headerlink" title="react 基础知识"></a>react 基础知识</h1><h2 id="基础语法JSX"><a href="#基础语法JSX" class="headerlink" title="基础语法JSX"></a>基础语法JSX</h2><ul><li><p>什么是jsx<br>JSX即JavaScript XML。运用于React架构中，其格式比较像是模版语言，但事实上完全是在JavaScript内部实现的。元素是构成React应用的最小单位，JSX就是用来声明React当中的元素，React使用JSX来描述用户界面。<br>语法例子：<br><code>const element = &lt;h1&gt;Hello, world!&lt;/h1&gt;;</code></p></li><li><p>JSX 是react 标配吗？<br>对于这个问题，在react.js 框架出来的时候为了更好的实现react渲染逻辑，出现了jsx。React 认为渲染逻辑本质上与其他 UI 逻辑内在耦合，比如，在 UI 中需要绑定处理事件、在某些时刻状态发生变化时需要通知到 UI，以及需要在 UI 中展示准备好的数据。<br>React 并没有采用将标记与逻辑进行分离到不同文件这种人为地分离方式，而是通过将二者共同存放在称之为“组件”的松散耦合单元之中<br>比如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">formatName</span>(<span class="params">user</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> user.firstName + <span class="string">&#x27; &#x27;</span> + user.lastName;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> user = &#123;</span><br><span class="line">  <span class="attr">firstName</span>: <span class="string">&#x27;Harper&#x27;</span>,</span><br><span class="line">  <span class="attr">lastName</span>: <span class="string">&#x27;Perez&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> element = (</span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="xml">    Hello, &#123;formatName(user)&#125;!</span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">  element,</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">&#x27;root&#x27;</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><blockquote><p>React <a href="https://zh-hans.reactjs.org/docs/react-without-jsx.html">不强制要求</a>使用 JSX，但是大多数人发现，在 JavaScript 代码中将 JSX 和 UI 放在一起时，会在视觉上有辅助作用。它还可以使 React 显示更多有用的错误和警告消息。</p></blockquote></li><li><p>JSX 嵌入表达式</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> name = <span class="string">&#x27;Josh Perez&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> element = <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, &#123;name&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">  element,</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">&#x27;root&#x27;</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li><li><p>JSX 特定属性</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nst element = &lt;div tabIndex=&quot;0&quot;&gt;&lt;/div&gt;;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const element = &lt;img src=&#123;user.avatarUrl&#125;&gt;&lt;/img&gt;;</span><br></pre></td></tr></table></figure><blockquote><p>警告：<br>因为 JSX 语法上更接近 JavaScript 而不是 HTML，所以 React DOM 使用 camelCase（小驼峰命名）来定义属性的名称，而不使用 HTML 属性名称的命名约定。<br>例如，JSX 里的 class 变成了 className，而 tabindex 则变为 tabIndex。</p></blockquote></li><li><p>JSX 指定子元素<br>一个标签里面没有内容，你可以使用 /&gt; 来闭合标签，就像 XML 语法一样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const element = &lt;img src=&#123;user.avatarUrl&#125; /&gt;;</span><br></pre></td></tr></table></figure><p>JSX 标签里能够包含很多子元素:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const element = (</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;h1&gt;Hello!&lt;/h1&gt;</span><br><span class="line">    &lt;h2&gt;Good to see you here.&lt;/h2&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li><li><p>JSX 防止注入攻击</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const title = response.potentiallyMaliciousInput;</span><br><span class="line">// 直接使用是安全的：</span><br><span class="line">const element = &lt;h1&gt;&#123;title&#125;&lt;/h1&gt;;</span><br></pre></td></tr></table></figure><p>React DOM 在渲染所有输入内容之前，默认会进行转义。它可以确保在你的应用中，永远不会注入那些并非自己明确编写的内容。所有的内容在渲染之前都被转换成了字符串。这样可以有效地防止 XSS（cross-site-scripting, 跨站脚本）攻击。</p></li><li><p>JSX 表示对象<br>Babel 会把 JSX 转译成一个名为 React.createElement() 函数调用。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const element = (</span><br><span class="line">  &lt;h1 className=&quot;greeting&quot;&gt;</span><br><span class="line">    Hello, world!</span><br><span class="line">  &lt;/h1&gt;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const element = React.createElement(</span><br><span class="line">  &#x27;h1&#x27;,</span><br><span class="line">  &#123;className: &#x27;greeting&#x27;&#125;,</span><br><span class="line">  &#x27;Hello, world!&#x27;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>React.createElement() 会预先执行一些检查，以帮助你编写无错代码，但实际上它创建了一个这样的对象：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 注意：这是简化过的结构</span><br><span class="line">const element = &#123;</span><br><span class="line">  type: &#x27;h1&#x27;,</span><br><span class="line">  props: &#123;</span><br><span class="line">    className: &#x27;greeting&#x27;,</span><br><span class="line">    children: &#x27;Hello, world!&#x27;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这些对象被称为 “React 元素”。它们描述了你希望在屏幕上看到的内容。React 通过读取这些对象，然后使用它们来构建 DOM 以及保持随时更新。</p></li></ul><h2 id="组建-props"><a href="#组建-props" class="headerlink" title="组建/props"></a>组建/props</h2><p>组件允许你将 UI 拆分为独立可复用的代码片段，并对每个片段进行独立构思。</p><blockquote><p>注意： 组件名称必须以大写字母开头。<br>React 会将以小写字母开头的组件视为原生 DOM 标签。例如，<code>&lt;div /&gt;</code> 代表 HTML 的 div 标签，而 <code>&lt;Welcome /&gt;</code> 则代表一个组件，并且需在作用域内使用 Welcome。</p></blockquote><p>你可以在<a href="https://zh-hans.reactjs.org/docs/jsx-in-depth.html#user-defined-components-must-be-capitalized">深入</a> JSX 中了解更多关于此规范的原因。</p><h2 id="state-amp-生命周期"><a href="#state-amp-生命周期" class="headerlink" title="state &amp; 生命周期"></a>state &amp; 生命周期</h2><p>React 把组件看成是一个状态机（State Machines）。通过与用户的交互，实现不同状态，然后渲染 UI，让用户界面和数据保持一致。</p><p>React 里，只需更新组件的 state，然后根据新的 state 重新渲染用户界面（不要操作 DOM）。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Clock</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">props</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(props);</span><br><span class="line">    <span class="built_in">this</span>.state = &#123;<span class="attr">date</span>: <span class="keyword">new</span> <span class="built_in">Date</span>()&#125;;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, world!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">h2</span>&gt;</span>现在是 &#123;this.state.date.toLocaleTimeString()&#125;.<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">ReactDOM.render(</span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">Clock</span> /&gt;</span></span>,</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">&#x27;example&#x27;</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><strong>正确地使用 State</strong></p><ul><li>不要直接修改 State<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Wrong  此代码不会重新渲染组件：</span></span><br><span class="line"><span class="built_in">this</span>.state.comment = <span class="string">&#x27;Hello&#x27;</span>;</span><br></pre></td></tr></table></figure></li></ul><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Correct</span></span><br><span class="line"><span class="built_in">this</span>.setState(&#123;<span class="attr">comment</span>: <span class="string">&#x27;Hello&#x27;</span>&#125;);</span><br></pre></td></tr></table></figure><p>构造函数是唯一可以给 this.state 赋值的地方：</p><ul><li>State 的更新可能是异步的<br>出于性能考虑，React 可能会把多个 setState() 调用合并成一个调用。</li></ul><p>因为 this.props 和 this.state 可能会异步更新，所以你不要依赖他们的值来更新下一个状态。</p><p>比如：此代码可能会无法更新计数器：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Wrong</span></span><br><span class="line"><span class="built_in">this</span>.setState(&#123;</span><br><span class="line">  <span class="attr">counter</span>: <span class="built_in">this</span>.state.counter + <span class="built_in">this</span>.props.increment,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>要解决这个问题，可以让 setState() 接收一个函数而不是一个对象。这个函数用上一个 state 作为第一个参数，将此次更新被应用时的 props 做为第二个参数：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Correct</span></span><br><span class="line"><span class="built_in">this</span>.setState(<span class="function">(<span class="params">state, props</span>) =&gt;</span> (&#123;</span><br><span class="line">  <span class="attr">counter</span>: state.counter + props.increment</span><br><span class="line">&#125;));</span><br></pre></td></tr></table></figure><p>注意：在某些特殊情况下 需要将更改后的状态立即更新此时可以设置<code>setState()</code>第二个参数<br>react的setstate方法中的第二个参数为会回掉函数,可以调用 forceUpdate() 强制让组件重新渲染</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span>.setState(&#123;</span><br><span class="line">  <span class="attr">mystate</span>: <span class="string">&#x27;xxx&#x27;</span></span><br><span class="line">&#125;, <span class="function">()=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.forceUpdate()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><p>react 16之前<br><img src="https://img-blog.csdnimg.cn/20200831134455163.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1lhbkFoYW8=,size_16,color_FFFFFF,t_70" alt="react lifecycle"><br>react 17之后<br><img src="https://segmentfault.com/img/bVbBsYR" alt="react life new"></p><h3 id="数据是向下流动的"><a href="#数据是向下流动的" class="headerlink" title="数据是向下流动的"></a>数据是向下流动的</h3><p>不管是父组件或是子组件都无法知道某个组件是有状态的还是无状态的，并且它们也并不关心它是函数组件还是 class 组件。</p><p>这就是为什么称 state 为局部的或是封装的的原因。除了拥有并设置了它的组件，其他组件都无法访问。</p><h2 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h2><p>React 元素的事件处理和 DOM 元素的很相似，但是有一点语法上的不同：</p><p>React 事件的命名采用小驼峰式（camelCase），而不是纯小写。<br>使用 JSX 语法时你需要传入一个函数作为事件处理函数，而不是一个字符串。</p><p>传统HTML</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;button onclick=&quot;activateLasers()&quot;&gt;</span><br><span class="line">  Activate Lasers</span><br><span class="line">&lt;/button&gt;</span><br></pre></td></tr></table></figure><p>react中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;button onClick=&#123;activateLasers&#125;&gt;</span><br><span class="line">  Activate Lasers</span><br><span class="line">&lt;/button&gt;</span><br></pre></td></tr></table></figure><p>在 React 中另一个不同点是你不能通过返回 false 的方式阻止默认行为。你必须显式的使用 preventDefault。例如，传统的 HTML 中阻止表单的默认提交行为，你可以这样写：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;form onsubmit=<span class="string">&quot;console.log(&#x27;You clicked submit.&#x27;); return false&quot;</span>&gt;</span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span>&gt;</span>Submit<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure><p>在 React 中，可能是这样的：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Form</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">handleSubmit</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">    e.preventDefault();</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;You clicked submit.&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">form</span> <span class="attr">onSubmit</span>=<span class="string">&#123;handleSubmit&#125;</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span>&gt;</span>Submit<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里，e 是一个合成事件。React 根据 W3C 规范来定义这些合成事件，所以你不需要担心跨浏览器的兼容性问题。React 事件与原生事件不完全相同。</p><blockquote><p>如果想了解更多，请查看 <a href="https://zh-hans.reactjs.org/docs/events.html">SyntheticEvent</a> 参考指南。</p></blockquote><p>完整例子：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Toggle</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">props</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(props);</span><br><span class="line">    <span class="built_in">this</span>.state = &#123;<span class="attr">isToggleOn</span>: <span class="literal">true</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为了在回调中使用 `this`，这个绑定是必不可少的</span></span><br><span class="line">    <span class="built_in">this</span>.handleClick = <span class="built_in">this</span>.handleClick.bind(<span class="built_in">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">handleClick</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.setState(<span class="function"><span class="params">prevState</span> =&gt;</span> (&#123;</span><br><span class="line">      <span class="attr">isToggleOn</span>: !prevState.isToggleOn</span><br><span class="line">    &#125;));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;this.handleClick&#125;</span>&gt;</span></span></span><br><span class="line"><span class="xml">        &#123;this.state.isToggleOn ? &#x27;ON&#x27; : &#x27;OFF&#x27;&#125;</span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">Toggle</span> /&gt;</span></span>,</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">&#x27;root&#x27;</span>)</span><br><span class="line">);</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>向事件处理程序传递参数<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;button onClick=&#123;<span class="function">(<span class="params">e</span>) =&gt;</span> <span class="built_in">this</span>.deleteRow(id, e)&#125;&gt;Delete Row&lt;/button&gt;</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;this.deleteRow.bind(this,</span> <span class="attr">id</span>)&#125;&gt;</span>Delete Row<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br></pre></td></tr></table></figure>React 的事件对象 e 会被作为第二个参数传递。如果通过箭头函数的方式，事件对象必须显式的进行传递，而通过 bind 的方式，事件对象以及更多的参数将会被隐式的进行传递。</li></ul><h2 id="元素渲染"><a href="#元素渲染" class="headerlink" title="元素渲染"></a>元素渲染</h2><h3 id="条件渲染"><a href="#条件渲染" class="headerlink" title="条件渲染"></a>条件渲染</h3><p>在 React 中，你可以创建不同的组件来封装各种你需要的行为。然后，依据应用的不同状态，你可以只渲染对应状态下的部分内容。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">UserGreeting</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Welcome back!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">GuestGreeting</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Please sign up.<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Greeting</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> isLoggedIn = props.isLoggedIn;</span><br><span class="line">  <span class="keyword">if</span> (isLoggedIn) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">UserGreeting</span> /&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">GuestGreeting</span> /&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">  <span class="comment">// Try changing to isLoggedIn=&#123;true&#125;:</span></span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">Greeting</span> <span class="attr">isLoggedIn</span>=<span class="string">&#123;false&#125;</span> /&gt;</span></span>,</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">&#x27;root&#x27;</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>运算符 &amp;&amp;<br>通过花括号包裹代码，你可以在 JSX 中嵌入表达式。这也包括 JavaScript 中的逻辑与 (&amp;&amp;) 运算符。它可以很方便地进行元素的条件渲染：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Mailbox</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> unreadMessages = props.unreadMessages;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="xml">      &#123;unreadMessages.length &gt; 0 &amp;&amp;</span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="xml">          You have &#123;unreadMessages.length&#125; unread messages.</span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="xml">      &#125;</span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> messages = [<span class="string">&#x27;React&#x27;</span>, <span class="string">&#x27;Re: React&#x27;</span>, <span class="string">&#x27;Re:Re: React&#x27;</span>];</span><br><span class="line">ReactDOM.render(</span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">Mailbox</span> <span class="attr">unreadMessages</span>=<span class="string">&#123;messages&#125;</span> /&gt;</span></span>,</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">&#x27;root&#x27;</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>三目运算符<br>另一种内联条件渲染的方法是使用 JavaScript 中的三目运算符 condition ? true : false。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> isLoggedIn = <span class="built_in">this</span>.state.isLoggedIn;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">      The user is <span class="tag">&lt;<span class="name">b</span>&gt;</span>&#123;isLoggedIn ? &#x27;currently&#x27; : &#x27;not&#x27;&#125;<span class="tag">&lt;/<span class="name">b</span>&gt;</span> logged in.</span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="列表-amp-key"><a href="#列表-amp-key" class="headerlink" title="列表 &amp; key"></a>列表 &amp; key</h3><blockquote><p>map函数<br>map() 方法创建一个新数组，其结果是该数组中的每个元素是调用一次提供的函数后的返回值。</p></blockquote><p>渲染多个组件<br>你可以通过使用 {} 在 JSX 内构建一个元素集合。</p><p>下面，我们使用 Javascript 中的 map() 方法来遍历 numbers 数组。将数组中的每个元素变成 <li> 标签，最后我们将得到的数组赋值给 listItems：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">const</span> listItems = numbers.map(<span class="function">(<span class="params">number</span>) =&gt;</span></span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">li</span>&gt;</span>&#123;number&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>基础列表组件</p><p>通常你需要在一个组件中渲染列表。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">NumberList</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> numbers = props.numbers;</span><br><span class="line">  <span class="keyword">const</span> listItems = numbers.map(<span class="function">(<span class="params">number</span>) =&gt;</span></span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">li</span>&gt;</span>&#123;number&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">ul</span>&gt;</span>&#123;listItems&#125;<span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">ReactDOM.render(</span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">NumberList</span> <span class="attr">numbers</span>=<span class="string">&#123;numbers&#125;</span> /&gt;</span></span>,</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">&#x27;root&#x27;</span>)</span><br><span class="line">);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="key"><a href="#key" class="headerlink" title="key"></a>key</h4><p>key 帮助 React 识别哪些元素改变了，比如被添加或删除。因此你应当给数组中的每一个元素赋予一个确定的标识。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">const</span> listItems = numbers.map(<span class="function">(<span class="params">number</span>) =&gt;</span></span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&#123;number.toString()&#125;</span>&gt;</span></span></span><br><span class="line"><span class="xml">    &#123;number&#125;</span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>一个元素的 key 最好是这个元素在列表中拥有的一个独一无二的字符串。 不建议使用<code>Math.random()</code> 来当作key值<br><a href="https://zh-hans.reactjs.org/docs/reconciliation.html#recursing-on-children">为什么 key 是必须的</a></p><h3 id="表单"><a href="#表单" class="headerlink" title="表单"></a>表单</h3><p>在 React 里，HTML 表单元素的工作方式和其他的 DOM 元素有些不同，这是因为表单元素通常会保持一些内部的 state。例如这个纯 HTML 表单只接受一个名称：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;form&gt;</span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">label</span>&gt;</span></span></span><br><span class="line"><span class="xml">    名字:</span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">label</span>&gt;</span></span></span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;提交&quot;</span> /&gt;</span></span></span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure><ul><li>受控组件<br>在 HTML 中，表单元素（如<code>&lt;input&gt;</code>、 <code>&lt;textarea&gt;</code> 和 <code>&lt;select&gt;</code>）通常自己维护 state，并根据用户输入进行更新。而在 React 中，可变状态（mutable state）通常保存在组件的 state 属性中，并且只能通过使用 setState()来更新。</li></ul><p>我们可以把两者结合起来，使 React 的 state 成为“唯一数据源”。渲染表单的 React 组件还控制着用户输入过程中表单发生的操作。被 React 以这种方式控制取值的表单输入元素就叫做“受控组件”。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NameForm</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">props</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(props);</span><br><span class="line">    <span class="built_in">this</span>.state = &#123;<span class="attr">value</span>: <span class="string">&#x27;&#x27;</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">this</span>.handleChange = <span class="built_in">this</span>.handleChange.bind(<span class="built_in">this</span>);</span><br><span class="line">    <span class="built_in">this</span>.handleSubmit = <span class="built_in">this</span>.handleSubmit.bind(<span class="built_in">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">handleChange</span>(<span class="params">event</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.setState(&#123;<span class="attr">value</span>: event.target.value&#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">handleSubmit</span>(<span class="params">event</span>)</span> &#123;</span><br><span class="line">    alert(<span class="string">&#x27;提交的名字: &#x27;</span> + <span class="built_in">this</span>.state.value);</span><br><span class="line">    event.preventDefault();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="xml"><span class="tag">&lt;<span class="name">form</span> <span class="attr">onSubmit</span>=<span class="string">&#123;this.handleSubmit&#125;</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">label</span>&gt;</span></span></span><br><span class="line"><span class="xml">          名字:</span></span><br><span class="line"><span class="xml">          <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">value</span>=<span class="string">&#123;this.state.value&#125;</span> <span class="attr">onChange</span>=<span class="string">&#123;this.handleChange&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">label</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;提交&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>非受控组件<br>在大多数情况下，我们推荐使用 受控组件 来处理表单数据。在一个受控组件中，表单数据是由 React 组件来管理的。另一种替代方案是使用非受控组件，这时表单数据将交由 DOM 节点来处理。</li></ul><p>要编写一个非受控组件，而不是为每个状态更新都编写数据处理函数，你可以 使用 ref 来从 DOM 节点中获取表单数据。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NameForm</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">props</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(props);</span><br><span class="line">    <span class="built_in">this</span>.handleSubmit = <span class="built_in">this</span>.handleSubmit.bind(<span class="built_in">this</span>);</span><br><span class="line">    <span class="built_in">this</span>.input = React.createRef();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">handleSubmit</span>(<span class="params">event</span>)</span> &#123;</span><br><span class="line">    alert(<span class="string">&#x27;A name was submitted: &#x27;</span> + <span class="built_in">this</span>.input.current.value);</span><br><span class="line">    event.preventDefault();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="xml"><span class="tag">&lt;<span class="name">form</span> <span class="attr">onSubmit</span>=<span class="string">&#123;this.handleSubmit&#125;</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">label</span>&gt;</span></span></span><br><span class="line"><span class="xml">          Name:</span></span><br><span class="line"><span class="xml">          <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">ref</span>=<span class="string">&#123;this.input&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">label</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Submit&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;</summary>
        
      
    
    
    
    <category term="知识剖析" scheme="http://example.com/categories/%E7%9F%A5%E8%AF%86%E5%89%96%E6%9E%90/"/>
    
    
    <category term="JavaScript" scheme="http://example.com/tags/JavaScript/"/>
    
    <category term="浏览器" scheme="http://example.com/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
    <category term="react" scheme="http://example.com/tags/react/"/>
    
  </entry>
  
</feed>
