<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>彼方のE栈</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2024-02-19T10:44:35.853Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>境界の彼方</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Jest 测试工具（1）</title>
    <link href="http://example.com/2024/02/19/jest(1)/"/>
    <id>http://example.com/2024/02/19/jest(1)/</id>
    <published>2024-02-19T10:44:51.000Z</published>
    <updated>2024-02-19T10:44:35.853Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Jest"><a href="#Jest" class="headerlink" title="Jest"></a>Jest</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>Facebook 开源的一套 JavaScript 测试框架，它集成了断言库、mock、快照测试、覆盖率报告等功能。它非常适合用来测试 React 代码，但不仅仅如此，所有的 js 代码都可以使用 Jest 进行测试</p><h2 id="快照测试"><a href="#快照测试" class="headerlink" title="快照测试"></a>快照测试</h2><p>快照测试的基本理念，即：先保存一份副本文件，下次测试时把当前输出和上次副本文件对比就知道此次重构是否破坏了某些东西。</p><p><code>jest</code> 的快照测试提供了更高级的功能：</p><ol><li>自动创建把输出内容写到 .snap 快照文件，下次测试时可以自动对比</li><li>输出格式化的快照文件，阅读友好，开发者更容易看懂</li><li>当在做 diff 对比时，jest 能高亮差异点，而且对比信息更容易阅读</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// tests/components/Title.test.tsx</span><br><span class="line">import React from &quot;react&quot;;</span><br><span class="line">import &#123; render &#125; from &quot;@testing-library/react&quot;;</span><br><span class="line">import Title from &quot;components/Title&quot;;</span><br><span class="line"></span><br><span class="line">describe(&quot;Title&quot;, () =&gt; &#123;</span><br><span class="line">  it(&quot;可以正确渲染大字&quot;, () =&gt; &#123;</span><br><span class="line">    const &#123; baseElement &#125; = render(&lt;Title type=&quot;large&quot; title=&quot;大字&quot; /&gt;);</span><br><span class="line">    expect(baseElement).toMatchSnapshot();</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  it(&quot;可以正确渲染小字&quot;, () =&gt; &#123;</span><br><span class="line">    const &#123; baseElement &#125; = render(&lt;Title type=&quot;small&quot; title=&quot;小字&quot; /&gt;);</span><br><span class="line">    expect(baseElement).toMatchSnapshot();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>执行测试后，会发现在 <code>tests/components/</code> 下多了一个 <code>Title.test.tsx.snap</code> 文件，打开来看看：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">// tests/components/Title.test.tsx.snap</span><br><span class="line">// Jest Snapshot v1, https://goo.gl/fbAQLP</span><br><span class="line"></span><br><span class="line">exports[`Title 可以正确渲染大字 1`] = `</span><br><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;p</span><br><span class="line">      style=&quot;font-size: 2em; color: red;&quot;</span><br><span class="line">    &gt;</span><br><span class="line">      大字</span><br><span class="line">    &lt;/p&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">`;</span><br><span class="line"></span><br><span class="line">exports[`Title 可以正确渲染小字 1`] = `</span><br><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;p</span><br><span class="line">      style=&quot;font-size: 0.5em; color: green;&quot;</span><br><span class="line">    &gt;</span><br><span class="line">      小字</span><br><span class="line">    &lt;/p&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">`;</span><br></pre></td></tr></table></figure><p>快照测试通过说明渲染组件没有变，如果不通过则有两种可能：</p><ol><li>代码有 Bug。 本来好好的，被你这么一改，改出了问题</li><li>实现了新功能。 新功能可能会改变原有的 DOM 结构，所以你要用 jest –updateSnapshot 来更新快照</li></ol><h3 id="缺陷"><a href="#缺陷" class="headerlink" title="缺陷"></a>缺陷</h3><ol><li>避免大快照</li></ol><p>真实业务组件中动辄就有十几个标签，还带上很多乱七八糟的属性，生成的快照文件会变得无比巨大。</p><p>对于这个问题，我们能做的就是避免大快照，不要无脑地记录整个组件的快照，特别是有别的 UI 组件参与其中的时候:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">const Title: FC&lt;Props&gt; = (props) =&gt; &#123;</span><br><span class="line">  const &#123; title, type &#125; = props;</span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line">    &lt;Row style=&#123;styleMapper[type]&#125;&gt;</span><br><span class="line">      &lt;Col&gt;</span><br><span class="line">        第一个 Col</span><br><span class="line">      &lt;/Col&gt;</span><br><span class="line">      &lt;Col&gt;</span><br><span class="line">        &lt;div&gt;&#123;title&#125;&lt;/div&gt;</span><br><span class="line">      &lt;/Col&gt;</span><br><span class="line">    &lt;/Row&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>对于那种输出很复杂，而且不方便用 <code>expect</code> 做断言时，快照测试才算是一个好方法。 这也是为什么组件 DOM 结构适合做快照，因为 DOM 结构有大量的大于、小于、引号这些字符。如果都用 <code>expect</code> 来断言，<code>expect</code> 的结果会写得非常痛苦。 不过，需要注意的是：不要把无关的 DOM 也记录到快照里，这无法让人看懂。</p><ol start="2"><li>假错误<br>业务代码并没有任何问题，测试却出错了，这就是测试中的 “假错误”</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">describe(&quot;Title&quot;, () =&gt; &#123;</span><br><span class="line">  it(&quot;可以正确渲染大字&quot;, () =&gt; &#123;</span><br><span class="line">    const &#123; getByText &#125; = render(&lt;Title type=&quot;large&quot; title=&quot;我是一个大帅哥&quot; /&gt;);</span><br><span class="line">    const content = getByText(&#x27;大字&#x27;);</span><br><span class="line">    expect(content).toMatchSnapshot();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>在一些大快照，复杂组件的情况下，只要别的开发者改了某个地方，很容易导致一大片快照报错，基于人性的弱点，他们是没耐心看测试失败的原因的， 再加上更新快照的成本很低，只要加个 –updateSnapshot 就可以了，所以人们在面对快照测试不通过时，往往选择更新快照而不去思考 DOM 结构是否真的变了。</p><p>这些因素造成的最终结果就是：不再信任快照测试。 所以，你也会发现市面上很多前端测试的总结以及文章都很少做 快照测试。很大原因是快照测试本身比较脆弱， 而且容易造成 “假错误”。</p><ol start="3"><li>快照的扩展<br>把快照测试直接等于组件的 UI 测试，或者说快照测试是只用来测组件的。而事实上并不是！ Jest 的快照可不仅仅能记录 DOM 结构，还能记录 一切能被序列化 的内容，比如纯文本、JSON、XML 等等。</li></ol><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>快照测试。快照测试的思想很简单：</p><ul><li>先执行一次测试，把输出结果记录到 .snap 文件，以后每次测试都会把输出结果和 .snap 文件做 对比</li><li>快照失败有两种可能：<ul><li>业务代码变更后导致输出结果和以前记录的 .snap 不一致，说明业务代码有问题，要排查 Bug</li><li>业务代码有更新导致输出结果和以前记录的 .snap 不一致，新增功能改变了原有的 DOM 结构，要用 <code>npx jest --updateSnapshot</code> 更新当前快照</li></ul></li></ul><p>要避免“假错误”的情况，需要做好两点：</p><ul><li>生成小快照。 只取重要的部分来生成快照，必须保证快照是能让你看懂的</li><li>合理使用快照。 快照测试不是只为组件测试服务，同样组件测试也不一定要包含快照测试。快照能存放一切可序列化的内容。</li></ul><p>根据上面两点，还能总结出快照测试的适用场景：</p><ul><li>组件 DOM 结构的对比</li><li>在线上跑了很久的老项目</li><li>大块数据结果的对比</li></ul><h2 id="组件测试"><a href="#组件测试" class="headerlink" title="组件测试"></a>组件测试</h2><p>大多数情况下，对于组件中都会参杂对后端 API 的调用，但是对于每次测试来说不可能时刻调用后端接口。这个时候就需要利用 jest mock 功能 mock 后端请求返回值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">// src/components/AuthButton/index.tsx</span><br><span class="line">import React, &#123; FC, useEffect, useState &#125; from &quot;react&quot;;</span><br><span class="line">import &#123; Button, ButtonProps, message &#125; from &quot;antd&quot;;</span><br><span class="line">import classnames from &quot;classnames&quot;;</span><br><span class="line">import styles from &quot;./styles.module.less&quot;;</span><br><span class="line">import &#123; getUserRole, UserRoleType &#125; from &quot;apis/user&quot;;</span><br><span class="line"></span><br><span class="line">type Props = ButtonProps;</span><br><span class="line"></span><br><span class="line">// 身份文案 Mapper</span><br><span class="line">const mapper: Record&lt;UserRoleType, string&gt; = &#123;</span><br><span class="line">  user: &quot;普通用户&quot;,</span><br><span class="line">  admin: &quot;管理员&quot;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">const AuthButton: FC&lt;Props&gt; = (props) =&gt; &#123;</span><br><span class="line">  const &#123; children, className, ...restProps &#125; = props;</span><br><span class="line"></span><br><span class="line">  const [userType, setUserType] = useState&lt;UserRoleType&gt;();</span><br><span class="line"></span><br><span class="line">  // 获取用户身份并设置</span><br><span class="line">  const getLoginState = async () =&gt; &#123;</span><br><span class="line">    const res = await getUserRole();</span><br><span class="line">    setUserType(res.data.userType);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  useEffect(() =&gt; &#123;</span><br><span class="line">    getLoginState().catch((e) =&gt; message.error(e.message));</span><br><span class="line">  &#125;, []);</span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line">    &lt;Button &#123;...restProps&#125; className=&#123;classnames(className, styles.authButton)&#125;&gt;</span><br><span class="line">      &#123;mapper[userType!] || &quot;&quot;&#125;</span><br><span class="line">      &#123;children&#125;</span><br><span class="line">    &lt;/Button&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">export default AuthButton;</span><br></pre></td></tr></table></figure><h3 id="Mock-Axios"><a href="#Mock-Axios" class="headerlink" title="Mock Axios"></a>Mock Axios</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">// tests/components/AuthButton/mockAxios.test.tsx</span><br><span class="line">import React from &quot;react&quot;;</span><br><span class="line">import axios from &quot;axios&quot;;</span><br><span class="line">import &#123; render, screen &#125; from &quot;@testing-library/react&quot;;</span><br><span class="line">import AuthButton from &quot;components/AuthButton&quot;;</span><br><span class="line"></span><br><span class="line">// 更偏向细节，效果并不好</span><br><span class="line">describe(&quot;AuthButton Mock Axios&quot;, () =&gt; &#123;</span><br><span class="line">  it(&quot;可以正确展示普通用户按钮内容&quot;, async () =&gt; &#123;</span><br><span class="line">    jest.spyOn(axios, &quot;get&quot;).mockResolvedValueOnce(&#123;</span><br><span class="line">      // 其它的实现...</span><br><span class="line">      data: &#123; userType: &quot;user&quot; &#125;,</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    render(&lt;AuthButton&gt;你好&lt;/AuthButton&gt;);</span><br><span class="line"></span><br><span class="line">    expect(await screen.findByText(&quot;普通用户你好&quot;)).toBeInTheDocument();</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  it(&quot;可以正确展示管理员按钮内容&quot;, async () =&gt; &#123;</span><br><span class="line">    jest.spyOn(axios, &quot;get&quot;).mockResolvedValueOnce(&#123;</span><br><span class="line">      // 其它的实现...</span><br><span class="line">      data: &#123; userType: &quot;admin&quot; &#125;,</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    render(&lt;AuthButton&gt;你好&lt;/AuthButton&gt;);</span><br><span class="line"></span><br><span class="line">    expect(await screen.findByText(&quot;管理员你好&quot;)).toBeInTheDocument();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>分别对两个用例的 axios.get 进行了 Mock，使得一个 Mock 返回 user，另一个 Mock 返回 admin。 最后，在这两个用例里分别断言 <code>&lt;AuthButton/&gt;</code> 的渲染内容。</p><h3 id="Mock-API-函数"><a href="#Mock-API-函数" class="headerlink" title="Mock API 函数"></a>Mock API 函数</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">// tests/components/AuthButton/mockGetUserRole.test.tsx</span><br><span class="line">import React from &quot;react&quot;;</span><br><span class="line">import &#123; render, screen &#125; from &quot;@testing-library/react&quot;;</span><br><span class="line">import AuthButton from &quot;components/AuthButton&quot;;</span><br><span class="line">// 注意：这里要写成 * as userUtils！！！</span><br><span class="line">import * as userUtils from &quot;apis/user&quot;;</span><br><span class="line">import &#123; AxiosResponse &#125; from &quot;axios&quot;;</span><br><span class="line"></span><br><span class="line">// 也很偏向细节，效果也不好</span><br><span class="line">describe(&quot;AuthButton Mock Axios&quot;, () =&gt; &#123;</span><br><span class="line">  it(&quot;可以正确展示普通用户按钮内容&quot;, async () =&gt; &#123;</span><br><span class="line">    jest.spyOn(userUtils, &quot;getUserRole&quot;).mockResolvedValueOnce(&#123;</span><br><span class="line">      // 其它的实现...</span><br><span class="line">      data: &#123; userType: &quot;user&quot; &#125;,</span><br><span class="line">    &#125; as AxiosResponse);</span><br><span class="line"></span><br><span class="line">    render(&lt;AuthButton&gt;你好&lt;/AuthButton&gt;);</span><br><span class="line"></span><br><span class="line">    expect(await screen.findByText(&quot;普通用户你好&quot;)).toBeInTheDocument();</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  it(&quot;可以正确展示管理员按钮内容&quot;, async () =&gt; &#123;</span><br><span class="line">    jest.spyOn(userUtils, &quot;getUserRole&quot;).mockResolvedValueOnce(&#123;</span><br><span class="line">      // 其它的实现...</span><br><span class="line">      data: &#123; userType: &quot;admin&quot; &#125;,</span><br><span class="line">    &#125; as AxiosResponse);</span><br><span class="line"></span><br><span class="line">    render(&lt;AuthButton&gt;你好&lt;/AuthButton&gt;);</span><br><span class="line"></span><br><span class="line">    expect(await screen.findByText(&quot;管理员你好&quot;)).toBeInTheDocument();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>和第一种方法类似，我们依然监听了某个函数（这里是 getUserRole），通过 Mock 其返回来模拟不同场景。</p><h3 id="Mock-Http"><a href="#Mock-Http" class="headerlink" title="Mock Http"></a>Mock Http</h3><p>我们可以不 Mock 任何函数实现，只对 Http 请求进行 Mock！ 这个时候我们需要安装<code>msw</code></p><blockquote><p><a href="https://github.com/mswjs/msw">msw</a>可以拦截指定的 Http 请求，有点类似 Mock.js，是做测试时一个非常强大好用的 Http Mock 工具。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i -D msw@0.39.2</span><br></pre></td></tr></table></figure><p>先在 tests/mockServer/handlers.ts 里添加 Http 请求的 Mock Handler：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">import &#123; rest &#125; from &quot;msw&quot;;</span><br><span class="line"></span><br><span class="line">const handlers = [</span><br><span class="line">  rest.get(&quot;https://mysite.com/api/role&quot;, async (req, res, ctx) =&gt; &#123;</span><br><span class="line">    return res(</span><br><span class="line">      ctx.status(200),</span><br><span class="line">      ctx.json(&#123;</span><br><span class="line">        userType: &quot;user&quot;,</span><br><span class="line">      &#125;)</span><br><span class="line">    );</span><br><span class="line">  &#125;),</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">export default handlers;</span><br></pre></td></tr></table></figure><p>然后在 tests/mockServer/server.ts 里使用这些 handlers 创建 Mock Server 并导出它：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import &#123; setupServer &#125; from &quot;msw/node&quot;;</span><br><span class="line">import handlers from &quot;./handlers&quot;;</span><br><span class="line"></span><br><span class="line">const server = setupServer(...handlers);</span><br><span class="line"></span><br><span class="line">export default server;</span><br></pre></td></tr></table></figure><p>最后，在我们的 tests/jest-setup.ts 里使用 Mock Server：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">import server from &quot;./mockServer/server&quot;;</span><br><span class="line"></span><br><span class="line">beforeAll(() =&gt; &#123;</span><br><span class="line">  server.listen();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">afterEach(() =&gt; &#123;</span><br><span class="line">  server.resetHandlers();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">afterAll(() =&gt; &#123;</span><br><span class="line">  server.close();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这样一来，在所有测试用例中都能获得 handlers.ts 里的 Mock 返回了。如果你想在某个测试文件中想单独指定某个接口的 Mock 返回， 可以使用 server.use(mockHandler) 来实现。 我们以 <code>&lt;AuthButton/&gt;</code> 为例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">// tests/components/AuthButton/mockHttp.test.tsx</span><br><span class="line">// 更偏向真实用例，效果更好</span><br><span class="line">import server from &quot;../../mockServer/server&quot;;</span><br><span class="line">import &#123; rest &#125; from &quot;msw&quot;;</span><br><span class="line">import &#123; render, screen &#125; from &quot;@testing-library/react&quot;;</span><br><span class="line">import AuthButton from &quot;components/AuthButton&quot;;</span><br><span class="line">import React from &quot;react&quot;;</span><br><span class="line">import &#123; UserRoleType &#125; from &quot;apis/user&quot;;</span><br><span class="line"></span><br><span class="line">// 初始化函数</span><br><span class="line">const setup = (userType: UserRoleType) =&gt; &#123;</span><br><span class="line">  server.use(</span><br><span class="line">    rest.get(&quot;https://mysite.com/api/role&quot;, async (req, res, ctx) =&gt; &#123;</span><br><span class="line">      return res(ctx.status(200), ctx.json(&#123; userType &#125;));</span><br><span class="line">    &#125;)</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">describe(&quot;AuthButton Mock Http 请求&quot;, () =&gt; &#123;</span><br><span class="line">  it(&quot;可以正确展示普通用户按钮内容&quot;, async () =&gt; &#123;</span><br><span class="line">    setup(&quot;user&quot;);</span><br><span class="line"></span><br><span class="line">    render(&lt;AuthButton&gt;你好&lt;/AuthButton&gt;);</span><br><span class="line"></span><br><span class="line">    expect(await screen.findByText(&quot;普通用户你好&quot;)).toBeInTheDocument();</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  it(&quot;可以正确展示管理员按钮内容&quot;, async () =&gt; &#123;</span><br><span class="line">    setup(&quot;admin&quot;);</span><br><span class="line"></span><br><span class="line">    render(&lt;AuthButton&gt;你好&lt;/AuthButton&gt;);</span><br><span class="line"></span><br><span class="line">    expect(await screen.findByText(&quot;管理员你好&quot;)).toBeInTheDocument();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这里声明了一个 setup 函数，用于在每个用例前初始化 Http 请求的 Mock 返回。通过传不同值给 setup 就可以灵活模拟测试场景了。</p><h4 id="如何取舍"><a href="#如何取舍" class="headerlink" title="如何取舍"></a>如何取舍</h4><p>无论后端测试也好、前端测试也好，不管你要测什么，测试的目的都是为了让你能对测过的代码充满信心（Confidence）。什么样的测试才能提高代码自信呢？很简单：像真实用户那样去测你的代码。</p><h2 id="Jest-性能优化"><a href="#Jest-性能优化" class="headerlink" title="Jest 性能优化"></a>Jest 性能优化</h2><h3 id="Jest-架构"><a href="#Jest-架构" class="headerlink" title="Jest 架构"></a>Jest 架构</h3><p><img src="https://github.yanhaixiang.com/jest-tutorial/assets/img/jest-architecture.82649a92.png" alt="img"></p><p>最影响 Jest 性能的有 3 个地方：</p><ol><li>使用 jest-haste-map 生成虚拟文件系统</li><li>多线程执行测试任务</li><li>转译 JavaScript 代码</li></ol><h3 id="虚拟文件系统"><a href="#虚拟文件系统" class="headerlink" title="虚拟文件系统"></a>虚拟文件系统</h3><p>如果要在热更新时修改文件，脚手架都要遍历一次项目文件，非常损耗性能。特别在一些文件特别多的巨石应用中，电脑分分钟就卡得动不了。</p><p>为了解决这个问题，Facebook 团队就想到了一个方法 —— 虚拟文件系统。原理很简单：在第一次启动时遍历整个项目，把文件存储成 Map 的形式， 之后文件做了改动，那么只需增量地修改这个 Map 就可以了。 他们把这个工具命名为 Haste Map，中文翻译可以理解为快速生成 Map 的东西（这名字真的不好）。</p><p>这种思路不仅可以用于热更新场景，还能应用在所有监听文件改动的场景，其中一种就是 npx jest –watch 这个场景。</p><p><img src="https://github.yanhaixiang.com/jest-tutorial/assets/img/haste-map.0cd61a1b.png" alt="img"></p><p>因此，上面图中刚开始时，Jest 就用 jest-haste-map 生成了一次虚拟文件系统，这样后续的过滤、搜索文件就非常快速了。这也是为什么执行第一个测试用例时速度比较慢的原因。 这一步的性能我们无法优化。</p><h3 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h3><p>Jest 还有一个非常强大的功能，利用 Node.js 的 Worker 开启多个线程来执行测试用例。对于一些大型项目（几千个测试用例）来说，这能提升不少效率。</p><p>但线程不是越多越好，每开一个线程都需要额外的开销。如果不做任何配置，那么 Jest 默认最大的 Worker 数是 CPU 数 - 1。其中的 1 用于运行 jest-cli， 剩下的都拿来执行测试用例。由于之前我们一直没有对 maxWorkers 进行配置，所以默认会用最多的 Worker，执行这么几十个简单的测试会非常慢。</p><p>通常来说，单个测试用例速度应该要做到非常快的，尽量不写一些耗时的操作，比如不要加 setTimeout，n 个 for 循环等。 所以，理论上，测试数量不多的情况下单线程就足够了。这里我们可以把 jest.config.js 配置改为用单线程：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// jest.config.js</span><br><span class="line">module.exports = &#123;</span><br><span class="line">  maxWorkers: 1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在流水线中，Jest 也推荐使用单线程来跑单测和集成测试：jest –runInBand，其中 runInBand 和 maxWorkers: 1 效果是一样的。</p><blockquote><p>在以前的 Intel Mac 里单线程的速度比多线程快了一倍，而 M1 的 Mac 上则是相反，多线程比单线程快。所以，还是要自己的机器的情况来决定使用多少个 Worker。</p></blockquote><p>M1 Macbook Pro，单线程：<br><img src="https://github.yanhaixiang.com/jest-tutorial/assets/img/single-worker.5024c896.png" alt="img"></p><p>M1 Macbook Pro，多线程：<br><img src="https://github.yanhaixiang.com/jest-tutorial/assets/img/multiple-workers.497a34f8.png" alt="img"></p><h3 id="文件转译"><a href="#文件转译" class="headerlink" title="文件转译"></a>文件转译</h3><p>最后一个性能优化点就是转译速度（图中第 11 步）。需要注意的是 Jest 是会边执行测试用例边转译 JavaScript</p><p><img src="https://github.yanhaixiang.com/jest-tutorial/assets/img/transpile.56f11504.png" alt="img"></p><p>既然 Jest 刚开始遍历项目来生成虚拟文件系统，为什么不顺便把转译的工作做了呢？<br>当然是因为慢了。 首先，对于很多业务项目来说，测试并不会很多。可能就测几个 utils 下的函数，那如果把项目的文件都转译一次，会把很多没用到测试的业务代码也转译。</p><p>所以说，通过文件找依赖的方式不是很可靠，有太多不确定因素，最终 Jest 还是选择 “执行到那个文件再做转译” 的方法。</p><p>原理说完了，下面来看看怎么提高转译效率。在前面的章节里，我们说到当今 JavaScript 的转译器有很多种，不仅可以用 <code>tsc</code> 和 <code>babel</code> 来转， 还能用别的语言写的转译器 <code>swc</code> 以及 <code>esbuild</code> 来转。</p><p>如果想用 esbuild 做转译，可以看 esbuild-jest (opens new window)这个库。这里我用 @swc/jest (opens new window)做例子， 先安装依赖：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i -D @swc/core@1.2.165 @swc/jest@0.2.20</span><br></pre></td></tr></table></figure><p>然后在 jest.config.js 里添加：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">  // 不用 ts-jest</span><br><span class="line">  // preset: &quot;ts-jest&quot;,</span><br><span class="line"></span><br><span class="line">  transform: &#123;</span><br><span class="line">    // 使用 swc 转译 JavaScript 和 TypeScrit</span><br><span class="line">    &quot;^.+\\.(t|j)sx?$&quot;: [&quot;@swc/jest&quot;],</span><br><span class="line">    // 静态资源 stub 转译</span><br><span class="line">    &quot;.+\\.(css|styl|less|sass|scss|png|jpg|ttf|woff|woff2)$&quot;:</span><br><span class="line">      &quot;jest-transform-stub&quot;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大功告成，配置非常简单，我们来看看使用 ts-jest 以及 @swc/jest 两者的对比。</p><p>ts-jest：<br><img src="https://github.yanhaixiang.com/jest-tutorial/assets/img/ts-jest.4c97d98e.png" alt="img"></p><p>@swc/jest：</p><p><img src="https://github.yanhaixiang.com/jest-tutorial/assets/img/swc.8c4aebf1.png" alt="img"></p><h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><p>有 3 个地方比较耗性能：</p><ol><li>生成虚拟文件系统。 在执行第一个测试会很慢</li><li>多线程。 生成新线程耗费的资源，不过，不同机器的效果会不一致</li><li>文件转译。 Jest 会在执行到该文件再对它进行转译</li></ol><p>解决的方法有：</p><ol><li>无解，有条件的话拆解项目吧</li><li>具体情况具体分析，要看机器的执行情况，多线程快就用多线程，单线程快就用单线程</li><li>使用 esbuild-jest、 @swc/jest 等其它高效的转译工具来做转译</li></ol>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;</summary>
        
      
    
    
    
    <category term="知识剖析" scheme="http://example.com/categories/%E7%9F%A5%E8%AF%86%E5%89%96%E6%9E%90/"/>
    
    
    <category term="单元测试" scheme="http://example.com/tags/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/"/>
    
    <category term="测试工具" scheme="http://example.com/tags/%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>加密媒体扩展</title>
    <link href="http://example.com/2024/01/21/%E5%8A%A0%E5%AF%86%E5%AA%92%E4%BD%93%E6%89%A9%E5%B1%95/"/>
    <id>http://example.com/2024/01/21/%E5%8A%A0%E5%AF%86%E5%AA%92%E4%BD%93%E6%89%A9%E5%B1%95/</id>
    <published>2024-01-21T02:11:51.000Z</published>
    <updated>2024-01-22T00:53:27.406Z</updated>
    
    <content type="html"><![CDATA[<h1 id="加密媒体扩展-Encrypted-Media-Extensions"><a href="#加密媒体扩展-Encrypted-Media-Extensions" class="headerlink" title="加密媒体扩展(Encrypted Media Extensions)"></a>加密媒体扩展(Encrypted Media Extensions)</h1><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>加密媒体扩展（Encrypted Media Extensions）提供了一种 API，可以使 Web 应用程序与内容保护系统进行交互，以允许播放加密的音频和视频。<br><br>EME 旨在使相同的应用程序和加密文件在任何浏览器中使用，而不管底层保护系统如何。前者是通过标准化的 API 和流程实现的，而后者通过通用加密的概念成为可能 。<br><br>EME 是 HTMLMediaElement 规范的扩展，因此取名。作为“扩展”意味着浏览器对 EME 的支持是可选的：如果浏览器不支持加密的媒体，它将无法播放加密的媒体，但是 EME 不符合 HTML 规范。从 EME 规范：<br></p><blockquote><p>该提案扩展了 HTMLMediaElement， 提供了 API 来控制受保护内容的播放。</p></blockquote><p>API 支持从简单的清除密钥解密到高价值视频（给定适当的用户代理实现）的用例。许可证/密钥交换由应用程序控制，便于开发支持一系列内容解密和保护技术的强大的回放应用程序。<br><br>本规范未定义内容保护或数字版权管理系统。相反，它定义了可以用于发现，选择和与这样的系统以及更简单的内容加密系统交互的通用 API。数字版权管理的实施不符合本规范要求：只有 Clear Key 系统才能被实现为一个共同的基准。<br><br>通用 API 支持一组简单的内容加密功能，将页面作者的身份验证和授权等应用程序功能留下。这是通过要求内容保护系统特定的消息传递由页面介导而不是假设加密系统与许可证或其他服务器之间的带外通信来实现的。<br><br>EME 实现使用以下外部组件：</p><ul><li>关键系统：内容保护（DRM）机制。EME 没有定义密钥系统本身，除了清除键（更多关于<a href="https://web.dev/media-eme/#clear_key">下文</a>）。</li><li>内容解密模块（CDM）：支持加密媒体播放的客户端软件或硬件机制。与 Key Systems 一样，EME 还没有定义任何 CDM，而是为应用程序提供了与可用 CDM 进行交互的界面。</li><li>许可证（Key）服务器：与 CDM 进行交互以提供解密媒体的密钥。许可证服务器的协商是应用程序的责任。</li><li>包装服务：编码和加密媒体进行分发/消费。</li></ul><p>请注意，使用 EME 的应用程序与许可证服务器交互以获取密钥以启用解密，但用户身份和身份验证不是 EME 的一部分。在可选地验证用户之后，检索启用媒体播放的键。Netflix 等服务必须对其 Web 应用程序中的用户进行身份验证：用户登录应用程序时，应用程序将确定用户的身份和权限。<br></p><h1 id="EME-如何工作"><a href="#EME-如何工作" class="headerlink" title="EME 如何工作"></a>EME 如何工作</h1><blockquote><p>如果有多种格式或编解码器可用，则 MediaSource.isTypeSupported（）或 HTMLMediaElement.canPlayType（） 都可用于选择正确的格式 。但是，CDM 可能只支持浏览器支持未加密内容的一部分。最好在选择格式和编解码器之前协商 MediaKeys 配置。如果应用程序等待加密的事件，但是 MediaKeys 显示它无法处理所选的格式/编解码器，那么在不中断播放的情况下切换可能太晚了。<br><br>推荐的流程是首先使用 MediaKeysSystemAccess.getConfiguration（）来协商 MediaKey，以查找协商的配置。<br><br>如果只有一种格式/编解码器可供选择，那么不需要 getConfiguration（）。但是，最好先建立 MediaKeys。等待加密事件的唯一原因是，如果没有办法知道内容是否被加密，但实际上不太可能。··</p></blockquote><ol><li>Web 应用程序尝试播放具有一个或多个加密流的音频或视频。</li><li>浏览器会识别媒体是否被加密（请参阅下面的框），并触发加密事件，从媒体获取有关加密的元数据（initData）。</li><li>应用程序处理加密事件：<ol><li>如果没有 MediaKeys 对象已经与媒体元素相关联，首先使用 navigator.requestMediaKeySystemAccess（）来检查可用的密钥系统，然后通过 MediaKeySystemAccess 对象为可用密钥系统创建一个 MediaKeys 对象。请注意，MediaKeys 对象的初始化应该发生在第一个加密事件之前。获取许可证服务器 URL 是由应用程序完成的，而不是选择可用的密钥系统。MediaKeys 对象表示可用于解密音频或视频元素的媒体的所有键。它代表 CDM 实例，并提供对 CDM 的访问，专门用于创建密钥会话，用于从许可证服务器获取密钥。</li><li>MediaKeys 对象创建完成后，将其分配给媒体元素：setMediaKeys（）将 MediaKeys 对象与 HTMLMediaElement 相关联，从而可以在播放过程中使用它的键，即在解码过程中。</li></ol></li><li>该应用程序通过在 MediaKeys 上调用 createSession（）创建一个 MediaKeySession。这将创建一个 MediaKeySession，它表示许可证的生命周期及其密钥。</li><li>通过在 MediaKeySession 上调用 generateRequest（），通过将加密处理程序中获取的媒体数据传递给 CDM 来生成许可证请求。</li><li>CDM 触发消息事件：从许可证服务器获取密钥的请求。</li><li>MediaKeySession 对象接收消息事件，应用程序向许可证服务器发送消息（例如，通过 XHR）。</li><li>应用程序从许可证服务器接收响应，并使用 MediaKeySession 的 update（）方法将数据传递给 CDM。</li><li>CDM 使用许可证中的密钥解密媒体。可以使用与媒体元素相关联的 MediaKey 中的任何会话的有效密钥。CDM 将访问按密钥 ID 索引的密钥和策略。</li></ol><p>媒体播放恢复。</p><blockquote><p>浏览器如何知道媒体是否被加密？<br>该信息在媒体容器文件的元数据中，其格式为 ISO BMFF 或 WebM。对于 ISO BMFF，这意味着标题元数据，称为保护方案信息框。WebM 使用 Matroska ContentEncryption 元素，并添加了特定的 WebM。为 EME 特定的注册表中的每个容器提供了指南。</p></blockquote><p>请注意，CDM 和许可证服务器之间可能存在多条消息，并且此过程中的所有通信对于浏览器和应用程序都是不透明的：消息仅由 CDM 和许可证服务器理解，尽管应用层可以看到 CDM 正在发送 什么类型的消息 。许可证请求包含 CDM 的有效性（和信任关系）的证明，以及在生成的许可证中加密内容密钥时使用的密钥。<br></p><h1 id="但-CDM-究竟做了什么呢？"><a href="#但-CDM-究竟做了什么呢？" class="headerlink" title="但 CDM 究竟做了什么呢？"></a>但 CDM 究竟做了什么呢？</h1><p>EME 实现本身不提供解密媒体的方法：它只是为 Web 应用程序提供一个 API，以便与内容解密模块进行交互。<br><br>CDM 实际上做了什么不是由 EME 规范定义的，CDM 可以处理媒体的解码（解压缩）以及解密。从至少到最强大的，CDM 功能有几个潜在的选择：</p><ul><li>仅解密，使用普通媒体流水线进行播放，例如通过<code>&lt;video&gt;</code>元素进行播放。</li><li>解密和解码，将视频帧传递到浏览器进行渲染。</li><li>解密和解码，直接在硬件中渲染（例如，GPU）。</li></ul><p>可以通过多种方法使 CDM 可用于 Web 应用程序：</p><ul><li>用浏览器捆绑 CDM。</li><li>分发 CDM。</li><li>在操作系统中构建 CDM。</li><li>在固件中加入 CDM。</li><li>将 CDM 嵌入硬件。</li></ul><p>如何提供 CDM 不是由 EME 规范定义的，但在所有情况下，浏览器都负责审核和公开 CDM。<br></p><p>EME 不要求特定的关键系统; 在目前的桌面和移动浏览器中，Chrome 支持 Widevine，IE11 支持 PlayReady。<br></p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;</summary>
        
      
    
    
    
    <category term="知识剖析" scheme="http://example.com/categories/%E7%9F%A5%E8%AF%86%E5%89%96%E6%9E%90/"/>
    
    
    <category term="流媒体" scheme="http://example.com/tags/%E6%B5%81%E5%AA%92%E4%BD%93/"/>
    
    <category term="直播" scheme="http://example.com/tags/%E7%9B%B4%E6%92%AD/"/>
    
    <category term="EME" scheme="http://example.com/tags/EME/"/>
    
  </entry>
  
  <entry>
    <title>加密媒体扩展</title>
    <link href="http://example.com/2024/01/20/CDN%E5%8F%8APCDN/"/>
    <id>http://example.com/2024/01/20/CDN%E5%8F%8APCDN/</id>
    <published>2024-01-20T05:30:51.000Z</published>
    <updated>2024-01-22T00:57:38.803Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CDN-及-PCDN"><a href="#CDN-及-PCDN" class="headerlink" title="CDN 及 PCDN"></a>CDN 及 PCDN</h1><p><img src="https://github.com/CharonChui/Pictures/blob/master/cdn.png?raw=true" alt="image"></p><h2 id="CDN"><a href="#CDN" class="headerlink" title="CDN"></a>CDN</h2><p>CDN(Content Delivery Network 或 Content Ddistribute Network):内容分发网络也称为内容传送网络。<br>是指一种透过互联网互相连接的电脑网络系统，利用最靠近每位用户的服务器，更快、更可靠地将音乐、图片、影片、<br>应用程序及其他文件发送给用户，来提供高性能、可扩展性及低成本的网络内容传递给用户。<br>这个概念始于 1996 年，是美国麻省理工学院的一个研究小组为改善互联网的服务质量而提出的。<br>为了能在传统 IP 网上发布丰富的宽带媒体内容，他们提出在现有互联网基础上建立一个内容分发平台专门为网站提供<br>服务，并于 1999 年成立了专门的 CDN 服务公司，为 Yahoo 提供专业服务。由于 CDN 是为加快网络访问速度而被优化的<br>网络覆盖层，因此被形象地称为“网络加速器”。</p><ul><li>举个栗子:</li></ul><p>大学的时候宿舍里面有一个同学 A 翻墙去东京看一个比较热的电影，日本人访问那个网站的时候，速度就会很快。<br>但是我在中国，当我去访问网站的时候速度就会很慢。这是由于地域的限制，中间隔了很多很多的网络，<br>导致我访问很慢。所有同学 A 想要把这个电影下载下来再看。结果宿舍内的其他同学 BCD 发现这个电影挺好看，<br>他也想看这个电影，如果同学 BCD 直接去该网站上下载这个电影，那速度肯定是奇慢无比。<br>但是如果同学 A 先把这个电影缓存下来，然后同学 BCD 可以直接通过内网来从同学 A 缓存的电影进行下载，<br>这样既不占用访问外网的带宽，也对目标网站的服务器压力小了很多，同时也大大的提高了速度。</p><p>这种把一个视频从比较远的服务器中，缓存下来，放到离用户比较近的地方，让他们可以就近获取，<br>更快速，这就是 CDN,那个缓存视频的同学 A 就是一个 CDN 节点。</p><p>还有一个现实中的例子，我感觉是对 CDN 原理的最佳应用:<br>打个比方我想买一个手表，我先去淘宝上找了一个第三方的卖家，看了下价格，问了一下从哪发货啊，<br>是什么快递啊，他告诉我从深圳发货。到你那三天，因为他这个发货地点一般就是一个。<br>而我在京东上面的话，京东在全国各地都有仓库，他会根据你的位置,在全国范围内找离你最近、<br>送达最快的仓库，京东的这种仓储系统，就是类似 CDN 的作用。</p><h3 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h3><p>CDN 网络中包含的功能实体包括以下部分:</p><ul><li>内容缓存:CDN 网络节点，位于用户接入点，是面向最终用户的内容提供设备，可缓存静态 Web 内容和流媒<br>体内容，实现内容的边缘传播和存储，以便用户的就近访问。它借助于建立索引、缓存、流分裂、组播（Multicast）等技术，将内容发布或投递到距离用户最近的远程服务点（POP）处。<br>内容分发包含从内容源到 CDN 边缘的 Cache 的过程。从实现上，有两种主流的内容分发技术：PUSH 和 PULL。<br>PUSH 是一种主动分发的技术。通常，PUSH 由内容管理系统发起，将内容从源或者中心媒体资源库分发到各边缘的 Cache 节点。分发的协议可以采用 Http/ftp 等。通过 PUSH 分发的内容一般是比较热点的内容，<br>这些内容通过 PUSH 方式预分发到边缘 Cache，可以实现有针对的内容提供。<br>对于 PUSH 分发需要考虑的主要问题是分发策略，即在什么时候分发什么内容。一般来说，<br>内容分发可以由 CP（内容提供商）或者 CDN 内容管理员人工确定，也可以通过智能的方式决定，<br>即所谓的智能分发，它根据用户访问的统计信息，以及预定义的内容分发的规则，确定内容分发的过程。PULL 是一种被动的分发技术，PULL 分发通常由用户请求驱动。当用户请求的内容在本地的边缘 Cache 上不存在（未命中）时，Cache 启动 PULL 方法从内容源或者其他 CDN 节点实时获取内容。在 PULL 方式下，内容的分发是按需的。</li><li>内容交换机:处于用户接入集中点，可以均衡单点多个内容缓存设备的负载，并对内容进行缓存负载平衡及访问控制。</li><li>内容路由器:负责将用户的请求调度到适当的设备上。它是整体性的网络负载均衡技术，通过内容路由器中的重定向（DNS）机制，在多个远程 POP 上均衡用户的请求，<br>以使用户请求得到最近内容源的响应。CDN 负载均衡系统实现 CDN 的内容路由功能。它的作用是将用户的请求导向<br>整个 CDN 网络中的最佳节点。最佳节点的选定可以根据多种策略，例如距离最近、节点负载最轻等。<br>负载均衡系统是整个 CDN 的核心，负载均衡的准确性和效率直接决定了整个 CDN 的效率和性能。<br>通常负载均衡可以分为两个层次:全局负载均衡（GSLB）和本地负载均衡（SLB）。全局负载均衡主要的目的是在整<br>个网络范围内将用户的请求定向到最近的节点（或者区域）。因此，就近性判断是全局负载均衡的主要功能。<br>本地负载均衡一般局限于一定的区域范围内，其目标是在特定的区域范围内寻找一台最适合的节点提供服务，<br>因此，CDN 节点的健康性、负载情况、支持的媒体格式等运行状态是本地负载均衡进行决策的主要依据。</li><li>内容管理系统:负责整个 CDN 的管理，它通过内部和外部监控系统，获取网络部件的状况信息，测量内容发布的<br>端到端性能（如包丢失、延时、平均带宽、启动时间、帧速率等），保证网络处于最佳的运行状态。内容管理在<br>广义上涵盖了从内容的发布、注入、分发、调整、传递等一系列过程。在这里，内容管理重点强调内容进人 Cache<br>点后的内容管理，称其为本地内容管理。本地内容管理主要针对一个 CDN 节点（有多个 CDN Cache 设备和一个<br>SLB 设备构成）进行。本地内容管理的主要目标是提高内容服务的效率，提高本地节点的存储利用率。<br>通过本地内容管理，可以在 CDN 节点实现基于内容感知的调度，通过内容感知的调度，可以避免将用户重定向到没有<br>该内容的 Cache 设备上，从而提高负载均衡的效率。通过本地内容管理还可以有效实现在 CDN 节点内容的存储共享，<br>提高存储空间的利用率。</li></ul><h3 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h3><p>使用 CDN 的第一个也是最重要的原因：加速网站的访问。</p><p>对于 TCP 传输而言，TCP 的速度会受到延迟时间与数据包漏失率影响。为了改善这些负面因素，<br>内容分发网络通常会指派较近、较顺畅的服务器节点将数据传输给用户。虽然距离并不是绝对因素，<br>但这么做可以尽可能提高性能，用户将会觉得比较顺畅。这使得一些比较高带宽的应用（传输高清影片）更容易推动。</p><p>归纳起来，CDN 具有以下主要功能:</p><ol><li>实现跨运营商、跨地域的全网覆盖<br>互联不互通、区域 ISP 地域局限、出口带宽受限制等种种因素都造成了网站的区域性无法访问。<br>CDN 加速可以覆盖全球的线路，通过和运营商合作，部署 IDC 资源，在全国骨干节点上，合理部署 CDN 边缘<br>分发存储节点，充分利用带宽资源，平衡源站流量，这样可以节省骨干网带宽，减少带宽需求量并能<br>解决由于用户访问量大造成的服务器过载问题。</li><li>保障网站安全<br>CDN 的负载均衡和分布式存储技术，可以加强网站的可靠性，相当无无形中给你的网站添加了一把保护伞，<br>应对绝大部分的互联网攻击事件。防攻击系统也能避免网站遭到恶意攻击。</li><li>为了异地备援<br>当某个服务器发生意外故障时，系统将会调用其他临近的健康服务器节点进行服务，进而提供接近 100%的可靠性，<br>这就让你的网站可以做到永不宕机。</li><li>为了节约成本投入<br>使用 CDN 加速可以实现网站的全国铺设，你根本不用考虑购买服务器与后续的托管运维，服务器之间镜像同步，<br>也不用为了管理维护技术人员而烦恼，节省了人力、精力和财力。</li></ol><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul><li>本地 Cache 加速：提高了企业站点（尤其含有大量图片和静态页面站点）的访问速度，<br>并大大提高以上性质站点的稳定性。</li><li>镜像服务：消除了不同运营商之间互联的瓶颈造成的影响，实现了跨运营商的网络加速，保证不同网络中的用户<br>都能得到良好的访问质量。</li><li>远程加速：远程访问用户根据 DNS 负载均衡技术智能自动选择 Cache 服务器，选择最快的 Cache 服务器，<br>加快远程访问的速度。</li><li>带宽优化：自动生成服务器的远程 Mirror（镜像）cache 服务器，远程用户访问时从 cache 服务器上读取数据，<br>减少远程访问的带宽、分担网络流量、减轻原站点 WEB 服务器负载等功能。</li><li>集群抗攻击：广泛分布的 CDN 节点加上节点之间的智能冗余机制，可以有效地预防黑客入侵以及降低各<br>种 D.D.o.S 攻击对网站的影响，同时保证较好的服务质量。</li></ul><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>CDN 的工作原理就是将您源站的资源缓存到位于全国各地的 CDN 节点上，用户请求资源时，就近返回节点上缓存的资源，而不需要每个用户的请求都回您的源站获取，避免网络拥塞、分担源站压力，保证用户访问资源的速度和体验。</p><p>下面分别是不用 CDN 以及使用 CDN 时的访问流程:<br><img src="https://github.com/CharonChui/Pictures/blob/master/dns_no_cdn.png?raw=true" alt="image"></p><p><img src="https://github.com/CharonChui/Pictures/blob/master/dns_cdn.png?raw=true" alt="image"></p><p>上面图中在使用 CDN 时，server-isp-DNS 服务器不是直接把域名做 A 记录映射到源站，而是 CNAME 记录到调度中心，调度中心根据用户请求的来源，选择一个最近的 CDN 节点，主要的流程如下:</p><ol><li>当用户点击网站页面上的内容 URL，经过本地 DNS 系统解析，DNS 系统会最终将域名的解析权交给 CNAME 指向的 CDN 专用 DNS 服务器。</li><li>CDN 的 DNS 服务器将 CDN 的全局负载均衡设备 IP 地址返回用户。</li><li>用户向 CDN 的全局负载均衡设备发起内容 URL 访问请求。</li><li>CDN 全局负载均衡设备根据用户 IP 地址，以及用户请求的内容 URL，选择一台用户所属区域的区域负载均衡设备，告诉用户向这台设备发起请求。</li><li>区域负载均衡设备会为用户选择一台合适的缓存服务器提供服务，选择的依据包括：根据用户 IP 地址，<br>判断哪一台服务器距用户最近；根据用户所请求的 URL 中携带的内容名称，判断哪一台服务器上有用户所需内容；查询各个服务器当前的负载情况，判断哪一台服务器尚有服务能力。基于以上这些条件的综合分析之后，<br>区域负载均衡设备会向全局负载均衡设备返回一台缓存服务器的 IP 地址。</li><li>全局负载均衡设备把服务器的 IP 地址返回给用户。</li><li>用户向缓存服务器发起请求，缓存服务器响应用户请求，将用户所需内容传送到用户终端。如果这台缓存服务器上并没有用户想要的内容，而区域均衡设备依然将它分配给了用户，那么这台服务器就要向它的上一级缓存服务器请求内容，直至追溯到网站的源服务器将内容拉到本地。</li></ol><h3 id="网站接入-CDN"><a href="#网站接入-CDN" class="headerlink" title="网站接入 CDN"></a>网站接入 CDN</h3><p>使用 CDN 的方法很简单，只需要修改自己的 DNS 解析，设置一个 CNAME 指向 CDN 服务商即可。</p><p>用户访问未使用 CDN 缓存资源的过程为:</p><ul><li>浏览器通过前面提到的过程对域名进行解析，以得到此域名对应的 IP 地址；</li><li>浏览器使用所得到的 IP 地址，向域名的服务主机发出数据访问请求；</li><li>服务器向浏览器返回响应数据</li></ul><p>使用 CDN 后:</p><ul><li><p>当用户点击网站页面上的内容 URL，经过本地 DNS 系统解析，DNS 系统会最终将域名的解析权交给 CNAME 指向的 CDN 专用 DNS 服务器。</p></li><li><p>CDN 的 DNS 服务器将 CDN 的全局负载均衡设备 IP 地址返回用户。</p></li><li><p>用户向 CDN 的全局负载均衡设备发起内容 URL 访问请求。</p></li><li><p>CDN 全局负载均衡设备根据用户 IP 地址，以及用户请求的内容 URL，选择一台用户所属区域的区域负载均衡设备，告诉用户向这台设备发起请求。</p></li><li><p>区域负载均衡设备会为用户选择一台合适的缓存服务器提供服务，选择的依据包括：根据用户 IP 地址，判断哪一台服务器距用户最近；根据用户所请求的 URL 中携带的内容名称，判断哪一台服务器上有用户所需内容；查询各个服务器当前的负载情况，判断哪一台服务器尚有服务能力。基于以上这些条件的综合分析之后，区域负载均衡设备会向全局负载均衡设备返回一台缓存服务器的 IP 地址。</p></li><li><p>全局负载均衡设备把服务器的 IP 地址返回给用户</p></li><li><p>用户向缓存服务器发起请求，缓存服务器响应用户请求，将用户所需内容传送到用户终端。如果这台缓存服务器上并没有用户想要的内容，而区域均衡设备依然将它分配给了用户，那么这台服务器就要向它的上一级缓存服务器请求内容，直至追溯到网站的源服务器将内容拉到本地。</p></li></ul><p>上面的字太多，有点绕？通俗点就是用户访问的资源原本是存放在你自己的服务器，通过修改 DNS 让用户根据 IP 等情况来选择合适的 CDN 缓存服务器来获取资源。</p><h2 id="PCDN"><a href="#PCDN" class="headerlink" title="PCDN"></a>PCDN</h2><p>PCDN:(P2P 技术和 CDN 的融合创新)，下面是<a href="https://help.aliyun.com/product/54287.html">阿里云 PCDN</a><br>的介绍:P2P 内容分发网络（英文名：P2P CDN，简称 PCDN）是以 P2P 技术为基础，通过挖掘利用电信边缘网络<br>海量碎片化闲置资源而构建的低成本高品质内容分发网络服务。客户通过集成 PCDN SDK 接入该服务后能获得等<br>同（或略高于）CDN 的分发质量，同时显著降低分发成本。适用于视频点播、直播、大文件下载等业务场景。</p><p>我们知道，在移动终端上，通常上传流量会带来很多负面影响，比如消耗用户流量、更加耗电、频繁读写 T 卡/ROM 影响硬件设备寿命等。阿里云 PCDN 利用海量的 P2P 节点资源，使终端能做到只下载而不用上传，大大扩展了 P2P CDN 的使用范围，这个优势已明显领先于那些完全依靠客户端上传流量而获得 P2P 效率的 P2P 产品。</p><p>P2P 节点布局中有路由器、运营商接入层/汇聚层节点等二级节点可以为客户 APP 提供 P2P 带宽，不强制要求客户 APP 上传流量，所以移动端不需要上传流量也可以使用 PCDN。</p><p>另外，PCDN 针对各类业务场景做了进一步优化，使之对各场景的支持更加完善，给客户提供了更多差异化价值。在下载业务方面，支持下载速率控制（限速）。在带宽峰期对下载速度进行限制，可以有效控制带宽峰值。对于一些不追求下载速度的后台下载场景，同样可以对下载速度进行控制，使后台下载不至于影响前台的游戏、视频等网络体验。在安全方面，支持 https，防止内容被篡改。并且集成了 httpdns，保证了调度精准性，同时有效避免了域名劫持的发生。在防盗链的处理上，PCDN 除了继承 CDN 的 referer、鉴权策略、IP 黑名单等防盗链机制，还从云+端的角度，使 SDK 跟本地业务结合，实现鉴权逻辑、DRM 等，弥补了单纯靠云端鉴权的不足，使防盗链机制更加完善。</p><h3 id="CDN-存在的问题"><a href="#CDN-存在的问题" class="headerlink" title="CDN 存在的问题"></a>CDN 存在的问题</h3><p>传统的 CDN 技术虽然可以在一定程度上加速流媒体，实现下载、直播和点播。但是其核心仍然是基于<br>集中服务器的结构，跟地域化管制紧密相连，很难降低其扩展的成本。另外，传统 CDN 技术在高峰时期<br>对突发流量的适应性，容错性等方面仍然存在一定缺陷。随着用户规模的迅速增加，对 CDN 应用发展提出了较大挑战。因部署或租用机房带来的多方面高昂成本和管理压力，学界和业界也研究了将 P2P 技术融入 CDN 部署和管理的技术，以降低运营成本和通信时延。迅雷、优酷、百度、阿里巴巴等公司就在 2010 年代多次试水用户端运行的 P2P 众包类 CDN 服务、专用设备，模式为用户自愿以 PC 或专用设备利用闲置上行带宽充当 CDN 缓存节点，<br>提供服务并赚取积分，而积分可兑换现金红包、特定商品或服务。</p><p>P2P 技术则是打破了传统的 Client/Server 模式，是一种基于对等节点非中心化服务的平台方案。<br>P2P 技术发展迅猛，迅速改变了整个互联网传统秩序。“去中性化”符合 WEB2.0 技术潮流。特别在流媒体领域，<br>由于采用 Peer 之间对等计算的模式，大大提高了资源共享的利用率，能在较低的成本下，充分利用空闲时间分<br>发数据，避免拥塞，提供具备高实时性，和容错性能的流服务。为流媒体服务开辟了一条崭新的道路。</p><h3 id="PCDN-节点及架构"><a href="#PCDN-节点及架构" class="headerlink" title="PCDN 节点及架构"></a>PCDN 节点及架构</h3><p><img src="https://raw.githubusercontent.com/CharonChui/Pictures/master/pcdn_jiedian.png"></p><p><strong>PCDN 的基础架构</strong></p><p>关键组件</p><ul><li><p>index 服务：全局调度，把用户请求调度到最佳的机房</p></li><li><p>ZooKeeper (Global&amp;Local)：服务活动情况汇报给调度服务，动态配置更新</p></li><li><p>Nignx Proxy：支持私有协议的 Nginx 代理服务，针对不同文件一致性 Hash 到不同的 Channel 服务</p></li><li><p>Channel 服务：记录文件和拥有文件的端点地址信息，为下载提供就近的端点地址</p></li><li><p>Realy 服务：服务 P2P 建立连接和通讯</p></li><li><p>Hot 服务：hot 文件发现和推送</p></li></ul><p>PCDN 架构图：</p><p><img src="https://raw.githubusercontent.com/CharonChui/Pictures/master/pcdn_jiagou.png"></p><h3 id="P2P-简介"><a href="#P2P-简介" class="headerlink" title="P2P 简介"></a>P2P 简介</h3><p>P2P(Peer to Peer):点对点通信或称为对等联网。每个用户既下载数据，又作为服务器存储数据<br>并供其他用户下载。他的本质，是一种硬盘的共享，是把每个人电脑上的一部分硬盘，拿出来与其他人共享。</p><p>然而目前单纯的 P2P 应用亦存在它的问题，P2P 业务的盛行会带来网络流量风暴；新闻监管缺失，<br>内容版权管理真空，盗版盛行；可能导致恶性病毒；给电信运营商以及产业链造成损害。此外，层出不穷的 p2P<br>产品采用的拓扑结构、算法模型不尽相同，缺乏标准体系，应用模式也不清晰。这些问题都阻碍了 P2P 技术<br>进一步发展成为运营商级别的可靠技术平台。</p><h3 id="P2P-技术的发展演变过程"><a href="#P2P-技术的发展演变过程" class="headerlink" title="P2P 技术的发展演变过程"></a>P2P 技术的发展演变过程</h3><p>早期的 P2P 技术，称为 1.0 版本，这个版本主要是依靠 P2P 尽力而为的提供服务，没有服务质量保障。像 2000 年前后出现的迅雷、BT、电驴等 2C 的应用。这类应用是互联网上内容传播分享的工具，并没有严谨的服务质量保证，而且从技术层面来说，这样的应用都是基于终端流量的上传，需要同时读写电脑本地的磁盘。</p><p>经过几年的发展，到 2005 年左右，发展到 P2P 的 2.0 版本，这个版本的主要特征是 P2P+CDN，有了一定的服务质量保障。像风行、PPlive、PPS、优酷等视频网站，把 P2P 和 CDN 相结合，做了自建的技术方案。但是从技术实现上来讲，还是基于终端的流量互传，主要是 PC 客户端和 Flash 这两种形态。</p><p>到 2014 年以后，P2P 技术发展到了 3.0 版本，这个版本的特征就是 CDN+P2P 技术+P2P 节点资源，能提供全面的服务质量保障，性能不低于 CDN。这个时期有优酷路由宝和迅雷赚钱宝等智能硬件产品面世，吸纳用户家庭和商业场所中闲散的带宽资源，打包成 P2P 的分发服务。P2P 节点自此发展成了共享经济的模型。技术上，使用了智能硬件产品，客户端 APP 不再需要终端上传和读写磁盘。在业务场景上也支持的比较全面，长视频/短视频点播、大型赛事直播、秀场直播、大文件下载等都能完美支持。质量好，价格低，并且业务场景支持全面，这些因素促成了 P2P CDN 产品的不断发展，这个阶段积累了较大规模的商业化案例。</p><h3 id="PCDN-保证高质量的基本原理"><a href="#PCDN-保证高质量的基本原理" class="headerlink" title="PCDN 保证高质量的基本原理"></a>PCDN 保证高质量的基本原理</h3><p>CDN 对外服务是单节点、单链路的方式，这要求 CDN 节点有很高的稳定性。一旦 CDN 节点出现故障或者链路出现抖动、拥塞等，将势必影响服务质量。而 PCDN 对外服务是多点对单点、多链路的方式，这种特性使 PCDN 能够有效避免节点故障、链路网络问题带来的影响，使整个传输更加稳定。</p><p><img src="https://raw.githubusercontent.com/CharonChui/Pictures/master/pcdn_vs_cdn.png"></p><p>PCDN 对外服务时，CDN 将被当做超级种子，同时也有很多 P2P 节点提供服务。虽然单个 P2P 节点的能力弱于 CDN，但依赖数量众多的 P2P 节点和优良的调度算法，可以很好的保证整网的可靠性。CDN 在节点水位问题、稳定性、网络波动等问题将要发生之前，P2P 调度会尽可能从 P2P 节点把用户所要的内容返回给 SDK，来抑制缓冲和卡顿的情况。所以 PCDN 相对于 CDN，服务质量有所优化。</p><p>有数据显示，以视频点播业务为例，PCDN 的首播时间等同于 CDN，流畅性同比 CDN 平均提升 1~3%。在下载业务方面，PCDN 的下载速度、下载完成率等指标全面领先 CDN。</p><h3 id="四、PCDN-保证低价格的基本原理"><a href="#四、PCDN-保证低价格的基本原理" class="headerlink" title="四、PCDN 保证低价格的基本原理"></a>四、PCDN 保证低价格的基本原理</h3><p>PCDN 的带宽分为一、二、三级节点带宽，一级节点带宽为 CDN 带宽；二级节点带宽为分布全国各地 P2P 节点提供的带宽，包含接入层节点、路由器等提供的运营商/家庭出口带宽；三级带宽为客户端之间互相分享的带宽。如下图所示，各级节点能力不同，从一级 CDN 节点到三级客户端节点，根据其自身能力，按网络质量、存储容量、稳定性、计算能力、节点数量、可控性六个基本维度进行划分。其中，CDN 各方面能力是最强的，但是节点数量是最少的，成本是最高的。逐一往右推移，网络质量和存储能力、计算能力在不同程度的下降，但是节点数量在提升，成本在降低。</p><p><img src="https://raw.githubusercontent.com/CharonChui/Pictures/master/pcdn_peer.png"></p><p>所以，PCDN 在对外提供服务时，调度系统根据质量优先、兼顾成本的原则，对各级节点进行合理配比。以视频点播的业务为例，当播放器开始播放的时候，无论从用户还是从业务角度，都希望尽快拿到数据，不愿意缓冲和等待，这个时候 PCDN 默认 CDN 的响应是比较及时，调度系统首先从 CDN 上拿数据，即首帧时间与 CDN 等效。在正常播放过程中，播放器预缓冲时，播放器对数据的请求不是很着急，这时优先使用低成本的 P2P，如果 P2P 没有命中或者调度系统评估要很慢才能回传，再回源 CDN。通过这样的方法，能有效减少高成本的 CDN 用量。</p><p>通过这种方式，根据业务场景和使用量，PCDN 的价格一般比 CDN 降低 30%~50%。目前支持按日峰值带宽、月 95 峰值带宽和日流量三种计费方式。从客户的时间使用情况看，对于一个峰值带宽 30G 左右的业务，使用 PCDN 一年相比 CDN 可以节省至少 100 万。对于带宽峰值超过 100G 的业务，成本节省效果将更加可观。</p><p>PCDN 目前已支持视频点播、视频直播、大文件下载各类典型的业务场景，包括但不限于长视频点播、短视频点播、互动娱乐直播、晚会赛事直播、应用市场分发等各类产品，全面支持 Android、iOS、OTT、Flash、PC-Client 等各种主流平台和主流协议。通过在娱乐、教育、体育、广电等多个行业积累的众多成熟服务客户案例，PCDN 对各业务场景的理解与服务也不断升级优化，目前已能支持更多的下载场景、提供更好的防劫持防盗链方案和更好的视频播放体验，让质量和价格不再是矛盾体，达到高质量低成本这一超高性价比的效果，鱼和熊掌兼得。PCDN，期待为您提供更好的服务。</p><h3 id="CDN-和-P2P-技术优劣势分析"><a href="#CDN-和-P2P-技术优劣势分析" class="headerlink" title="CDN 和 P2P 技术优劣势分析"></a>CDN 和 P2P 技术优劣势分析</h3><table><thead><tr><th></th><th>CDN</th><th>P2P</th></tr></thead><tbody><tr><td>可扩展性</td><td>扩展成本较高</td><td>低成本扩展</td></tr><tr><td>内容版权</td><td>可监管</td><td>不可监管</td></tr><tr><td>用户管理有效性</td><td>可实现用户的有效管理</td><td>无法进行有效的用户管理</td></tr><tr><td>QoS 服务</td><td>可保障服务</td><td>无法保障</td></tr><tr><td>流量有序性</td><td>流量区域控制</td><td>无序无序</td></tr></tbody></table><p>也就是说，P2P 和 CDN 技术在几个关键点上，完全实现互补，如果能将两种技术有效的结合起来，<br>必然是一种更加完美的组合。于是，一种全新的思路是在 CDN 网络中，引入 P2P 技术。通过这种模式，<br>可以在不增加成本的同时有效提升 CDN 服务能力，更有效避免了 P2P 应用的诸多弊端，是在当前运营商<br>网络状况下最理想的媒体业务承载平台方案。</p><p>PCDN 的主要优势:</p><ul><li>流服务能力的提高<br>P2P 传输的内容与原 CDN 的内容有所不同，在核心节点根据 P2P 协议对内容（包括文件和流）做切片处理，<br>P2P 用户将根据这些规则来完成 P2P 共享。P2P 在边缘层的引入大大降低了边缘服务器的压力，<br>提高了文件传输和流媒体传输的效率。P2P 技术充分利用了用户的闲置上行带宽，这样运营商可以通过更少<br>的边缘服务器，提供更多的业务量为更多的用户服务，以较低成本代价应对迅猛增长的客户规模带来的挑战。</li><li>可管理的 P2P ＋ CDN 网络<br>为了避免骨干网上的流量对冲，通过集中的分布式架构，将 P2P 的流量严格限制在同一边缘节点的区域内。<br>这样就继承了 P2P 和 CDN 的优点，同时摒弃双方的缺点，避免电信骨干网上的流量无序性和风暴，<br>增强了网络的可管理性和服务高的可靠性。通过客户端，可以实现对用户的监控，流量的监管。</li><li>客户体验的改善<br>一方面，P2P+CDN 结合的方式，使得有限的服务能力可以为更多的用户提供流媒体服务。超级种子的存在保证了<br>服务质量。另一方面，P2P 技术的应用也能够更有效地防止因网络的抖动而产生对服务质量的影响。</li></ul><p>​</p><p><a href="https://dzone.com/articles/content-delivery-acceleration-and-cost-reduction-w">Content Delivery Acceleration and Cost Reduction with P2P CDN (PCDN)</a></p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;</summary>
        
      
    
    
    
    <category term="知识剖析" scheme="http://example.com/categories/%E7%9F%A5%E8%AF%86%E5%89%96%E6%9E%90/"/>
    
    
    <category term="计算机基础" scheme="http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    <category term="流媒体" scheme="http://example.com/tags/%E6%B5%81%E5%AA%92%E4%BD%93/"/>
    
    <category term="直播" scheme="http://example.com/tags/%E7%9B%B4%E6%92%AD/"/>
    
  </entry>
  
  <entry>
    <title>音视频同步原理及实现</title>
    <link href="http://example.com/2024/01/14/%E9%9F%B3%E8%A7%86%E9%A2%91%E5%90%8C%E6%AD%A5%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0/"/>
    <id>http://example.com/2024/01/14/%E9%9F%B3%E8%A7%86%E9%A2%91%E5%90%8C%E6%AD%A5%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0/</id>
    <published>2024-01-14T00:58:51.000Z</published>
    <updated>2024-01-22T01:04:59.097Z</updated>
    
    <content type="html"><![CDATA[<h1 id="音视频同步原理及实现"><a href="#音视频同步原理及实现" class="headerlink" title="音视频同步原理及实现"></a>音视频同步原理及实现</h1><p>本文主要描述音视频同步原理，及常见的音视频同步方案，并以代码示例，展示如何以音频的播放时长为基准，将视频同步到音频上以实现视音频的同步播放。内容如下：</p><ul><li>1.音视频同步简单介绍</li><li>2.DTS 和 PTS 简介<ul><li>2.1I/P/B 帧</li><li>2.2 时间戳 DTS、PTS</li></ul></li><li>3.常用同步策略</li><li>4.音视频同步简单示例代码</li></ul><h2 id="1-音视频同步简单介绍"><a href="#1-音视频同步简单介绍" class="headerlink" title="1.音视频同步简单介绍"></a>1.音视频同步简单介绍</h2><p>对于一个播放器，一般来说，其基本构成均可划分为以下几部分：<br/></p><h4>数据接收（网络/本地）->解复用->音视频解码->音视频同步->音视频输出</h4><br/>基本框架如下图所示：<p><img src="https://user-images.githubusercontent.com/87458342/127260415-01bbdcf6-d305-42fd-b83a-2c406582c6cb.png" alt="image"></p><p>为什么需要音视频同步？<br>媒体数据经过解复用流程后，音频/视频解码便是独立的，也是独立播放的。而在音频流和视频流中，其播放速度都是有相关信息指定的：</p><ul><li>视频：帧率，表示视频一秒显示的帧数。</li><li>音频：采样率，表示音频一秒播放的样本的个数。</li></ul><p><img src="https://user-images.githubusercontent.com/87458342/127260435-73a8a825-a541-429d-9f19-3d74342163d9.png" alt="image"></p><p>从帧率及采样率，即可知道视频/音频播放速度。声卡和显卡均是以一帧数据来作为播放单位，如果单纯依赖帧率及采样率来进行播放，在理想条件下，应该是同步的，不会出现偏差。<br/><br>以一个 44.1KHz 的 AAC 音频流和 24FPS 的视频流为例：<br/><br>一个 AAC 音频 frame 每个声道包含 1024 个采样点，则一个 frame 的播放时长(duration)为：(1024/44100)×1000ms = 23.22ms；一个视频 frame 播放时长(duration)为：1000ms/24 = 41.67ms。<br/><br>理想情况下，音视频完全同步，音视频播放过程如下图所示：</p><p><img src="https://user-images.githubusercontent.com/87458342/127260456-956345d3-1c17-43c9-9ac8-c70aeb8c4410.png" alt="image"></p><p>但实际情况下，如果用上面那种简单的方式，慢慢的就会出现音视频不同步的情况，要不是视频播放快了，要么是音频播放快了。可能的原因如下：</p><ol><li>一帧的播放时间，难以精准控制。音视频解码及渲染的耗时不同，可能造成每一帧输出有一点细微差距，长久累计，不同步便越来越明显。（例如受限于性能，42ms 才能输出一帧）</li><li>音频输出是线性的，而视频输出可能是非线性，从而导致有偏差。</li><li>媒体流本身音视频有差距。（特别是 TS 实时流，音视频能播放的第一个帧起点不同）</li></ol><p>所以，解决音视频同步问题，引入了时间戳：<br>首先选择一个参考时钟（要求参考时钟上的时间是线性递增的）；<br>编码时依据参考时钟上的给每个音视频数据块都打上时间戳；<br>播放时，根据音视频时间戳及参考时钟，来调整播放。<br>所以，视频和音频的同步实际上是一个动态的过程，同步是暂时的，不同步则是常态。以参考时钟为标准，放快了就减慢播放速度；播放快了就加快播放的速度。</p><p>接下来，我们介绍媒体流中时间戳的概念。</p><h2 id="2-DTS-和-PTS-简介"><a href="#2-DTS-和-PTS-简介" class="headerlink" title="2.DTS 和 PTS 简介"></a>2.DTS 和 PTS 简介</h2><h3 id="2-1I-P-B-帧"><a href="#2-1I-P-B-帧" class="headerlink" title="2.1I/P/B 帧"></a>2.1I/P/B 帧</h3><p>在介绍 DTS/PTS 之前，我们先了解 I/P/B 帧的概念。I/P/B 帧本身和音视频同步关系不大，但理解其概念有助于我们了解 DTS/PTS 存在的意义。<br>视频本质上是由一帧帧画面组成，但实际应用过程中，每一帧画面会进行压缩（编码）处理，已达到减少空间占用的目的。</p><blockquote><p>编码方式可以分为帧内编码和帧间编码。<br/><br>内编码方式：<br/><br>即只利用了单帧图像内的空间相关性，对冗余数据进行编码，达到压缩效果，而没有利用时间相关性，不使用运动补偿。所以单靠自己，便能完整解码出一帧画面。<br/><br>帧间编码：<br/><br>由于视频的特性，相邻的帧之间其实是很相似的，通常是运动矢量的变化。利用其时间相关性，可以通过参考帧运动矢量的变化来预测图像，并结合预测图像与原始图像的差分，便能解码出原始图像。<br/><br>所以，帧间编码需要依赖其他帧才能解码出一帧画面。</p></blockquote><p>由于编码方式的不同，视频中的画面帧就分为了不同的类别，其中包括：I 帧、P 帧、B 帧。I 帧、P 帧、B 帧的区别在于：</p><blockquote><ul><li>I 帧（Intra coded frames）：<br/><br>I 帧图像采用帧 I 帧使用帧内压缩，不使用运动补偿，由于 I 帧不依赖其它帧，可以独立解码。I 帧图像的压缩倍数相对较低，周期性出现在图像序列中的，出现频率可由编码器选择。</li></ul></blockquote><blockquote><ul><li>P 帧（Predicted frames）：<br/><br>P 帧采用帧间编码方式，即同时利用了空间和时间上的相关性。P 帧图像只采用前向时间预测，可以提高压缩效率和图像质量。P 帧图像中可以包含帧内编码的部分，即 P 帧中的每一个宏块可以是前向预测，也&gt;可以是帧内编码。</li></ul></blockquote><blockquote><ul><li>B 帧（Bi-directional predicted frames）：<br/><br>B 帧图像采用帧间编码方式，且采用双向时间预测，可以大大提高压缩倍数。也就是其在时间相关性上，还依赖后面的视频帧，也正是由于 B 帧图像采用了后面的帧作为参考，因此造成视频帧的传输顺序和显示顺序是不同的。</li></ul></blockquote><p>也就是说，一个 I 帧可以不依赖其他帧就解码出一幅完整的图像，而 P 帧、B 帧不行。P 帧需要依赖视频流中排在它前面的帧才能解码出图像。B 帧则需要依赖视频流中排在它前面或后面的 I/P 帧才能解码出图像。<br>对于 I 帧和 P 帧，其解码顺序和显示顺序是相同的，但 B 帧不是，如果视频流中存在 B 帧，那么就会打乱解码和显示顺序。<br>正因为解码和显示的这种非线性关系，所以需要 DTS、PTS 来标识帧的解码及显示时间。</p><h3 id="2-2-时间戳-DTS、PTS"><a href="#2-2-时间戳-DTS、PTS" class="headerlink" title="2.2 时间戳 DTS、PTS"></a>2.2 时间戳 DTS、PTS</h3><ul><li>DTS（Decoding Time Stamp）：即解码时间戳，这个时间戳的意义在于告诉播放器该在什么时候解码这一帧的数据。</li><li>PTS（Presentation Time Stamp）：即显示时间戳，这个时间戳用来告诉播放器该在什么时候显示这一帧的数据。<br>当视频流中没有 B 帧时，通常 DTS 和 PTS 的顺序是一致的。但如果有 B 帧时，就回到了我们前面说的问题：解码顺序和播放顺序不一致了，即视频输出是非线性的。<br>比如一个视频中，帧的显示顺序是：I B B P，因为 B 帧解码需要依赖 P 帧，因此这几帧在视频流中的顺序可能是：I P B B，这时候就体现出每帧都有 DTS 和 PTS 的作用了。DTS 告诉我们该按什么顺序解码这几帧图像，PTS 告诉我们该按什么顺序显示这几帧图像。顺序大概如下：</li></ul><p><img src="https://user-images.githubusercontent.com/87458342/127260671-74335624-21f5-46f1-9e1f-d29c3ee29c2b.png" alt="image"></p><p>从流分析工具看，流中 P 帧在 B 帧之前，但显示确实在 B 帧之后。</p><p><img src="https://user-images.githubusercontent.com/87458342/127260691-c371b7e0-89e5-4c7d-af9c-f7a63b6fcda7.png" alt="image"></p><p>需要注意的是：虽然 DTS、PTS 是用于指导播放端的行为，但它们是在编码的时候由编码器生成的。<br>以我们最常见的 TS 为例：</p><blockquote><p>TS 流中，PTS/DTS 信息在打流阶段生成在 PES 层，主要是在 PES 头信息里。<br/> &gt;<img src="https://user-images.githubusercontent.com/87458342/127260726-fa2dcd5c-385f-4d58-99bb-c6cace880d49.png" alt="image"><br/> &gt;<img src="https://user-images.githubusercontent.com/87458342/127260731-578367d7-9a37-42ee-ac1e-f888b2aae1c9.png" alt="image"><br/><br>标志第一位是 PTS 标识，第二位是 DTS 标识。<br/><br>标志：<br/><br>00，表示无 PTS 无 DTS；<br/><br>01，错误，不能只有 DTS 没有 PTS；<br/><br>10，有 PTS；<br/><br>11，有 PTS 和 DTS。<br/><br>PTS 有 33 位，但是它不是直接的 33 位数据，而是占了 5 个字节,PTS 分别在这 5 字节中取。<br/> &gt;<img src="https://user-images.githubusercontent.com/87458342/127260772-21de6836-16d9-4937-a8fa-589abd87c528.png" alt="image"><br/><br>TS 的 I/P 帧携带 PTS/DTS 信息，B 帧 PTS/DTS 相等，进保留 PTS；由于声音没有用到双向预测，它的解码次序就是它的显示次序，故它只有 PTS。</p></blockquote><blockquote><p>TS 的编码器中有一个系统时钟 STC（其频率是 27MHz），此时钟用来产生指示音视频的正确显示和解码时间戳。<br/><br>PTS 域在 PES 中为 33bits，是对系统时钟的 300 分频的时钟的计数值。它被编码成为 3 个独立的字段:<br/><br>PTS[32…30][29…15][14…0]。<br/><br>DTS 域在 PES 中为 33bits，是对系统时钟的 300 分频的时钟的计数值。它被编码成为 3 个独立的字段:<br/><br>DTS[32…30][29…15][14…0]。<br/><br>因此，对于 TS 流，PTS/DTS 时间基均为 1/90000 秒（27MHz 经过 300 分频）。<br/><br>PTS 对于 TS 流的意义不仅在于音视频同步，TS 流本身不携带 duration（可播放时长）信息，所以计算 duration 也是根据 PTS 得到。</p></blockquote><p>附上 TS 流解析 PTS 示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAKE_WORD(h, l) (((h) &lt;&lt; 8) | (l))</span></span><br><span class="line"><span class="comment">//packet为PES</span></span><br><span class="line"><span class="function"><span class="keyword">int64_t</span> <span class="title">get_pts</span><span class="params">(<span class="keyword">const</span> <span class="keyword">uint8_t</span> *packet)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">uint8_t</span> *p = packet;</span><br><span class="line">    <span class="keyword">if</span>(packet == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!(p[<span class="number">0</span>] == <span class="number">0x00</span> &amp;&amp; p[<span class="number">1</span>] == <span class="number">0x00</span> &amp;&amp; p[<span class="number">2</span>] == <span class="number">0x01</span>)) &#123;<span class="comment">//pes sync word</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    p += <span class="number">3</span>; <span class="comment">//jump pes sync word</span></span><br><span class="line">    p += <span class="number">4</span>; <span class="comment">//jump stream id(1) pes length(2) pes flag(1)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> pts_pts_flag = *p &gt;&gt; <span class="number">6</span>;</span><br><span class="line">    p += <span class="number">2</span>; <span class="comment">//jump pes flag(1) pes header length(1)</span></span><br><span class="line">    <span class="keyword">if</span> (pts_pts_flag &amp; <span class="number">0x02</span>) &#123;</span><br><span class="line">        <span class="keyword">int64_t</span> pts32_30, pts29_15, pts14_0, pts;</span><br><span class="line">pts32_30 = (*p) &gt;&gt; <span class="number">1</span> &amp; <span class="number">0x07</span>;</span><br><span class="line">        p += <span class="number">1</span>;</span><br><span class="line">        pts29_15 = (<span class="built_in">MAKE_WORD</span>(p[<span class="number">0</span>],p[<span class="number">1</span>])) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        p += <span class="number">2</span>;</span><br><span class="line">        pts14_0  = (<span class="built_in">MAKE_WORD</span>(p[<span class="number">0</span>],p[<span class="number">1</span>])) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        p += <span class="number">2</span>;</span><br><span class="line">        pts = (pts32_30 &lt;&lt; <span class="number">30</span>) | (pts29_15 &lt;&lt; <span class="number">15</span>) | pts14_0;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> pts;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-常用同步策略"><a href="#3-常用同步策略" class="headerlink" title="3.常用同步策略"></a>3.常用同步策略</h2><p>前面已经说了，实现音视频同步，在播放时，需要选定一个参考时钟，读取帧上的时间戳，同时根据的参考时钟来动态调节播放。现在已经知道时间戳就是 PTS，那么参考时钟的选择一般来说有以下三种：</p><ol><li>将视频同步到音频上：就是以音频的播放速度为基准来同步视频。</li><li>将音频同步到视频上：就是以视频的播放速度为基准来同步音频。</li><li>将视频和音频同步外部的时钟上：选择一个外部时钟为基准，视频和音频的播放速度都以该时钟为标准。</li></ol><p>当播放源比参考时钟慢，则加快其播放速度，或者丢弃；快了，则延迟播放。</p><p>这三种是最基本的策略，考虑到人对声音的敏感度要强于视频，频繁调节音频会带来较差的观感体验，且音频的播放时钟为线性增长，所以一般会以音频时钟为参考时钟，视频同步到音频上。<br>在实际使用基于这三种策略做一些优化调整，例如：</p><ul><li><p>调整策略可以尽量采用渐进的方式，因为音视频同步是一个动态调节的过程，一次调整让音视频 PTS 完全一致，没有必要，且可能导致播放异常较为明显。</p></li><li><p>调整策略仅仅对早到的或晚到的数据块进行延迟或加快处理，有时候是不够的。如果想要更加主动并且有效地调节播放性能，需要引入一个反馈机制，也就是要将当前数据流速度太快或太慢的状态反馈给“源”，让源去放慢或加快数据流的速度。<br><img src="https://user-images.githubusercontent.com/87458342/127260923-5e2388bb-fbe5-49c2-b12d-f8c6e02d32a8.png" alt="image"></p></li><li><p>对于起播阶段，特别是 TS 实时流，由于视频解码需要依赖第一个 I 帧，而音频是可以实时输出，可能出现的情况是视频 PTS 超前音频 PTS 较多，这种情况下进行同步，势必造成较为明显的慢同步。处理这种情况的较好方法是将较为多余的音频数据丢弃，尽量减少起播阶段的音视频差距。</p></li></ul><h2 id="4-音视频同步简单示例代码"><a href="#4-音视频同步简单示例代码" class="headerlink" title="4.音视频同步简单示例代码"></a>4.音视频同步简单示例代码</h2><p>代码参考 ffplay 实现方式，同时加入自己的修改。以 audio 为参考时钟，video 同步到音频的示例代码：</p><ol><li>获取当前要显示的 video PTS，减去上一帧视频 PTS，则得出上一帧视频应该显示的时长 delay；</li><li>当前 video PTS 与参考时钟当前 audio PTS 比较，得出音视频差距 diff；</li><li>获取同步阈值 sync_threshold，为一帧视频差距，范围为 10ms-100ms；</li><li>diff 小于 sync_threshold，则认为不需要同步；否则 delay+diff 值，则是正确纠正 delay；</li><li>如果超过 sync_threshold，且视频落后于音频，那么需要减小 delay（FFMAX(0, delay + diff)），让当前帧尽快显示。<br/><br>如果视频落后超过 1 秒，且之前 10 次都快速输出视频帧，那么需要反馈给音频源减慢，同时反馈视频源进行丢帧处理，让视频尽快追上音频。因为这很可能是视频解码跟不上了，再怎么调整 delay 也没用。</li><li>如果超过 sync_threshold，且视频快于音频，那么需要加大 delay，让当前帧延迟显示。<br/><br>将 delay*2 慢慢调整差距，这是为了平缓调整差距，因为直接 delay+diff，会让画面画面迟滞。<br/><br>如果视频前一帧本身显示时间很长，那么直接 delay+diff 一步调整到位，因为这种情况再慢慢调整也没太大意义。<br/> 7.考虑到渲染的耗时，还需进行调整。frame_timer 为一帧显示的系统时间，frame_timer+delay- curr_time，则得出正在需要延迟显示当前帧的时间。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    video-&gt;frameq.<span class="built_in">deQueue</span>(&amp;video-&gt;frame);</span><br><span class="line">    <span class="comment">//获取上一帧需要显示的时长delay</span></span><br><span class="line">    <span class="keyword">double</span> current_pts = *(<span class="keyword">double</span> *)video-&gt;frame-&gt;opaque;</span><br><span class="line">    <span class="keyword">double</span> delay = current_pts - video-&gt;frame_last_pts;</span><br><span class="line">    <span class="keyword">if</span> (delay &lt;= <span class="number">0</span> || delay &gt;= <span class="number">1.0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        delay = video-&gt;frame_last_delay;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据视频PTS和参考时钟调整delay</span></span><br><span class="line">    <span class="keyword">double</span> ref_clock = audio-&gt;<span class="built_in">get_audio_clock</span>();</span><br><span class="line">    <span class="keyword">double</span> diff = current_pts - ref_clock;<span class="comment">// diff &lt; 0 :video slow,diff &gt; 0 :video fast</span></span><br><span class="line">    <span class="comment">//一帧视频时间或10ms，10ms音视频差距无法察觉</span></span><br><span class="line">    <span class="keyword">double</span> sync_threshold = <span class="built_in">FFMAX</span>(MIN_SYNC_THRESHOLD, <span class="built_in">FFMIN</span>(MAX_SYNC_THRESHOLD, delay)) ;</span><br><span class="line"></span><br><span class="line">    audio-&gt;<span class="built_in">audio_wait_video</span>(current_pts,<span class="literal">false</span>);</span><br><span class="line">    video-&gt;<span class="built_in">video_drop_frame</span>(ref_clock,<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">isnan</span>(diff) &amp;&amp; <span class="built_in">fabs</span>(diff) &lt; NOSYNC_THRESHOLD) <span class="comment">// 不同步</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (diff &lt;= -sync_threshold)<span class="comment">//视频比音频慢，加快</span></span><br><span class="line">        &#123;</span><br><span class="line">            delay = <span class="built_in">FFMAX</span>(<span class="number">0</span>,  delay + diff);</span><br><span class="line">            <span class="keyword">static</span> <span class="keyword">int</span> last_delay_zero_counts = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(video-&gt;frame_last_delay &lt;= <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                last_delay_zero_counts++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                last_delay_zero_counts = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(diff &lt; <span class="number">-1.0</span> &amp;&amp; last_delay_zero_counts &gt;= <span class="number">10</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;maybe video codec too slow, adjust video&amp;audio\n&quot;</span>);</span><br><span class="line">                <span class="meta">#<span class="meta-keyword">ifndef</span> DORP_PACK</span></span><br><span class="line">                audio-&gt;<span class="built_in">audio_wait_video</span>(current_pts,<span class="literal">true</span>);<span class="comment">//差距较大，需要反馈音频等待视频</span></span><br><span class="line">                <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">                video-&gt;<span class="built_in">video_drop_frame</span>(ref_clock,<span class="literal">true</span>);<span class="comment">//差距较大，需要视频丢帧追上</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//视频比音频快，减慢</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (diff &gt;= sync_threshold &amp;&amp; delay &gt; SYNC_FRAMEDUP_THRESHOLD)</span><br><span class="line">            delay = delay + diff;<span class="comment">//音视频差距较大，且一帧的超过帧最常时间，一步到位</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (diff &gt;= sync_threshold)</span><br><span class="line">            delay = <span class="number">2</span> * delay;<span class="comment">//音视频差距较小，加倍延迟，逐渐缩小</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    video-&gt;frame_last_delay = delay;</span><br><span class="line">    video-&gt;frame_last_pts = current_pts;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">double</span> curr_time = <span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>&gt;(<span class="built_in">av_gettime</span>()) / <span class="number">1000000.0</span>;</span><br><span class="line">    <span class="keyword">if</span>(video-&gt;frame_timer == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        video-&gt;frame_timer = curr_time;<span class="comment">//show first frame ,set frame timer</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">double</span> actual_delay = video-&gt;frame_timer + delay - curr_time;</span><br><span class="line">    <span class="keyword">if</span> (actual_delay &lt;= MIN_REFRSH_S)</span><br><span class="line">    &#123;</span><br><span class="line">        actual_delay = MIN_REFRSH_S;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">usleep</span>(<span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(actual_delay * <span class="number">1000</span> * <span class="number">1000</span>));</span><br><span class="line">    <span class="comment">//printf(&quot;actual_delay[%lf] delay[%lf] diff[%lf]\n&quot;,actual_delay,delay,diff);</span></span><br><span class="line">    <span class="comment">// Display</span></span><br><span class="line">    <span class="built_in">SDL_UpdateTexture</span>(video-&gt;texture, &amp;(video-&gt;rect), video-&gt;frame-&gt;data[<span class="number">0</span>], video-&gt;frame-&gt;linesize[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">SDL_RenderClear</span>(video-&gt;renderer);</span><br><span class="line">    <span class="built_in">SDL_RenderCopy</span>(video-&gt;renderer, video-&gt;texture, &amp;video-&gt;rect, &amp;video-&gt;rect);</span><br><span class="line">    <span class="built_in">SDL_RenderPresent</span>(video-&gt;renderer);</span><br><span class="line">    video-&gt;frame_timer = <span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>&gt;(<span class="built_in">av_gettime</span>()) / <span class="number">1000000.0</span> ;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">av_frame_unref</span>(video-&gt;frame);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//update next frame</span></span><br><span class="line">    <span class="built_in">schedule_refresh</span>(media, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br/>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;</summary>
        
      
    
    
    
    <category term="知识剖析" scheme="http://example.com/categories/%E7%9F%A5%E8%AF%86%E5%89%96%E6%9E%90/"/>
    
    
    <category term="流媒体" scheme="http://example.com/tags/%E6%B5%81%E5%AA%92%E4%BD%93/"/>
    
    <category term="直播" scheme="http://example.com/tags/%E7%9B%B4%E6%92%AD/"/>
    
    <category term="播放" scheme="http://example.com/tags/%E6%92%AD%E6%94%BE/"/>
    
  </entry>
  
  <entry>
    <title>2024年生日有感</title>
    <link href="http://example.com/2024/01/10/2024%E5%B9%B4%E7%94%9F%E6%97%A5%E6%9C%89%E6%84%9F/"/>
    <id>http://example.com/2024/01/10/2024%E5%B9%B4%E7%94%9F%E6%97%A5%E6%9C%89%E6%84%9F/</id>
    <published>2024-01-10T15:23:23.000Z</published>
    <updated>2024-01-22T00:48:50.904Z</updated>
    
    <content type="html"><![CDATA[<h1 id="2024年生日有感"><a href="#2024年生日有感" class="headerlink" title="2024年生日有感"></a>2024年生日有感</h1><p>今天是一年一次的生日，同时也是发薪日，很高兴，晚上回来喝了点含有酒精的饮料。突然有感而发，写一下自己的感想吧</p><p>我可提前声明：我可没有喝多。这点酒量对我来说就是和水差不多。想当初人生唯二的宿醉那是真的喝多了。2斤白的有喝了一堆啤酒。第二天那难受的。<br>哈哈哈有点跑题了。</p><p>我把说实话，不关管干啥没那么多弯弯绕绕。所以我对自己看的比较通透。也就是管理，玩弄人心不适合我。我适合干技术。之前看了一个新闻说：人们总是说创造财富。然而现在其实并不是创造财富。<br>只是财富的转移。从一个地方转移到另外一个地方。这句话如果放到技术上来说也挺适合。现在的技术不过是从一个地方复制模仿到另外一个地方。现在真正创造技术的人很少了。全都是你抄抄我，我参考参考你。</p><p>其实对我来说。这并不是我想要的技术。我对我自己的职涯规划其实并不是说赚多少钱为标准。而是我要实现我自己的理想。去创造真正的技术。在荒野的大陆上开辟新的道路。这是我真正的职涯规划。</p><p>今天是我的生日，那么我就再次许一个愿望。今年为我的真正的创造技术迈出一步吧。</p><p>我不觉得我自己比较“仙”。我很“仙”吗！！！<br><img src="https://greenhaha.oss-cn-beijing.aliyuncs.com/frontend/assets/img/images.jpg" alt="我很“仙”吗"></p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;</summary>
        
      
    
    
    
    <category term="计划总结" scheme="http://example.com/categories/%E8%AE%A1%E5%88%92%E6%80%BB%E7%BB%93/"/>
    
    
    <category term="个人感想" scheme="http://example.com/tags/%E4%B8%AA%E4%BA%BA%E6%84%9F%E6%83%B3/"/>
    
  </entry>
  
  <entry>
    <title>流媒体协议-DASH</title>
    <link href="http://example.com/2024/01/05/%E6%B5%81%E5%AA%92%E4%BD%93%E5%8D%8F%E8%AE%AE-DASH/"/>
    <id>http://example.com/2024/01/05/%E6%B5%81%E5%AA%92%E4%BD%93%E5%8D%8F%E8%AE%AE-DASH/</id>
    <published>2024-01-05T02:11:51.000Z</published>
    <updated>2024-01-02T01:33:13.066Z</updated>
    
    <content type="html"><![CDATA[<h1 id="流媒体协议-DASH"><a href="#流媒体协议-DASH" class="headerlink" title="流媒体协议-DASH"></a>流媒体协议-DASH</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>除了前面讲的 Apple 的 HLS，还有 Adobe HTTP Dynamic Streaming (HDS)、Microsoft Smooth Streaming (MSS)。他们各家的协议原理大致相同，但是格式又不一样，也无法兼容，所以 Moving Picture Expert Group (MPEG) 就把大家叫到了一起，呼吁大家一起来制定一个标准的，然后就有了<a href="https://www.encoding.com/mpeg-dash/">MPEG-DASH</a>,它的主要目标是形成 IP 网络承载单一格式的流媒体并提供高效与高质量服务的统一方案，解决多制式传输方案(HTTP Live Streaming, Microsoft Smooth Streaming, HTTP Dynamic Streaming)并存格局下的存储与服务能力浪费、运营高成本与复杂度、系统间互操作弱等问题。</p><p><a href="https://mpeg.chiariglione.org/standards/mpeg-dash/">DASH(MPEG-DASH)</a>全称为 Dynamic Adaptive Streaming over HTTP.是由 MPEG 和 ISO 批准的独立于供应商的国际标准，它是一种基于 HTTP 的使用 TCP 传输协议的流媒体传输技术。它诞生的目的是为了统一标准，因此是兼容 SmoothStreaming 和 HLS 的.同时支持 TS profile 和 ISO profile，支持节目观看等级控制，支持父母锁. mpeg dash 支持的 DRM 类型包括 PlayReady 和 Marlin，而 HLS 支持的是 AES128（密钥长度为 128 位的高级加密标准 Advanced Encryption Standard）加密类型。</p><p>MPEG-DASH 是一种自适应比特率流技术，可根据实时网络状况实现动态自适应下载。和 HLS, HDS 技术类似， 都是把视频分割成一小段一小段， 通过 HTTP 协议进行传输，客户端得到之后进行播放；不同的是 MPEG-DASH 支持 MPEG-2 TS、MP4(最新的 HLS 也支持了 MP4)等多种格式, 可以将视频按照多种编码切割, 下载下来的媒体格式既可以是 ts 文件也可以是 mp4 文件，MPEG—DASH 技术与编解码器无关，可使用 H.265，H.264，VP9 等任何编解码器进行编码。</p><p>安卓平台上的 ExoPlayer 支持 MPEG-DASH。另外，三星、索尼、飞利浦、松下的一些较新型号的智能电视支持 MPEG—DASH。Google 的 Chromecast、YouTube 和 Netflix 也已支持 MPEG-DASH。</p><p><img src="https://raw.githubusercontent.com/CharonChui/Pictures/master/dash_compare.png" alt="dash_compare"></p><p>HLS 在 16 年支持了 fmp4，在 17 年支持了 4K。</p><h3 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h3><p><img src="https://raw.githubusercontent.com/CharonChui/Pictures/master/dash_main_idea.png" alt="dash_main_idea"></p><p>DASH 的核心思想是，在服务端，视频被提前编好多种码率，并且被切成固定长度的视频片段，存放到 HTTP 服务器中，当客户端播放时，通过 HTTP 请求向服务器请求视频切片，并根据网络状况的变化，请求相应质量的视频切片，从而达到对网络带宽的最大利用，并且保证播放流畅。可以实现不同画质内容无缝切换。所以在 YouTube 切换画质时完全不会黑屏，更不会影响观看。</p><p><img src="https://raw.githubusercontent.com/CharonChui/Pictures/master/a_dash_scenario.png" alt="image-20200406163508642"></p><p>DASH 的整个流程:</p><p>内容生成服务器(编码模块、封装模块) -&gt; 流媒体服务器(MPD、媒体文件、HTTP 服务器) &lt;-&gt; DASH 客户端(控制引擎、媒体引擎、HTTP 接入容器)</p><p><img src="https://raw.githubusercontent.com/CharonChui/Pictures/master/mpd_hierarchical_data.png" alt="image-20200406164238038"></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; standalone=&quot;yes&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">MPD</span> <span class="attr">id</span>=<span class="string">&quot;0564e940-122b-42bb-9d56-98f3def67247&quot;</span> <span class="attr">profiles</span>=<span class="string">&quot;urn:mpeg:dash:profile:isoff-main:2011&quot;</span> <span class="attr">type</span>=<span class="string">&quot;static&quot;</span> <span class="attr">availabilityStartTime</span>=<span class="string">&quot;2016-01-14T09:30:35.000Z&quot;</span> <span class="attr">publishTime</span>=<span class="string">&quot;2016-01-14T09:31:33.000Z&quot;</span> <span class="attr">mediaPresentationDuration</span>=<span class="string">&quot;P0Y0M0DT0H2M17.000S&quot;</span> <span class="attr">minBufferTime</span>=<span class="string">&quot;P0Y0M0DT0H0M1.000S&quot;</span> <span class="attr">bitmovin:version</span>=<span class="string">&quot;1.6.0&quot;</span> <span class="attr">xmlns:ns2</span>=<span class="string">&quot;http://www.w3.org/1999/xlink&quot;</span> <span class="attr">xmlns</span>=<span class="string">&quot;urn:mpeg:dash:schema:mpd:2011&quot;</span> <span class="attr">xmlns:bitmovin</span>=<span class="string">&quot;http://www.bitmovin.net/mpd/2015&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Period</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">AdaptationSet</span> <span class="attr">mimeType</span>=<span class="string">&quot;video/mp4&quot;</span> <span class="attr">codecs</span>=<span class="string">&quot;avc1.42c00d&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">SegmentTemplate</span> <span class="attr">media</span>=<span class="string">&quot;../video/$RepresentationID$/dash/segment_$Number$.m4s&quot;</span> <span class="attr">initialization</span>=<span class="string">&quot;../video/$RepresentationID$/dash/init.mp4&quot;</span> <span class="attr">duration</span>=<span class="string">&quot;120119&quot;</span> <span class="attr">startNumber</span>=<span class="string">&quot;0&quot;</span> <span class="attr">timescale</span>=<span class="string">&quot;30000&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Representation</span> <span class="attr">id</span>=<span class="string">&quot;1920_9000000&quot;</span> <span class="attr">bandwidth</span>=<span class="string">&quot;9000000&quot;</span> <span class="attr">width</span>=<span class="string">&quot;3840&quot;</span> <span class="attr">height</span>=<span class="string">&quot;1920&quot;</span> <span class="attr">frameRate</span>=<span class="string">&quot;30&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Representation</span> <span class="attr">id</span>=<span class="string">&quot;1080_5000000&quot;</span> <span class="attr">bandwidth</span>=<span class="string">&quot;5000000&quot;</span> <span class="attr">width</span>=<span class="string">&quot;2160&quot;</span> <span class="attr">height</span>=<span class="string">&quot;1080&quot;</span> <span class="attr">frameRate</span>=<span class="string">&quot;30&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Representation</span> <span class="attr">id</span>=<span class="string">&quot;720_3000000&quot;</span> <span class="attr">bandwidth</span>=<span class="string">&quot;3000000&quot;</span> <span class="attr">width</span>=<span class="string">&quot;1440&quot;</span> <span class="attr">height</span>=<span class="string">&quot;720&quot;</span> <span class="attr">frameRate</span>=<span class="string">&quot;30&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Representation</span> <span class="attr">id</span>=<span class="string">&quot;540_1500000&quot;</span> <span class="attr">bandwidth</span>=<span class="string">&quot;1500000&quot;</span> <span class="attr">width</span>=<span class="string">&quot;1080&quot;</span> <span class="attr">height</span>=<span class="string">&quot;540&quot;</span> <span class="attr">frameRate</span>=<span class="string">&quot;30&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Representation</span> <span class="attr">id</span>=<span class="string">&quot;360_1000000&quot;</span> <span class="attr">bandwidth</span>=<span class="string">&quot;1000000&quot;</span> <span class="attr">width</span>=<span class="string">&quot;720&quot;</span> <span class="attr">height</span>=<span class="string">&quot;360&quot;</span> <span class="attr">frameRate</span>=<span class="string">&quot;30&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">AdaptationSet</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">AdaptationSet</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span> <span class="attr">mimeType</span>=<span class="string">&quot;audio/mp4&quot;</span> <span class="attr">codecs</span>=<span class="string">&quot;mp4a.40.2&quot;</span> <span class="attr">bitmovin:label</span>=<span class="string">&quot;english stereo&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">AudioChannelConfiguration</span> <span class="attr">schemeIdUri</span>=<span class="string">&quot;urn:mpeg:dash:23003:3:audio_channel_configuration:2011&quot;</span> <span class="attr">value</span>=<span class="string">&quot;2&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">SegmentTemplate</span> <span class="attr">media</span>=<span class="string">&quot;../audio/$RepresentationID$/dash/segment_$Number$.m4s&quot;</span> <span class="attr">initialization</span>=<span class="string">&quot;../audio/$RepresentationID$/dash/init.mp4&quot;</span> <span class="attr">duration</span>=<span class="string">&quot;191472&quot;</span> <span class="attr">startNumber</span>=<span class="string">&quot;0&quot;</span> <span class="attr">timescale</span>=<span class="string">&quot;48000&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Representation</span> <span class="attr">id</span>=<span class="string">&quot;1_stereo_128000&quot;</span> <span class="attr">bandwidth</span>=<span class="string">&quot;128000&quot;</span> <span class="attr">audioSamplingRate</span>=<span class="string">&quot;48000&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">AdaptationSet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">Period</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">MPD</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="MPD"><a href="#MPD" class="headerlink" title="MPD"></a>MPD</h4><p>DASH 采用 3GPP AHS 中定义的 MPD(Media Presentation Description)作为媒体文件的描述文件（manifest），作用类似 HLS 的 m3u8 文件。MPD 文件以 XML 格式组织，用于描述 segment 的信息，比如时间、url、视频分辨率、码率等。<br>DASH 会通过 media presentation description (MPD)将视频内容切片成一个很短的文件片段，每个切片都有多个不同的码率，DASH Client 可以根据网络的情况选择一个码率进行播放，支持在不同码率之间无缝切换。<br>DASH 中的重要概念</p><h4 id="Period"><a href="#Period" class="headerlink" title="Period"></a>Period</h4><p>标注了视频的时长信息，也可以看做是更新 mpd 文件的最长时长，MPD 文件包含一个或者多个片段(Period)，它表示时间轴上的一段时间，每个片段都有一个起始时间和结束时间，并且包含了一个或者多个适配集合(Adaptation Set)。每个适配集合提供了一个或者多个媒体组件的信息，并包含了多种不同的码率。每个适配集合又是由多个呈现(Representation)组成，每个呈现就是同一个视频的不同特征的版本，如码率、分辨率等特征。由于每个的视频都要被切成固定长度的切片，因此每个呈现包括多个视频切片(Segment)，每个视频切片都有一个 URL 地址，这样客户端就可以通过这个地址向服务器发送 HTTP GET 请求获取该片段。同一个 Period 内，意味着可用的媒体内容及其各个可用码率（Representation）不会发生变更。直播情况下，“可能”需要周期地去服务器更新 MPD 文件，服务器可能会移除旧的已经过时的 Period,或是添加新的 Period。新的 Period 中可能会添加新的可用码率或去掉上一个 Period 中存在的某些码率(Representation)。</p><h4 id="Adaptation-Set"><a href="#Adaptation-Set" class="headerlink" title="Adaptation Set"></a>Adaptation Set</h4><p>包含了媒体呈现的形式，（视频/音频/字幕）。 一个 Period 由一个或者多个 Adaptationset 组成。Adaptationset 由一组可供切换的不同码率的码流（Representation)组成，这些码流中可能包含一个（ISO profile)或者多个(TS profile)media content components，因为 ISO profile 的 mp4 或者 fmp4 segment 中通常只含有一个视频或者音频内容，而 TS profile 中的 TS segment 同时含有视频和音频内容，当同时含有多个 media component content 时，每个被复用的 media content component 将被单独描述</p><h4 id="Representation"><a href="#Representation" class="headerlink" title="Representation"></a>Representation</h4><p>包含不同的码率、编码方式、帧率信息等。每个 Adaptationset 包含了一个或者多个 Representations,一个 Representation 包含一个或者多个 media streams，每个 media stream 对应一个 media content component。为了适应不同的网络带宽，实际播放的时候，视频会在一个 AdaptationSet 中的不同 Representaiton 之间切换码率，可能会从一个 Representation 切换到另外一个 Representation，会依次请求该 Representaiton 下不同 Segment 序列。</p><h4 id="Segments"><a href="#Segments" class="headerlink" title="Segments"></a>Segments</h4><p>每一个具体的片段。（1,2,4,6,10s …） Segments 可以包含任何媒体数据，关于容器，官方提供了两种建议: ISO base media file format(比如 MP4 文件格式)和 MPEG-2 Transport Stream。</p><p>每个 Representation 会划分为多个 Segment。Segment 分为 4 类，其中，最重要的是：Initialization Segment（每个 Representation 都包含 1 个 Init Seg），Media Segment（每个 Representation 的媒体内容包含若干 Media Seg）</p><ul><li><p>Initialization Segment：</p><p>Representation 的 Segments 一般都采用 1 个 Init Segment+多个普通 Segment 的方式，还有一种形式就是 Self Initialize Segment，这种形式没有单独的 Init Segment，初始化信息包括在了各个 Segment 中。Init Segment 中包含了解封装需要的全部信息，比如 Representation 中有哪些音视频流，各自的编码格式及参数。对于 ISO profile 来说(容器为 MP4)，包含了 moov box,H264 的 sps/pps 数据等关键信息存放于此（avCc box）。另外，同一个 Adaptation set 的多个 Representation 还可能共享同一个 Init Segment，该种情况下，对于 ISO profile 来说，诸如 stsd box，avCc box 等重要的 box 会含有多个 entry，每个 entry 对应一个 Representation，第一个 entry 对应第一个 Representation，第二个 entry 对应第二个 Representation，以此类推。</p></li><li><p>Subsegment</p><p>Segment 可能进一步划分为 subsegment，每个 subsegment 由数个 Acess Unit 组成，Segment index 提供了 subsegment 相对于 Segment 的字节范围和 presentation time range 。客户端可以先下载 Segment index。</p><p><code>*_init.mp4</code>: 初始的 mp4 文件，相当于视频头，在这个头文件中包含了完整的视频元信息(moov)，具体的可以使用 <code>MP4Box  -info</code> 查看。</p><p><code>*.m4s</code>: 即上面提到的 Segments 文件，每个 m4s 仅包含媒体信息 (moof + mdat)，而播放器是不能直接播放这个文件的，需要用支持 DASH 的播放器从 init 文件开始播放。</p></li></ul><p>确切的说，当 Adaptation set 的属性@segmentAlignment 为真（true）时，同一个 Adaptation set 中的多个 Representation 之中的媒体段是对齐的，因此，当从一个 Representation A 切换到另一个 Representation B 时，若 Representation A 的第 N 个媒体段已经下载完成，切换时可直接下载 Representation B 的第 N+1 个媒体段。</p><p>DASH 对媒体段定义了三种方式：</p><p>BaseURL：单段表示</p><p>SegmentList：段列表</p><p>SegmentTemplate：段模板</p><p>单段表示是最简单的：每个 Representation 只有一个媒体段。用 BaseURL 表示。举例如下：</p><h4 id="SAP-和无缝切换以及-SEEK"><a href="#SAP-和无缝切换以及-SEEK" class="headerlink" title="SAP 和无缝切换以及 SEEK"></a>SAP 和无缝切换以及 SEEK</h4><p>SAP：Stream Acess Point，可以简单理解为 I 帧，每个 Segment 的第一个帧都是 SAP，因此 Seek 时可直接 Seek 到某一个 Segment 的起始位置，利用 Init Segment+Seek 到的某个 Segment 的数据，在解封装后可实现完美解码。一般来说，同一个 Adaptation set 中的多个 Representation 是 Segment Align 的（当 Adaptation set 的属性@segmentAlignment 不为 false 时），因此，当从 Representation A 切换到 Representation B 时，如果当前 Representation A 的第 N 个 Segment 已经下载完成，切换时直接下载 Representation B 的第 N+1 个 Segment 即可。</p><p>码率自适应切换算法</p><ul><li>基于带宽的码率自适应切换算法</li><li>基于缓存的码率自适应切换算法</li></ul><p><img src="https://raw.githubusercontent.com/CharonChui/Pictures/master/dash_change_compare.png" alt="image-20200406165443536"></p><p>此基于时间缓存的码率自适应算法对网络带宽变化反应敏感，能够有效的提高平均码率，但同时码率切换次数过大，尤其是在网络状况波动很大的情况下，这势必会造成用户体验的下降。</p><ul><li><p>MSS 拥有最高的平均码率和较少的切换次数</p></li><li><p>HLS 的切换次数最少，但是以最低的平均码率作为代价</p></li><li><p>HDS 不能保证流程的播放</p></li><li><p>DASH 有足够的竞争力，也具有巨大的提升空间。</p></li></ul><h3 id="为什么使用-DASH"><a href="#为什么使用-DASH" class="headerlink" title="为什么使用 DASH"></a>为什么使用 DASH</h3><ul><li><p>DASH 支持多种编码，支持 H.265、H.264、VP9 等。</p></li><li><p>DASH 支持 MultiDRM，支持 PlayReady、Widewine，采用通用加密技术，支持终端自带 DRM，可以大幅度降低 DRM 投资成本。</p></li><li><p>DASH 支持多种文件封装，支持 MPEG-4、MPEG-2 TS。</p></li><li><p>DASH 支持多种 CDN 对接，采用相同的封装描述对接多厂家 CDN。</p></li><li><p>DASH 支持直播、点播、录制等丰富的视频特性。</p></li><li><p>DASH 支持动态码率适配 Adaptive Bitrate (ABR) ，支持多码率平滑切换。</p></li><li><p>DASH 支持缩略型描述以支持快速启动。</p></li></ul><h4 id="HLS-vs-DASH"><a href="#HLS-vs-DASH" class="headerlink" title="HLS vs DASH"></a>HLS vs DASH</h4><ul><li>在标准 HTTP 服务器上的用法： HLS 和 DASH 均可在常规 HTTP 服务器（例如 Nginx，Apache 等）上使用。</li><li>多个音频通道: 特别是对于多语言内容，重要的是能够在各个语言的不同音频通道之间进行切换。 DASH 和 HLS 都可以做到这一点。</li><li>字幕和标题: 为了给视频添加字幕，通常创建一个单独的文件，例如，文件可以具有 WebVTT 格式。然后从清单（即.m3u8 或.mpd 文件）中引用该文件。</li><li>插入广告: 通常，可以在 HLS 和 DASH 的实时流中插入广告。为此，只需交换单个视频块。 DASH 为此提供了一种有效的方法：标准化的界面允许有效地插入广告。</li><li>快速频道切换: 您可以在各个通道之间切换的速度取决于最大的子段（块）。块越小，通道更改速度越快。正如引言中已经提到的，HLS 块通常长约 10 秒，而 DASH 块通常长 2 至 4 秒。因此，DASH 在这方面领先一步。小块还具有降低代码效率的缺点。具有较小块的播放列表必须比具有较大块的播放列表更频繁地更新。这意味着包含较短视频片段的播放列表必须通过 HTTP 更频繁地更新。</li></ul><h2 id="结构与编码"><a href="#结构与编码" class="headerlink" title="结构与编码"></a><strong>结构与编码</strong></h2><p>MPEG-DASH 支持 TS 和 MP4 / ISO BMFF 媒体段。HLS 只支持 MPEG-2 TS。DASH 媒体段通常比 HLS 短，2 至 4 秒比较常见。DASH 不需要特定的编解码器。视频可以使用 H264 编码，也可以用其他编码，VP9 和 H265 也是比较受欢迎的编码。</p><p>一般而言，与 HLS 相比，DASH 可以提供实质上更低的端对端延迟。这对于现场直播的工作流程很重要。此外， MPEG-DASH 的基于模板的 MPD 不需要更新，可以在网络边缘服务器进行缓存，HLS 则需要周期性地更新传播多次。</p><p>DASH 支持索引和基于时间的模版，播放器能够基于公开的时钟，如 NTPS，进行同步。这对于多相机的情况下，多个播放器之间同步会比较容易。</p><h2 id="DRM"><a href="#DRM" class="headerlink" title="DRM"></a><strong>DRM</strong></h2><p>DASH 和 HLS 之间的另一个关键区别是它支持 DRM。可是，在 DASH 中不存在一个单一通用的 DRM 解决方案。例如，Google 的 Chrome 支持 Widevine，而 Microsoft 的 Internet Explorer 支持 PlayReady。然而，通过使用 MPEG-CENC（MPEG 通用加密）结合加密媒体扩展（EME），视频流内容可以仅被加密一次。HLS 支持 AES-128 加密，以及苹果自己的 DRM，Fairplay。</p><h4 id="测试流"><a href="#测试流" class="headerlink" title="测试流"></a>测试流</h4><ul><li><p>HEVC HLS with fMP4: <a href="https://bitmovin-a.akamaihd.net/content/dataset/multi-codec/hevc/stream_fmp4.m3u8">http://bitmovin-a.akamaihd.net/content/dataset/multi-codec/hevc/stream_fmp4.m3u8</a></p></li><li><p>HEVC HLS with TS (not supported by Apple): <a href="https://bitmovin-a.akamaihd.net/content/dataset/multi-codec/hevc/stream_ts.m3u8">http://bitmovin-a.akamaihd.net/content/dataset/multi-codec/hevc/stream_ts.m3u8</a></p><p><a href="https://bitmovin-a.akamaihd.net/content/playhouse-vr/m3u8s/105560.m3u8">https://bitmovin-a.akamaihd.net/content/playhouse-vr/m3u8s/105560.m3u8</a></p></li><li><p>HEVC MPEG-DASH: <a href="https://bitmovin-a.akamaihd.net/content/dataset/multi-codec/hevc/stream.mpd">http://bitmovin-a.akamaihd.net/content/dataset/multi-codec/hevc/stream.mpd</a></p></li><li><p>Multi-Codec MPEG-DASH (AVC/H.264, HEVC/H.265, VP9): <a href="http://bitmovin-a.akamaihd.net/content/dataset/multi-codec/stream.mpd">http://bitmovin-a.akamaihd.net/content/dataset/multi-codec/stream.mpd</a></p><p><a href="https://bitmovin-a.akamaihd.net/content/playhouse-vr/mpds/105560.mpd">https://bitmovin-a.akamaihd.net/content/playhouse-vr/mpds/105560.mpd</a></p></li><li><p>VP9 MPEG-DASH: <a href="http://bitmovin-a.akamaihd.net/content/dataset/multi-codec/stream_vp9.mpd">http://bitmovin-a.akamaihd.net/content/dataset/multi-codec/stream_vp9.mpd</a></p></li></ul><p>参考:</p><ul><li><a href="http://telestreamblog.telestream.net/2017/05/what-is-abr/">HLS，MPEG-DASH - What is ABR?</a></li><li><a href="https://www.bilibili.com/read/cv855111">B 站我们为什么使用 DASH</a></li><li><a href="https://strivecast.io/hls-vs-mpeg-dash/">Adaptive HTTP Streaming Technologies: HLS vs. DASH</a></li><li><a href="https://blog.csdn.net/nonmarking/article/details/86351147">自适应流媒体传输</a></li></ul><p>在线测试播放器:</p><p><a href="http://demo.theoplayer.com/test-your-stream-with-statistics">http://demo.theoplayer.com/test-your-stream-with-statistics</a></p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;</summary>
        
      
    
    
    
    <category term="知识剖析" scheme="http://example.com/categories/%E7%9F%A5%E8%AF%86%E5%89%96%E6%9E%90/"/>
    
    
    <category term="流媒体" scheme="http://example.com/tags/%E6%B5%81%E5%AA%92%E4%BD%93/"/>
    
    <category term="直播" scheme="http://example.com/tags/%E7%9B%B4%E6%92%AD/"/>
    
  </entry>
  
  <entry>
    <title>2023 总结</title>
    <link href="http://example.com/2024/01/01/2023%E6%80%BB%E7%BB%93/"/>
    <id>http://example.com/2024/01/01/2023%E6%80%BB%E7%BB%93/</id>
    <published>2024-01-01T04:05:22.000Z</published>
    <updated>2024-01-02T01:12:08.502Z</updated>
    
    <content type="html"><![CDATA[<h1 id="2023-总结"><a href="#2023-总结" class="headerlink" title="2023 总结"></a>2023 总结</h1><p>打开笔记本电脑面对着屏幕不禁陷入沉思，2023 年我该总结点啥呢。写一点再删一点断断续续。但是脑袋里一直有一个很模糊的景象，在告诉我你要去做，你必须要去做。<br>这个情况怎么说呢，已经持续 3 年多了，但是在我被面包车剐蹭之后，这个模糊的场景变得清晰了，但是还是依旧很模糊。每次当我用手机看一些新闻或者相关视频的时候，脑子里一直有一个声音一直在告诉要去做。一定要去做。<br>哈哈哈，可能这么说很魔幻，可能被人认为这个人是不是有病。说实话我也不知道我自己为什么会这样。有时候晚上躺在床上一直在想为什么会这样，为什么。在过去的一年里，我一直断断续续一直在想这个问题。为什么，为什么。有时候我会用忙碌的工作迫使自己不去可以注意这个问题。但是到最后还是在想这个问题。脑子里的那个声音总是断断续续告诉自己。你要去做。必须要去做。就好像我的身体和我的精神是割裂开的。我是缺少什么东西了吗。不知道，不清楚。</p><p>每次当我会的更多的时候，脑子里的声音就越强烈。而且这一年，也不能说这一年而是这最近一两年，每晚的做梦一直梦到自己的小学，初中，高中场景，或者一些相关的人。为什么，不知道。每次在梦中我都清晰的知道我自己已经毕业了，已经有工作了，但是已经还是梦到自己小初高学校的一些人或者事情。我这是念旧吗？不知道！不清楚。<del>有点说多了</del></p><p>该把话题扯回来了。想一想自己进入这个行业时间也蛮长的了。想当初在大学社团的时候，写一个 html 的颜色标签都不会到现在想一想。内心一阵苦笑。2023 年这一年，说轻松吧也不轻松，但是也不至于加班那种。这就给我了很多时间来归纳总结我自己的知识体系。前几年说实话自己学的蛮多的。但是归纳成自己的文档的蛮少的，今年的博客文档也没怎么更新。明明自己私下写了很多知识整理的内容。但是一直没有更新到自己的博客。可能这就是自己的拖延症吧。</p><p>说些很神奇的事情，有些时候我自己自学的一些新技术新内容，在有些时候很神奇的就会在某些项目中应用，这些新东西，或很长时间或者很短时间，就被新的项目提案中，列为必备技能或者技术。我有时候我都很佩服我自己。你说这个发生 1 次 2 次是偶然吧，关键是这种神奇的事情发生了很多次 2 只手都数不过来了。太神奇了。 <del>我可不是自卖自夸，请叫我先知先生 阿哈哈哈哈哈</del></p><p>看着自己写了这么多的内容，越看越像自己写的日记。无所谓了，总结和日记也差不多了，洒洒水啦，😂。我可不是偷懒哦，<strong>哦</strong>！<strong>哦</strong>！<strong>哦！</strong>。</p><p>一般来说有了总结就会有展望。那就写一点这一年我自己的计划吧。<br>首先：</p><ol><li><strong>体重减下来。</strong><br>今年是认真的，虽然前几年也减下来过，但是因为疫情也不能说怪疫情，也是因为自己松懈了，今年真的要把体重减下来。</li><li>看看有没有机会去日本出差。这个说实话我是真的挺想去日本去出差试试。<del>我可没有私心，我可不会承认我是一个老二次元了</del></li><li>技术方面的话保密。目前我自己有几个研究大概方向。但是没有具体想象，需要点时间。</li></ol><p>好了就写这么多了，这才是元旦，2024 第一天，等到春节我会更新自己的具体计划的敬请谅解！！！</p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;</summary>
        
      
    
    
    
    <category term="计划总结" scheme="http://example.com/categories/%E8%AE%A1%E5%88%92%E6%80%BB%E7%BB%93/"/>
    
    
    <category term="2023" scheme="http://example.com/tags/2023/"/>
    
    <category term="反省总结" scheme="http://example.com/tags/%E5%8F%8D%E7%9C%81%E6%80%BB%E7%BB%93/"/>
    
    <category term="企划" scheme="http://example.com/tags/%E4%BC%81%E5%88%92/"/>
    
    <category term="未来计划" scheme="http://example.com/tags/%E6%9C%AA%E6%9D%A5%E8%AE%A1%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>直播原理</title>
    <link href="http://example.com/2022/04/23/%E7%9B%B4%E6%92%AD%E5%8E%9F%E7%90%86%E4%B8%8E/"/>
    <id>http://example.com/2022/04/23/%E7%9B%B4%E6%92%AD%E5%8E%9F%E7%90%86%E4%B8%8E/</id>
    <published>2022-04-23T02:11:51.000Z</published>
    <updated>2024-01-02T01:12:08.529Z</updated>
    
    <content type="html"><![CDATA[<h1 id="直播原理与web直播实战"><a href="#直播原理与web直播实战" class="headerlink" title="直播原理与web直播实战"></a>直播原理与web直播实战</h1><h2 id="直播构成"><a href="#直播构成" class="headerlink" title="直播构成"></a>直播构成</h2><p><img src="http://greenhaha.oss-cn-beijing.aliyuncs.com/frontend/assets/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202022-04-23%20202423.png" alt="直播构成"></p><h2 id="直播流程"><a href="#直播流程" class="headerlink" title="直播流程"></a>直播流程</h2><p>视频直播可以分为采集，前处理，编码，传输，解码，渲染 这几个环节。</p><h3 id="采集"><a href="#采集" class="headerlink" title="采集"></a>采集</h3><p>一般是由客户端（IOS、安卓、PC或其它工具，如OBS）完成的，iOS是比较简单的，Android则要做些机型适配工作，PC最麻烦各种奇葩摄像头驱动</p><h3 id="前处理"><a href="#前处理" class="headerlink" title="前处理"></a>前处理</h3><p>主要是处理直播美颜，美颜算法需要用到GPU编程，需要懂图像处理算法的人，没有好的开源实现，要自己参考论文去研究。难点不在于美颜效果，而在于GPU占用和美颜效果之间找平衡。</p><h3 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h3><p>肯定要采用硬编码，软编码720p完全没希望，勉强能编码也会导致CPU过热烫到摄像头。编码要在分辨率，帧率，码率，GOP等参数设计上找到最佳平衡点。</p><h3 id="传输"><a href="#传输" class="headerlink" title="传输"></a>传输</h3><p>一般交给了CDN服务商。</p><h3 id="解码"><a href="#解码" class="headerlink" title="解码"></a>解码</h3><p>是对之前编码的操作，进行解码，在web里需要解码是HLS。</p><h3 id="渲染"><a href="#渲染" class="headerlink" title="渲染"></a>渲染</h3><p>主要用播放器来解决，web中常用到的播放器有 video.js ，目前我们使用是腾讯云播放器。</p><p>其实一个完成直播，远远不上面这几个环节，下面是腾讯云直播方案的整个流程图：</p><p><img src="http://greenhaha.oss-cn-beijing.aliyuncs.com/frontend/assets/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202022-04-23%20203038.png" alt="腾讯云"></p><h2 id="web中直播技术"><a href="#web中直播技术" class="headerlink" title="web中直播技术"></a>web中直播技术</h2><p>目前互联网上web做直播，主要是展示，主流web展示的话可能涉及到HLS跟RTMP这两个东西，现在我们重点讲解hls跟RTMP协议。</p><h3 id="HLS"><a href="#HLS" class="headerlink" title="HLS"></a>HLS</h3><p>HLS（HTTP Live Streaming全称）是一个基于HTTP的视频流协议，由Apple公司实现，Mac OS上的QuickTime、Safari 以及iOS上的 Safari都能很好的支持 HLS，高版本 Android 也增加了对 HLS 的支持。<br>一些常见的客户端如：MPlayerX、VLC 也都支持HLS协议，如果需要在chrome上播放，需要使用 <a href="https://link.juejin.cn/?target=https://github.com/videojs/videojs-contrib-hls">videojs-contrib-hls.js</a> 解析。<br><img src="http://greenhaha.oss-cn-beijing.aliyuncs.com/frontend/assets/img/1626023bd565d932_tplv-t2oaga2asx-zoom-in-crop-mark_1304_0_0_0.awebp" alt="HLS工作流程图"></p><h2 id="Server服务器"><a href="#Server服务器" class="headerlink" title="Server服务器"></a>Server服务器</h2><p>HLS的服务器组件负责获取的媒体输入流 , 然后Media编码后 MPEG-4（H.264 video 和 AAC audio）格式然后用硬件打包到 MPEG-2 (MPEG-2 transport stream)的传输流中。图中显示,传输流会经过stream segmenter, 这里的工作是MPEG-2传输流会被分散为小片段然后保存为一个或多个系列的 .ts 格式的媒体文件。这个过程需要借助编码工具来完成，比如 Apple stream segmenter。<br>(视频类是.ts文件,纯音频会被编码为一些音频小片段，通常为 ADTS头的AAC、MP3、或者 AC-3格式。)<br>服务端可以采用硬件编码和软件编码两种形式，其功能都是按照上文描述的规则对现有的媒体文件进行切片并使用索引文件进行管理。而软件切片通常会使用 Apple 公司提供的工具或者第三方的集成工具。</p><h2 id="Distribution分配组件"><a href="#Distribution分配组件" class="headerlink" title="Distribution分配组件"></a>Distribution分配组件</h2><p>同时上面提到的那个切片器（segmenter）也会创建一个索引文件，通常会包含这些媒体文件的一个列表，也能包含元数据。它一般都是一个个.M38U的列表。列表元素会关联一个 URL 用于客户端访问。然后按序去请求这些 URL。</p><p><img src="http://greenhaha.oss-cn-beijing.aliyuncs.com/frontend/assets/img/1626032618b54942_tplv-t2oaga2asx-zoom-in-crop-mark_1304_0_0_0.awebp" alt="索引文件结构图"></p><h3 id="主索引文件"><a href="#主索引文件" class="headerlink" title="主索引文件"></a>主索引文件</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#EXTM3U</span><br><span class="line">#EXT-X-STREAM-INF:PROGRAM-ID=1,BANDWIDTH=409037,RESOLUTION=416x234,CODECS=&quot;mp4a.40.2, avc1.42001e&quot;</span><br><span class="line">Gear1/prog_index.m3u8</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>第一行：<strong>#EXTM3U</strong></p><p>每个M3U文件第一行必须是这个tag，起标示作用</p><p>第二行：<strong>#EXT-X-STREAM-INF</strong></p><p>标签的属性列表中直接指明当前流是VIDEO还是AUDIO</p><p>包含属性 :</p><ul><li>BANDWIDTH 指定码率</li><li>PROGRAM-ID 唯一ID (这个属性在后面的协议版本废除了)</li><li>CODECS 指定流的编码类型</li><li>RESOLUTION：分辨率</li></ul><h3 id="子索引文件"><a href="#子索引文件" class="headerlink" title="子索引文件"></a>子索引文件</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#EXTM3U</span><br><span class="line">#EXT-X-TARGETDURATION:11</span><br><span class="line">#EXT-X-VERSION:3</span><br><span class="line">#EXT-X-MEDIA-SEQUENCE:0</span><br><span class="line">#EXT-X-PLAYLIST-TYPE:VOD</span><br><span class="line">#EXTINF:10.133333,</span><br><span class="line">fileSequence0.ts</span><br><span class="line">#EXTINF:10.000666,</span><br><span class="line">fileSequence1.ts</span><br><span class="line">#EXTINF:10.667334,</span><br><span class="line">fileSequence2.ts</span><br><span class="line">#EXTINF:9.686001,</span><br><span class="line">fileSequence3.ts</span><br><span class="line">#EXTINF:9.768665,</span><br><span class="line">fileSequence4.ts</span><br><span class="line">#EXTINF:10.000000,</span><br><span class="line">fileSequence5.ts</span><br><span class="line">#EXT-X-ENDLIST</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>#EXTM3U</strong> m3u文件头，必须放在第一行。<br><strong>#EXT-X-TARGETDURATION</strong> 每个分片TS的最大的时长。<br><strong>#EXT-X-VERSION</strong> 用以标示协议版本。<br><strong>#EXT-X-MEDIA-SEQUENCE</strong> TS分片的序列号。<br><strong>#EXT-X-PLAYLIST-TYPE</strong> 提供关于PlayList的可变性的信息， 这个对整个PlayList文件有效，是可选的。<br><strong>#EXTINF</strong> extra info，分片TS的信息，如时长，带宽等。</p><h3 id="主索引文件与子索引文件的区别"><a href="#主索引文件与子索引文件的区别" class="headerlink" title="主索引文件与子索引文件的区别"></a>主索引文件与子索引文件的区别</h3><ul><li>主索引文件和子索引文件都是.M3U8的playlist</li><li>主索引文件只需下载一次，但对于直播节目子索引文件定期重新加载</li></ul><h2 id="client客户端"><a href="#client客户端" class="headerlink" title="client客户端"></a>client客户端</h2><p>分配组件由标准的网络服务器。他们负责接受Client客户端请求并提供相关联的资源给客户端。</p><h3 id="videojs-contrib-hls-js组件解析过程"><a href="#videojs-contrib-hls-js组件解析过程" class="headerlink" title="videojs-contrib-hls.js组件解析过程"></a>videojs-contrib-hls.js组件解析过程</h3><p><img src="http://greenhaha.oss-cn-beijing.aliyuncs.com/frontend/assets/img/16260382981ee008_tplv-t2oaga2asx-zoom-in-crop-mark_1304_0_0_0.awebp" alt="videojs-contrib-hls.js解析图"></p><p>HLS简单讲就是把整个流分成一个个小的片段，基于 HTTP 的文件来下载，每次只下载一小部分。<br>前面提到了用于 H5 播放直播视频时引入的一个 .m3u8 的文件，这个文件就是基于 HLS 协议，存放视频流元数据的文件。<br>每一个 .m3u8 文件，分别对应若干个 ts 文件，这些 ts 文件才是真正存放视频的数据，m3u8 文件只是存放了一些 ts 文件的配置信息和相关路径，当视频播放时，.m3u8 是动态改变的，再通过解析器（videojs-contrib-hls.js）解析这个文件，并找到对应的 ts 文件来播放，所以一般为了加快速度，.m3u8 放在 web 服务器上，ts 文件放在 cdn 上。</p><h2 id="RTMP"><a href="#RTMP" class="headerlink" title="RTMP"></a>RTMP</h2><p>Real Time Messaging Protocol（简称 RTMP）是 Macromedia 开发的一套视频直播协议，现在属于 Adobe。这套方案需要搭建专门的 RTMP 流媒体服务如 Adobe Media Server，并且在浏览器中只能使用 Flash 实现播放器。它的实时性非常好，延迟很小，但无法支持移动端 WEB 播放是它的硬伤。<br>浏览器端，HTML5 video标签无法播放 RTMP 协议的视频，可以通过 video.js 来实现。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">&quot;http://vjs.zencdn.net/5.8.8/video-js.css&quot;</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;<span class="name">video</span> <span class="attr">id</span>=<span class="string">&quot;example_video_1&quot;</span> <span class="attr">class</span>=<span class="string">&quot;video-js vjs-default-skin&quot;</span> <span class="attr">controls</span> <span class="attr">preload</span>=<span class="string">&quot;auto&quot;</span> <span class="attr">width</span>=<span class="string">&quot;640&quot;</span> <span class="attr">height</span>=<span class="string">&quot;264&quot;</span> <span class="attr">loop</span>=<span class="string">&quot;loop&quot;</span> <span class="attr">webkit-playsinline</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">&quot;rtmp://10.14.221.17:1935/rtmplive/home&quot;</span> <span class="attr">type</span>=<span class="string">&#x27;rtmp/flv&#x27;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">video</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;http://vjs.zencdn.net/5.8.8/video.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">videojs.options.flash.swf = <span class="string">&#x27;video.swf&#x27;</span>;</span></span><br><span class="line"><span class="javascript">videojs(<span class="string">&#x27;example_video_1&#x27;</span>).ready(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript"><span class="built_in">this</span>.play();</span></span><br><span class="line"><span class="javascript">&#125;);</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="HLS-VS-RTMP-优缺点对比"><a href="#HLS-VS-RTMP-优缺点对比" class="headerlink" title="HLS VS RTMP 优缺点对比"></a>HLS VS RTMP 优缺点对比</h2><table><thead><tr><th><strong>协议</strong></th><th><strong>原理</strong></th><th><strong>延时</strong></th><th><strong>优点</strong></th><th><strong>缺点</strong></th><th><strong>使用场景</strong></th></tr></thead><tbody><tr><td>HLS(http)</td><td>集合一段时间数据生成ts切片文件更m3u8文件</td><td>10s-30s</td><td>跨平台</td><td>延时性高</td><td>移动端</td></tr><tr><td>RTMP(TCP)</td><td>每个时刻的数据收到后立即发送</td><td>2s</td><td>延时低、实时性好</td><td>跨平台差</td><td>PC+直播+实时性要求高+互动性强</td></tr></tbody></table>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;</summary>
        
      
    
    
    
    <category term="知识剖析" scheme="http://example.com/categories/%E7%9F%A5%E8%AF%86%E5%89%96%E6%9E%90/"/>
    
    
    <category term="直播" scheme="http://example.com/tags/%E7%9B%B4%E6%92%AD/"/>
    
    <category term="chromeAPI" scheme="http://example.com/tags/chromeAPI/"/>
    
  </entry>
  
  <entry>
    <title>express-session 原理</title>
    <link href="http://example.com/2022/03/16/express-session/"/>
    <id>http://example.com/2022/03/16/express-session/</id>
    <published>2022-03-16T13:35:36.000Z</published>
    <updated>2024-01-02T01:12:08.503Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Express-session解析"><a href="#Express-session解析" class="headerlink" title="Express-session解析"></a>Express-session解析</h2><h3 id="session-是什么"><a href="#session-是什么" class="headerlink" title="session 是什么"></a>session 是什么</h3><p>ession一般译作会话，牛津词典对其的解释是进行某活动连续的一段时间。在web应用的用户看来，session是另一种记录客户状态的机制，不同的是Cookie保存在客户端浏览器中，而session保存在服务器上。<br>客户端浏览器访问服务器的时候，服务器把客户端信息以某种形式记录在服务器上.客户端浏览器再次访问时只需要从该Session中查找该客户的状态就可以了。</p><blockquote><p>Session是有状态的，而HTTP协议是无状态的，二者是否矛盾呢？</p></blockquote><p>Session和HTTP协议属于<code>不同层面的事物</code>，HTTP属于ISO七层模型的最高层<code>应用层</code>，<strong>前者Session不属于后者</strong>，前者HTTP是具体的动态页面技术来实现的，但同时它又是<strong>基于后者的</strong>。</p><h3 id="Session的原理：摘录"><a href="#Session的原理：摘录" class="headerlink" title="Session的原理：摘录"></a>Session的原理：摘录</h3><p>基本原理是服务端为每一个session维护一份会话信息数据, 而客户端和服务端依靠一个全局唯一的标识来访问会话信息数据。用户访问web应用时，服务端程序决定何时创建session，创建session可以概括为三个步骤：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. 生成全局唯一标识符（sessionid）；</span><br><span class="line">2. 开辟数据存储空间。一般会在内存中创建相应的数据结构，但这种情况下，系统一旦掉电，所有的会话数据就会丢失，如果是电子商务网站，这种事故会造成严重的后果。不过也可以写到文件里甚至存储在数据库中，这样虽然会增加I/O开销，但session可以实现某种程度的持久化，而且更有利于session的共享；</span><br><span class="line">3. 将session的全局唯一标示符发送给客户端。</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>问题的关键就在<strong>服务端如何发送这个session的唯一标识上</strong>。联系到HTTP协议，数据无非可以放到请求行、头域或Body里，基于此，一般来说会有两种常用的方式：<code>cookie</code>和<code>URL重写</code>。</p><h3 id="session和cookie-优缺点和各自的应用场景："><a href="#session和cookie-优缺点和各自的应用场景：" class="headerlink" title="session和cookie 优缺点和各自的应用场景："></a>session和cookie 优缺点和各自的应用场景：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">1.   应用场景</span><br><span class="line">Cookie的典型应用场景是Remember Me服务，即用户的账户信息通过cookie的形式保存在客户端，当用户再次</span><br><span class="line">请求匹配的URL的时候，账户信息会被传送到服务端，交由相应的程序完成自动登录等功能。当然也可以保存</span><br><span class="line">一些客户端信息，比如页面布局以及搜索历史等等。</span><br><span class="line">Session的典型应用场景是用户登录某网站之后，将其登录信息放入session，在以后的每次请求中查询相应</span><br><span class="line">的登录信息以确保该用户合法。当然还是有购物车等等经典场景；</span><br><span class="line">2.   安全性</span><br><span class="line">cookie将信息保存在客户端，如果不进行加密的话，无疑会暴露一些隐私信息，安全性很差，一般情况下敏</span><br><span class="line">感信息是经过加密后存储在cookie中，但很容易就会被窃取。而session只会将信息存储在服务端，如果存</span><br><span class="line">储在文件或数据库中，也有被窃取的可能，只是可能性比cookie小了太多。</span><br><span class="line">Session安全性方面比较突出的是存在会话劫持的问题，这是一种安全威胁。总体来讲，session的安全性</span><br><span class="line">要高于cookie；</span><br><span class="line">3.   性能</span><br><span class="line">Cookie存储在客户端，消耗的是客户端的I/O和内存，而session存储在服务端，消耗的是服务端的资源。</span><br><span class="line">但是session对服务器造成的压力比较集中，而cookie很好地分散了资源消耗，就这点来说，cookie是要优于session的；</span><br><span class="line">4.   时效性</span><br><span class="line">Cookie可以通过设置有效期使其较长时间内存在于客户端，而session一般只有比较短的有效期（用户主动销毁</span><br><span class="line">session或关闭浏览器后引发超时）；</span><br><span class="line">5.   其他</span><br><span class="line">Cookie的处理在开发中没有session方便。而且cookie在客户端是有数量和大小的限制的，而session的大小</span><br><span class="line">却只以硬件为限制，能存储的数据无疑大了太多。</span><br></pre></td></tr></table></figure><p>Session工作的大致步骤</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1. 用户提交包含用户名和密码的表单，发送HTTP请求。</span><br><span class="line">2. 服务器验证用户发来的用户名密码。</span><br><span class="line">3. 如果正确则把当前用户名（通常是用户对象）存储到redis中，并生成它在redis中的ID。</span><br><span class="line">    这个ID称为Session ID，通过Session ID可以从Redis中取出对应的用户对象， 敏感数据（比如authed=true）都存储在这个用户对象中。</span><br><span class="line">4. 设置Cookie为sessionId=xxxxxx|checksum并发送HTTP响应， 仍然为每一项Cookie都设置签名。</span><br><span class="line">5. 用户收到HTTP响应后，便看不到任何敏感数据了。在此后的请求中发送该Cookie给服务器。</span><br><span class="line">6. 服务器收到此后的HTTP请求后，发现Cookie中有SessionID，进行放篡改验证。</span><br><span class="line">7. 如果通过了验证，根据该ID从Redis中取出对应的用户对象， 查看该对象的状态并继续执行业务逻辑。</span><br></pre></td></tr></table></figure><h2 id="express-session中间件"><a href="#express-session中间件" class="headerlink" title="express-session中间件"></a>express-session中间件</h2><p>express-session中间件将会话数据存储在服务器上；它仅将会话标识（而非会话数据）保存在 cookie 中。从1.5.0版本开始, express-session不再依赖<code>cookie-parser</code>,直接通过<code>req/res</code>读取/写入;默认存储位置<code>内存存储</code>(服务器端),</p><p>安装:  <code>npm install express-session</code></p><p>主要方法 : <strong>session(options)</strong></p><p>通过option来设置session存储，除了session ID外，session中的任何数据都不存储在cookie中。<br>options可选参数:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">1. name - cookie的名字（原属性名为 key）。（默认：’connect.sid’）</span><br><span class="line">2. store - session存储实例</span><br><span class="line">3. secret - 用它来对session cookie签名，防止篡改</span><br><span class="line">4. cookie - session cookie设置 （默认：&#123; path: ‘/‘, httpOnly: true,secure: false, maxAge: null &#125;）</span><br><span class="line">5. genid - 生成新session ID的函数 （默认使用uid2库）</span><br><span class="line">6. rolling - 在每次请求时强行设置cookie，这将重置cookie过期时间（默认：false）</span><br><span class="line">7. resave - 强制保存session即使它并没有变化 （默认： true）</span><br><span class="line">8. proxy - 当设置了secure cookies（通过”x-forwarded-proto” header ）时信任反向代理。当设定为true时，</span><br><span class="line">”x-forwarded-proto” header 将被使用。当设定为false时，所有headers将被忽略。当该属性没有被设定时，将使用Express的trust proxy。</span><br><span class="line">9. saveUninitialized - 强制将未初始化的session存储。当新建了一个session且未设定属性或值时，它就处于</span><br><span class="line">未初始化状态。在设定一个cookie前，这对于登陆验证，减轻服务端存储压力，权限控制是有帮助的。（默认：true）</span><br><span class="line">10. unset - 控制req.session是否取消（例如通过 delete，或者将它的值设置为null）。这可以使session保持存储</span><br><span class="line">状态但忽略修改或删除的请求（默认：keep）</span><br></pre></td></tr></table></figure><h3 id="express-session的一些方法"><a href="#express-session的一些方法" class="headerlink" title="express-session的一些方法:"></a>express-session的一些方法:</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. Session.destroy():删除session，当检测到客户端关闭时调用。</span><br><span class="line">2. Session.reload():当session有修改时，刷新session。</span><br><span class="line">3. Session.regenerate()：将已有session初始化。</span><br><span class="line">4. Session.save()：保存session。</span><br></pre></td></tr></table></figure><h3 id="内存存储-方式实例代码"><a href="#内存存储-方式实例代码" class="headerlink" title="内存存储 方式实例代码:"></a>内存存储 方式实例代码:</h3><p>一旦我们将express-session中间件用use挂载后，我们可以很方便的通过req参数来存储和访问session对象的数据。req.session是一个JSON格式的JavaScript对象，我们可以在使用的过程中随意的增加成员，这些成员会自动的被保存到option参数指定的地方，默认即为内存中去。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">var express = require(&#x27;express&#x27;);</span><br><span class="line">var session = require(&#x27;express-session&#x27;);</span><br><span class="line">var app = express();// Use the session middleware </span><br><span class="line">app.use(session(&#123; </span><br><span class="line">////这里的name值得是cookie的name，默认cookie的name是：connect.sid</span><br><span class="line">  //name: &#x27;hhw&#x27;,</span><br><span class="line">  secret: &#x27;keyboard cat&#x27;, </span><br><span class="line">  cookie: (&#x27;name&#x27;, &#x27;value&#x27;, &#123; path: &#x27;/&#x27;, httpOnly: true,secure: false, maxAge:  60000 &#125;),  //重新保存：强制会话保存即使是未修改的。默认为true但是得写上</span><br><span class="line">  resave: true, </span><br><span class="line">  //强制“未初始化”的会话保存到存储。 </span><br><span class="line">  saveUninitialized: true,  </span><br><span class="line">  </span><br><span class="line">&#125;))</span><br><span class="line">// 只需要用express app的use方法将session挂载在‘/’路径即可，这样所有的路由都可以访问到session。//可以给要挂载的session传递不同的option参数，来控制session的不同特性 </span><br><span class="line">app.get(&#x27;/&#x27;, function(req, res, next) &#123;  </span><br><span class="line">var sess = req.session//用这个属性获取session中保存的数据，而且返回的JSON数据</span><br><span class="line">  if (sess.views) &#123;</span><br><span class="line">    sess.views++</span><br><span class="line">    res.setHeader(&#x27;Content-Type&#x27;, &#x27;text/html&#x27;)</span><br><span class="line">    res.write(&#x27;&lt;p&gt;欢迎第 &#x27; + sess.views + &#x27;次访问       &#x27; + &#x27;expires in:&#x27; + (sess.cookie.maxAge / 1000) + &#x27;s&lt;/p&gt;&#x27;)</span><br><span class="line">    res.end();</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    sess.views = 1</span><br><span class="line">    res.end(&#x27;welcome to the session demo. refresh!&#x27;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.listen(3000);</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;</summary>
        
      
    
    
    
    <category term="知识剖析" scheme="http://example.com/categories/%E7%9F%A5%E8%AF%86%E5%89%96%E6%9E%90/"/>
    
    
    <category term="Node" scheme="http://example.com/tags/Node/"/>
    
    <category term="express" scheme="http://example.com/tags/express/"/>
    
    <category term="中间件" scheme="http://example.com/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    <category term="express-session" scheme="http://example.com/tags/express-session/"/>
    
  </entry>
  
  <entry>
    <title>Interface 与 Type的区别</title>
    <link href="http://example.com/2022/03/14/interface%E4%B8%8Etype/"/>
    <id>http://example.com/2022/03/14/interface%E4%B8%8Etype/</id>
    <published>2022-03-14T03:48:43.000Z</published>
    <updated>2024-01-02T01:12:08.506Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Interface-与Type"><a href="#Interface-与Type" class="headerlink" title="Interface 与Type"></a>Interface 与Type</h2><p>在使用typescript的时候经常会使用到interface与type。对于这两者区别在<a href="https://github.com/microsoft/TypeScript/blob/main/doc/spec-ARCHIVED.md">官方文档</a>中说明了两者区别</p><blockquote><ul><li>An interface can be named in an extends or implements clause, but a type alias for an object type literal cannot.<br/>(接口可以在扩展或实现子句中命名，但对象类型文字的类型别名不能)</li><li>An interface can have multiple merged declarations, but a type alias for an object type literal cannot.(一个接口可以有多个合并的声明，但对象类型文字的类型别名不能。)</li></ul></blockquote><h2 id="相同点"><a href="#相同点" class="headerlink" title="相同点"></a>相同点</h2><p>简单一句话： <strong>都可以描述一个对象或者函数</strong></p><h3 id="interface"><a href="#interface" class="headerlink" title="interface"></a>interface</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> person &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> setperson &#123;</span><br><span class="line">  (name: <span class="built_in">string</span>, <span class="attr">age</span>: <span class="built_in">number</span>): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="type"><a href="#type" class="headerlink" title="type"></a>type</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> person = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> setperson = <span class="function">(<span class="params">name: <span class="built_in">string</span>, age: <span class="built_in">number</span></span>)=&gt;</span> <span class="built_in">void</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="都允许拓展（extends）与-交叉类型（Intersection-Types）"><a href="#都允许拓展（extends）与-交叉类型（Intersection-Types）" class="headerlink" title="都允许拓展（extends）与 交叉类型（Intersection Types）"></a>都允许拓展（extends）与 交叉类型（Intersection Types）</h3><p>interface 和 type 都可以拓展，并且两者并不是相互独立的，也就是说 interface 可以 extends type, type 也可以 extends interface 。interface 可以 extends， 但 type 是不允许 extends 和 implement 的，但是 type 却可以通过交叉类型 实现 interface 的 extend 行为，并且两者并不是相互独立的，也就是说 interface 可以 extends type, type 也可以 与 interface 类型 交叉 。 <strong>虽然效果差不多，但是两者语法不同。</strong></p><h3 id="interface-extends-interface"><a href="#interface-extends-interface" class="headerlink" title="interface extends interface"></a>interface extends interface</h3><p>interface 继承使用关键字 extends</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Name &#123; </span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> User <span class="keyword">extends</span> Name &#123; </span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="type-与-type-交叉"><a href="#type-与-type-交叉" class="headerlink" title="type 与 type 交叉"></a>type 与 type 交叉</h3><p>type 继承使用符号&amp;</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Name = &#123; </span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> User = Name &amp; &#123; <span class="attr">age</span>: <span class="built_in">number</span>  &#125;;</span><br></pre></td></tr></table></figure><h3 id="interface-extends-type"><a href="#interface-extends-type" class="headerlink" title="interface extends type"></a>interface extends type</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Name = &#123; </span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> User <span class="keyword">extends</span> Name &#123; </span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="type-与-interface-交叉"><a href="#type-与-interface-交叉" class="headerlink" title="type 与 interface 交叉"></a>type 与 interface 交叉</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Name &#123; </span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> User = Name &amp; &#123; </span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="不同点"><a href="#不同点" class="headerlink" title="不同点"></a>不同点</h2><h3 id="type-可以而-interface-不行"><a href="#type-可以而-interface-不行" class="headerlink" title="type 可以而 interface 不行"></a>type 可以而 interface 不行</h3><ul><li><p>type 可以声明基本类型别名，联合类型，元组等类型<br></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基本类型别名</span></span><br><span class="line"><span class="keyword">type</span> Name = <span class="built_in">string</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 联合类型</span></span><br><span class="line"><span class="keyword">interface</span> Dog &#123;</span><br><span class="line">    wong();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> Cat &#123;</span><br><span class="line">    miao();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Pet = Dog | Cat</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体定义数组每个位置的类型</span></span><br><span class="line"><span class="keyword">type</span> PetList = [Dog, Pet]</span><br></pre></td></tr></table></figure></li><li><p>type 语句中还可以使用 typeof 获取实例的 类型进行赋值<br></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当你想获取一个变量的类型时，使用 typeof</span></span><br><span class="line"><span class="keyword">let</span> div = <span class="built_in">document</span>.createElement(<span class="string">&#x27;div&#x27;</span>);</span><br><span class="line"><span class="keyword">type</span> B = <span class="keyword">typeof</span> div</span><br></pre></td></tr></table></figure></li><li><p>其他骚操作</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> StringOrNumber = <span class="built_in">string</span> | <span class="built_in">number</span>;  </span><br><span class="line"><span class="keyword">type</span> Text = <span class="built_in">string</span> | &#123; <span class="attr">text</span>: <span class="built_in">string</span> &#125;;  </span><br><span class="line"><span class="keyword">type</span> NameLookup = Dictionary&lt;<span class="built_in">string</span>, Person&gt;;  </span><br><span class="line"><span class="keyword">type</span> Callback&lt;T&gt; = <span class="function">(<span class="params">data: T</span>) =&gt;</span> <span class="built_in">void</span>;  </span><br><span class="line"><span class="keyword">type</span> Pair&lt;T&gt; = [T, T];  </span><br><span class="line"><span class="keyword">type</span> Coordinates = Pair&lt;<span class="built_in">number</span>&gt;;  </span><br><span class="line"><span class="keyword">type</span> Tree&lt;T&gt; = T | &#123; <span class="attr">left</span>: Tree&lt;T&gt;, right: Tree&lt;T&gt; &#125;;</span><br></pre></td></tr></table></figure></li></ul><h3 id="interface-可以而-type-不行"><a href="#interface-可以而-type-不行" class="headerlink" title="interface 可以而 type 不行"></a>interface 可以而 type 不行</h3><p>interface 能够声明合并</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> User &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> User &#123;</span><br><span class="line">  <span class="attr">sex</span>: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">User 接口为 &#123;</span></span><br><span class="line"><span class="comment">  name: string</span></span><br><span class="line"><span class="comment">  age: number</span></span><br><span class="line"><span class="comment">  sex: string </span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>一般来说，如果不清楚什么时候用interface/type，能用 interface 实现，就用 interface , 如果不能就用 type 。其他更多详情参看<a href="https://github.com/microsoft/TypeScript/blob/main/doc/spec-ARCHIVED.md">官方规范文档</a></p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;</summary>
        
      
    
    
    
    <category term="知识剖析" scheme="http://example.com/categories/%E7%9F%A5%E8%AF%86%E5%89%96%E6%9E%90/"/>
    
    
    <category term="Node" scheme="http://example.com/tags/Node/"/>
    
    <category term="TypeScript" scheme="http://example.com/tags/TypeScript/"/>
    
  </entry>
  
  <entry>
    <title>express中间件</title>
    <link href="http://example.com/2021/08/27/express%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    <id>http://example.com/2021/08/27/express%E4%B8%AD%E9%97%B4%E4%BB%B6/</id>
    <published>2021-08-27T07:35:36.000Z</published>
    <updated>2024-01-02T01:12:08.503Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是express-中间件？"><a href="#什么是express-中间件？" class="headerlink" title="什么是express 中间件？"></a>什么是express 中间件？</h2><p>在express 的官网中有一段对中间件函数的解释：</p><blockquote><p>Middleware functions are functions that have access to the request object (req), the response object (res), and the next middleware function in the application’s request-response cycle. The next middleware function is commonly denoted by a variable named next.</p></blockquote><p>理解这句话可以看一下下图：<br><img src="https://greenhaha.oss-cn-beijing.aliyuncs.com/frontend/assets/img/middleware.png" alt="middleware 流程"></p><p>可以把express 理解成一个水管，用户的请求内容（request）可以理解为进水口，返回的内容（response）可以理解为出水口。而中间件在其中起到的 可以理解为这个水管的过滤器对请求的内容进行过滤处理之后排出过滤或者处理的结果。</p><p>那么对于在日常开发中使用中间的好处的话可以总结3点：</p><ul><li>逻辑清楚，层次分明。 正如TCP/IP中的分层一样，通过分层，可以使得每一个部分各司其职，更好的干事情。</li><li>便于维护。如果觉得其中一个做的不好，还可以换一个中间件，而其他的不用替换。</li><li>可复用。我们写好了一个中间件之后，就可以直接拿来在别的地方用了，就比如，我们在使用第三方中间件的时候，直接npm install somemiddleware，然后 require，最后直接 app.use 即可，非常方便。</li></ul><p>正如官网对中间件的解释：Middleware function 中间件的本质就是一个函数，这时候在理解上面的好处的时候实际上就是函数组件化的优点。</p><p>在express里中间件可以大致分为4类：</p><ul><li>应用级中间件 Application-level middleware </li><li>路由级中间件 Router-level middleware</li><li>错误级中间件 Error-handling middleware</li><li>内置级中间件 Built-in middleware</li><li>第三方中间件 Third-party middleware</li></ul><h3 id="应用级中间件（Application-level-middleware）"><a href="#应用级中间件（Application-level-middleware）" class="headerlink" title="应用级中间件（Application-level middleware）"></a>应用级中间件（Application-level middleware）</h3><p>其实应用级中间件可以理解为直接作用于express实例上的，这么说可能不太理解，但是<code>expresss().ues()</code>一定用过，其实这个就是应用级中间件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>)</span><br><span class="line"><span class="keyword">let</span> app = express()</span><br><span class="line">app.use(middleware1)   <span class="comment">// app.use() 方法中可以直接加载中间件</span></span><br></pre></td></tr></table></figure><h3 id="路由级中间件（Router-level-middleware）"><a href="#路由级中间件（Router-level-middleware）" class="headerlink" title="路由级中间件（Router-level middleware）"></a>路由级中间件（Router-level middleware）</h3><p>路由级中间件和一般的应用级中间件使用的方法是一样的，它们之间的区别是功能上职责区别。路由级中间件是为进行路由的管理，这里的路由并非是前端页面的路由，可以理解为单纯的url管理</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> app = express()</span><br><span class="line"><span class="keyword">let</span> router = express.Router()</span><br><span class="line"><span class="comment">// a middleware function with no mount path. This code is executed for every request to the router</span></span><br><span class="line">router.use(<span class="function"><span class="keyword">function</span> (<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;Time:&#x27;</span>, <span class="built_in">Date</span>.now())</span><br><span class="line">  next()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="错误级中间件（Error-handling-middleware）"><a href="#错误级中间件（Error-handling-middleware）" class="headerlink" title="错误级中间件（Error-handling middleware）"></a>错误级中间件（Error-handling middleware）</h3><p>这个中间件可以理解为拦截请求错误的。有四个参数，所以你必须提供四个参数来表明这个中间件是一个错误处理中间件，即使也许你不需要Next对象，你也得明确说明，否则的话，这就会被解析为一个普通的中间件，而非错误处理中间件了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">app.use(<span class="function"><span class="keyword">function</span> (<span class="params">err, req, res, next</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.error(err.stack)</span><br><span class="line">  res.status(<span class="number">500</span>).send(<span class="string">&#x27;Something broke!&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="内置级中间件（Built-in-middleware）"><a href="#内置级中间件（Built-in-middleware）" class="headerlink" title="内置级中间件（Built-in middleware）"></a>内置级中间件（Built-in middleware）</h3><p>express.js本身就是一个基于node的web应用程序。一个web应用就会涉及到静态资源的加载，express也不例外。因此对于静态资源的加载问题，express在4.4之后就不再依赖connect。因此目前express中唯一的一个内置应用级中间件就是<code>express.static</code>。这个函数是基于server-static的。目的是为了提供类似html，css，img，js等静态资源的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">express.static(root, [options])</span><br></pre></td></tr></table></figure><p>具体使用方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> options = &#123;</span><br><span class="line">  <span class="attr">dotfiles</span>: <span class="string">&#x27;ignore&#x27;</span>,</span><br><span class="line">  <span class="attr">etag</span>: <span class="literal">false</span>,</span><br><span class="line">  <span class="attr">extensions</span>: [<span class="string">&#x27;htm&#x27;</span>, <span class="string">&#x27;html&#x27;</span>],</span><br><span class="line">  <span class="attr">index</span>: <span class="literal">false</span>,</span><br><span class="line">  <span class="attr">maxAge</span>: <span class="string">&#x27;1d&#x27;</span>,</span><br><span class="line">  <span class="attr">redirect</span>: <span class="literal">false</span>,</span><br><span class="line">  <span class="attr">setHeaders</span>: <span class="function"><span class="keyword">function</span> (<span class="params">res, path, stat</span>) </span>&#123;</span><br><span class="line">    res.set(<span class="string">&#x27;x-timestamp&#x27;</span>, <span class="built_in">Date</span>.now())</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">app.use(express.static(<span class="string">&#x27;public&#x27;</span>, options))</span><br></pre></td></tr></table></figure><p>如果有多个静态文件的目录</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">app.use(express.static(<span class="string">&#x27;public&#x27;</span>))</span><br><span class="line">app.use(express.static(<span class="string">&#x27;file&#x27;</span>))</span><br><span class="line">app.use(express.static(<span class="string">&#x27;image&#x27;</span>))</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="第三方级中间件（Third-party-middleware）"><a href="#第三方级中间件（Third-party-middleware）" class="headerlink" title="第三方级中间件（Third-party middleware）"></a>第三方级中间件（Third-party middleware）</h3><p>第三方级中间件按照字面理解的话就是第三方中间件。这些中间件非官方开发，有独立开发者自己开发的中间件。这种中间件有很多比如：</p><ul><li>cookie-parser</li><li>body-parser 等等</li></ul><h2 id="中间件实现原理"><a href="#中间件实现原理" class="headerlink" title="中间件实现原理"></a>中间件实现原理</h2><p>上面介绍的express的中间件，其实中间件就是一个函数，在相应发送之前对请求进行一些操作</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">middleware</span>(<span class="params">req, res, next</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// do someting</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// run next function</span></span><br><span class="line">    next()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>中间件函数它有一个next参数，而这个next参数也是一个函数，他表示函数数组中的下一个函数。那么就会有另外一个问题：函数数组又是什么呢？<br>其实就是express内部维护一个函数数组，这个函数数组表示在发出响应之前要执行的所有函数，也就是中间件数组</p><p>使用<code>app.use(fn)</code>后，传进来的fn就会被扔到这个数组里，执行完毕后调用<code>next()</code>方法执行函数数组里的下一个函数，如果没有调用next()的话，就不会调用下一个函数了，也就是说调用就会被终止</p><h2 id="简单实现一个express中间件"><a href="#简单实现一个express中间件" class="headerlink" title="简单实现一个express中间件"></a>简单实现一个express中间件</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 仿照express实现中间件的功能</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Created by BadWaka on 2017/3/6.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 仿express实现中间件机制</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;app&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">express</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> funcs = []; <span class="comment">// 待执行的函数数组</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> app = <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">next</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> task = funcs[i++];  <span class="comment">// 取出函数数组里的下一个函数</span></span><br><span class="line">            <span class="keyword">if</span> (!task) &#123;    <span class="comment">// 如果函数不存在,return</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            task(req, res, next);   <span class="comment">// 否则,执行下一个函数</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        next();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * use方法就是把函数添加到函数数组中</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param <span class="variable">task</span></span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    app.use = <span class="function"><span class="keyword">function</span> (<span class="params">task</span>) </span>&#123;</span><br><span class="line">        funcs.push(task);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> app;    <span class="comment">// 返回实例</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面是测试case</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> app = express();</span><br><span class="line">http.createServer(app).listen(<span class="string">&#x27;3000&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;listening 3000....&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">middlewareA</span>(<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;middlewareA before next()&#x27;</span>);</span><br><span class="line">    next();</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;middlewareA after next()&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">middlewareB</span>(<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;middlewareB before next()&#x27;</span>);</span><br><span class="line">    next();</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;middlewareB after next()&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">middlewareC</span>(<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;middlewareC before next()&#x27;</span>);</span><br><span class="line">    next();</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;middlewareC after next()&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">app.use(middlewareA);</span><br><span class="line">app.use(middlewareB);</span><br><span class="line">app.use(middlewareC);</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;</summary>
        
      
    
    
    
    <category term="知识剖析" scheme="http://example.com/categories/%E7%9F%A5%E8%AF%86%E5%89%96%E6%9E%90/"/>
    
    
    <category term="Node" scheme="http://example.com/tags/Node/"/>
    
    <category term="express" scheme="http://example.com/tags/express/"/>
    
    <category term="中间件" scheme="http://example.com/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript隐式类型转换</title>
    <link href="http://example.com/2021/08/26/js%E9%9A%90%E5%BC%8F%E8%BD%AC%E6%8D%A2/"/>
    <id>http://example.com/2021/08/26/js%E9%9A%90%E5%BC%8F%E8%BD%AC%E6%8D%A2/</id>
    <published>2021-08-26T07:47:56.000Z</published>
    <updated>2024-01-02T01:12:08.508Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://greenhaha.oss-cn-beijing.aliyuncs.com/frontend/assets/img/how-it-fucking-work.png" alt="JavaScript隐式类型转换"><br>javascript 在发生隐式类型转换的时候会有各种个样的问题,即使有很多经验的开发者有时候也不一定能理清楚具体规律是什么。</p><span class="blur">其实写这篇文章的主要原因是面试时候问到这个，而我却满脸❓</span>。因此我想要好好整理这一块<h2 id="数学运算符中的类型转换"><a href="#数学运算符中的类型转换" class="headerlink" title="数学运算符中的类型转换"></a>数学运算符中的类型转换</h2><p>因为 JS 并没有类型声明，所以任意两个变量或字面量，都可以做加减乘除。</p><h3 id="减、乘、除"><a href="#减、乘、除" class="headerlink" title="减、乘、除"></a>减、乘、除</h3><p>非<code>Number</code>类型运用数学运算符<code>(- * /)</code>时，会先将非<code>Number</code>类型转换为<code>Number</code>类型。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> - <span class="literal">true</span> <span class="comment">// 0， 首先把 true 转换为数字 1， 然后执行 1 - 1</span></span><br><span class="line"><span class="number">1</span> - <span class="literal">null</span> <span class="comment">// 1,  首先把 null 转换为数字 0， 然后执行 1 - 0</span></span><br><span class="line"><span class="number">1</span> * <span class="literal">undefined</span> <span class="comment">//  NaN, undefined 转换为数字是 NaN</span></span><br><span class="line"><span class="number">2</span> * [<span class="string">&#x27;5&#x27;</span>] <span class="comment">//  10， [&#x27;5&#x27;]首先会变成 &#x27;5&#x27;, 然后再变成数字 5</span></span><br></pre></td></tr></table></figure><h3 id="加法的特殊性"><a href="#加法的特殊性" class="headerlink" title="加法的特殊性"></a>加法的特殊性</h3><p>JS里 <code>+</code>还可以用来拼接字符串。谨记以下3条：</p><ul><li>当一侧为<code>String</code>类型，被识别为字符串拼接，并会优先将另一侧转换为字符串类型。</li><li>当一侧为<code>Number</code>类型，另一侧为原始类型，则将原始类型转换为<code>Number</code>类型。</li><li>当一侧为<code>Number</code>类型，另一侧为引用类型，将引用类型和<code>Number</code>类型转换成字符串后拼接。</li></ul><p>优先级从高到低，即 <code>3+&#39;abc&#39;</code> 会应用规则 1，而 <code>3+true</code>会应用规则2。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">123</span> + <span class="string">&#x27;123&#x27;</span> <span class="comment">// 123123   （规则1）</span></span><br><span class="line"><span class="number">123</span> + <span class="literal">null</span>  <span class="comment">// 123    （规则2）</span></span><br><span class="line"><span class="number">123</span> + <span class="literal">true</span> <span class="comment">// 124    （规则2）</span></span><br><span class="line"><span class="number">123</span> + &#123;&#125;  <span class="comment">// 123[object Object]    （规则3）</span></span><br></pre></td></tr></table></figure><h2 id="逻辑语句中的类型转换"><a href="#逻辑语句中的类型转换" class="headerlink" title="逻辑语句中的类型转换"></a>逻辑语句中的类型转换</h2><p>使用 <code>if while for</code> 语句时，我们期望表达式是一个<code>Boolean</code>，所以一定伴随着隐式类型转换。而这里面又分为两种情况:</p><h3 id="单个变量"><a href="#单个变量" class="headerlink" title="单个变量"></a>单个变量</h3><p>只有单个变量，会先将变量转换为<code>Boolean</code>值。</p><p>我们可以参考附录的转换表来判断各种类型转变为<code>Boolean</code>后的值。</p><p>不过这里有个小技巧：</p><p>只有 <code>null undefined &#39;&#39; NaN 0 false</code> 这几个是 <code>false</code>，其他的情况都是 <code>true</code>，比如 <code>&#123;&#125;</code> , <code>[]</code>。</p><h3 id="使用-比较中的5条规则"><a href="#使用-比较中的5条规则" class="headerlink" title="使用 == 比较中的5条规则"></a>使用 == 比较中的5条规则</h3><p>可以严格使用 ===，不过了解==的习性还是很有必要的<br>根据 == 两侧的数据类型，我们总结出 5 条规则：</p><ul><li>规则 1：NaN和其他任何类型比较永远返回false（包括和他自己）<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">NaN</span> == <span class="literal">NaN</span> <span class="comment">// false</span></span><br></pre></td></tr></table></figure></li><li>规则 2：Boolean 和其他任何类型比较，Boolean 首先被转换为 Number 类型。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">true</span> == <span class="number">1</span>  <span class="comment">// true </span></span><br><span class="line"><span class="literal">true</span> == <span class="string">&#x27;2&#x27;</span>  <span class="comment">// false, 先把 true 变成 1，而不是把 &#x27;2&#x27; 变成 true</span></span><br><span class="line"><span class="literal">true</span> == [<span class="string">&#x27;1&#x27;</span>]  <span class="comment">// true, 先把 true 变成 1， [&#x27;1&#x27;]拆箱成 &#x27;1&#x27;, 再参考规则3</span></span><br><span class="line"><span class="literal">true</span> == [<span class="string">&#x27;2&#x27;</span>]  <span class="comment">// false, 同上</span></span><br><span class="line"><span class="literal">undefined</span> == <span class="literal">false</span> <span class="comment">// false ，首先 false 变成 0，然后参考规则4</span></span><br><span class="line"><span class="literal">null</span> == <span class="literal">false</span> <span class="comment">// false，同上</span></span><br></pre></td></tr></table></figure></li><li>规则 3：<code>String</code>和<code>Number</code>比较，先将<code>String</code>转换为<code>Number</code>类型</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">123</span> == <span class="string">&#x27;123&#x27;</span> <span class="comment">// true, &#x27;123&#x27; 会先变成 123</span></span><br><span class="line"><span class="string">&#x27;&#x27;</span> == <span class="number">0</span> <span class="comment">// true, &#x27;&#x27; 会首先变成 0</span></span><br></pre></td></tr></table></figure><ul><li>规则 4：null == undefined比较结果是true，除此之外，null、undefined和其他任何结果的比较值都为false。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">null</span> == <span class="literal">undefined</span> <span class="comment">// true</span></span><br><span class="line"><span class="literal">null</span> == <span class="string">&#x27;&#x27;</span> <span class="comment">// false</span></span><br><span class="line"><span class="literal">null</span> == <span class="number">0</span> <span class="comment">// false</span></span><br><span class="line"><span class="literal">null</span> == <span class="literal">false</span> <span class="comment">// false</span></span><br><span class="line"><span class="literal">undefined</span> == <span class="string">&#x27;&#x27;</span> <span class="comment">// false</span></span><br><span class="line"><span class="literal">undefined</span> == <span class="number">0</span> <span class="comment">// false</span></span><br><span class="line"><span class="literal">undefined</span> == <span class="literal">false</span> <span class="comment">// false</span></span><br></pre></td></tr></table></figure></li><li>规则 5：原始类型和引用类型做比较时，引用类型会依照<code>ToPrimitive</code>规则转换为原始类型。<blockquote><p><code>ToPrimitive</code>规则，是引用类型向原始类型转变的规则，它遵循先<code>valueOf</code>后<code>toString</code>的模式期望得到一个原始类型。<br>如果还是没法得到一个原始类型，就会抛出 <code>TypeError</code>。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;[object Object]&#x27;</span> == &#123;&#125; </span><br><span class="line"><span class="comment">// true, 对象和字符串比较，对象通过 toString 得到一个基本类型值</span></span><br><span class="line"><span class="string">&#x27;1,2,3&#x27;</span> == [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>] </span><br><span class="line"><span class="comment">// true, 同上  [1, 2, 3]通过 toString 得到一个基本类型值</span></span><br></pre></td></tr></table></figure></li></ul><p>附录：<br><img src="https://greenhaha.oss-cn-beijing.aliyuncs.com/frontend/assets/img/convert-table.png" alt="附录"></p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;</summary>
        
      
    
    
    
    <category term="知识剖析" scheme="http://example.com/categories/%E7%9F%A5%E8%AF%86%E5%89%96%E6%9E%90/"/>
    
    
    <category term="JavaScript" scheme="http://example.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>TS 类型中的 any、void 和 never</title>
    <link href="http://example.com/2021/08/25/TS%E7%B1%BB%E5%9E%8B%E4%B8%ADany%C2%B7void%C2%B7never/"/>
    <id>http://example.com/2021/08/25/TS%E7%B1%BB%E5%9E%8B%E4%B8%ADany%C2%B7void%C2%B7never/</id>
    <published>2021-08-25T02:11:51.000Z</published>
    <updated>2024-01-02T01:12:08.502Z</updated>
    
    <content type="html"><![CDATA[<p>在ts的类型中常见的类型<code>number</code>, <code>string</code>, <code>boolean</code>等之外, 也有其他不直观的类型表达<code>any</code> <code>void</code> <code>never</code></p><h2 id="any-类型"><a href="#any-类型" class="headerlink" title="any 类型"></a>any 类型</h2><p>在一些情况下，如果我们无法确定变量的类型时（或者无需确认类型时），我们可以将其指定为 any 类型。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isNumber</span>(<span class="params">value: any</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">typeof</span> value === <span class="string">&#x27;number&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上，TS中对于被标记为 <code>any</code> 类型的变量，是没有进行类型检查而直接通过编译阶段的检查。</p><blockquote><p>We want to opt-out of type checking and let the values pass through compile-time checks. To do so, we label these with the any type.</p></blockquote><p>就个人来说，使用ts 的目的是为了提高并保证系统的健壮性，而<code>any</code>类型却没有进行类型的检查直接通过编译阶段对系统的稳定性来说有一定影响</p><h3 id="any-类型的特点"><a href="#any-类型的特点" class="headerlink" title="any 类型的特点"></a>any 类型的特点</h3><ul><li>允许赋值为任意类型<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> value: any = <span class="string">&#x27;seven&#x27;</span>;</span><br><span class="line">value = <span class="number">7</span>;</span><br></pre></td></tr></table></figure></li><li>可以访问任意属性和方法<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> value: any = <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以访问任意属性</span></span><br><span class="line"><span class="built_in">console</span>.log(value.name);</span><br><span class="line"><span class="built_in">console</span>.log(value.name.firstName);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以调用任意方法</span></span><br><span class="line">value.setName(<span class="string">&#x27;Jerry&#x27;</span>);</span><br><span class="line">value.setName(<span class="string">&#x27;Jerry&#x27;</span>).sayHello();</span><br><span class="line">value.name.setFirstName(<span class="string">&#x27;Cat&#x27;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>当变量为任意值之后，对它的任何操作返回的内容的类型都是任意值。很容易让某一块代码变得难以维护，丧失了静态类型检查阶段发现错误的可能性</li></ul><h3 id="变量如果在声明的时候，未指定其类型，那么它会被识别为任意值类型"><a href="#变量如果在声明的时候，未指定其类型，那么它会被识别为任意值类型" class="headerlink" title="变量如果在声明的时候，未指定其类型，那么它会被识别为任意值类型"></a>变量如果在声明的时候，未指定其类型，那么它会被识别为任意值类型</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> value;</span><br><span class="line">value = <span class="string">&#x27;seven&#x27;</span>;</span><br><span class="line">value = <span class="number">7</span>;</span><br></pre></td></tr></table></figure><p>未声明类型的变量虽然一开始被识别为 any 类型，但是经过赋值后，TS 会根据赋值类型来标识变量的类型</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> value;</span><br><span class="line"></span><br><span class="line">value = <span class="string">&#x27;seven&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> diff1 = value - <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 类型检查错误： The left-hand side of an arithmetic operation must be of type &#x27;any&#x27;, &#x27;number&#x27;, &#x27;bigint&#x27; or an enum type</span></span><br><span class="line"></span><br><span class="line">value = <span class="number">7</span>;</span><br><span class="line">cosnt diff2 = value - <span class="number">1</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="void-类型"><a href="#void-类型" class="headerlink" title="void 类型"></a>void 类型</h3><p><code>void</code> 类型表示没有任何类型</p><blockquote><p>void is a little like the opposite of any: the absence of having any type at all</p></blockquote><p>没有返回值的函数，其返回值类型为 <code>void</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;this is foo function&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>声明为<code>void</code>类型的变量，只能赋予<code>undefined</code>和<code>null</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> unusable: <span class="keyword">void</span> = <span class="literal">undefined</span>;</span><br></pre></td></tr></table></figure><h2 id="never"><a href="#never" class="headerlink" title="never"></a>never</h2><p><code>never</code> 类型表示永远不会有值的一种类型。(很抽象是不是)</p><blockquote><p>The never type represents the type of values that never occur.</p></blockquote><ul><li>never类型是那些总是会抛出异常或根本就不会有返回值的函数表达式或箭头函数表达式的返回值类型<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回never的函数必须存在无法达到的终点</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 因为总是抛出异常，所以 error 将不会有返回值</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">error</span>(<span class="params">message: string</span>): <span class="title">never</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(message);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 因为存在死循环，所以 infiniteLoop 将不会有返回值</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">infiniteLoop</span>(<span class="params"></span>): <span class="title">never</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>永远不可能存在的情况：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> foo = <span class="number">123</span>;</span><br><span class="line"><span class="keyword">if</span> (foo !== <span class="number">123</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> bar = foo;    <span class="comment">// bar: never</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="never-和-void-的差异"><a href="#never-和-void-的差异" class="headerlink" title="never 和 void 的差异"></a>never 和 void 的差异</h3><code>void</code> 表示没有任何类型，<code>never</code> 表示永远不存在的值的类型。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回never的函数必须存在无法达到的终点</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">infiniteLoop</span>(<span class="params"></span>): <span class="title">never</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个函数不能申明其返回值类型是 never</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">warnUser</span>(<span class="params"></span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;This is my warning message&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;</summary>
        
      
    
    
    
    <category term="知识剖析" scheme="http://example.com/categories/%E7%9F%A5%E8%AF%86%E5%89%96%E6%9E%90/"/>
    
    
    <category term="JavaScript" scheme="http://example.com/tags/JavaScript/"/>
    
    <category term="函数式编程" scheme="http://example.com/tags/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
    
    <category term="ELM" scheme="http://example.com/tags/ELM/"/>
    
  </entry>
  
  <entry>
    <title>ELM 编程语言</title>
    <link href="http://example.com/2021/08/20/elm/"/>
    <id>http://example.com/2021/08/20/elm/</id>
    <published>2021-08-20T02:11:51.000Z</published>
    <updated>2024-01-02T01:12:08.503Z</updated>
    
    <content type="html"><![CDATA[<p>在一个晴朗的午后，我正在拿我的专属神器‘保温杯’在快乐的划水摸鱼中，此时一个惊天阴谋将发生。项目经理面带微笑的走过来说：接下来开发会需要用到 ‘ELM’，你好好看看学一学！说完就离开了，留下了一脸楞逼的我。 ‘ELM’是啥？ELM能干什么？ELM应该怎么干？ 素质三连问？—– 中二病又犯了_(:3 LZ)_</p><h2 id="ELM-是什么？"><a href="#ELM-是什么？" class="headerlink" title="ELM 是什么？"></a>ELM 是什么？</h2><p>对于第一次接触的小伙伴来说估计也是一脸懵逼中，‘ELM’？==》‘element’ ==》‘饿了么’！机智如我<span class="blur">智障如我</span>。不用学，不久‘饿了么’，简单小菜一碟。然而google一下之后发现事情远远没有那么简单。</p><blockquote><p>Elm是一个领域特定编程语言，用于声明式的创建基于web浏览器的图形用户界面。Elm是纯函数式的，开发它时强调了易用性、性能和健壮性。它宣传为“实际上没有运行时间异常”，Elm编译器的静态类型检查使之成为可能。   —–维基百科</p></blockquote><p>一个领域特定编程语言？纯函数式？runningtime no error？静态类型检查？看介绍好高大上。机智的我搜索打开<a href="https://elm-lang.org/">ELM官网</a>。官网中第一句话就是：A delightful language<br>for reliable web applications.（对于开发web应用程序这是一个令开发者兴奋的语言 — 抱歉中文是我翻译的，然后之后我会对delightful这个词有一个新的理解 无论精神上还是肉体上）</p><p> <img src="https://greenhaha.oss-cn-beijing.aliyuncs.com/frontend/assets/img/elmindex.png" alt="elm 首页"></p><p>那么回到正题：ELM是什么？<br>官网给出了回答：ELM是一个可以编译成JavaScript的纯函数语言。其实说直白一点就是他也算是前端语言吧，不过他需要自己的解释器将对应的语法翻译成JavaScript最终在浏览器上执行。并且redux的产生于设计思想其实是借鉴ELM。<br>EML和JavaScript不同，虽然最终解释运行在浏览器上，但是开发的语法却和JavaScript不同。ELM的编译器使用的Haskell语法，你可以把它理解成是一个纯函数语法，和JavaScript有点相似但是与JavaScript又完全不同。之后会说到的。他有自己的运行环境：elm-live 或者是elm-go。是实施提供了elm的热更功能。不要问我为啥知道，这就是我在上面提到的 ‘delightful’的原因</p><h2 id="ELM能干什么"><a href="#ELM能干什么" class="headerlink" title="ELM能干什么"></a>ELM能干什么</h2><p>这个是重点：ELM有自己的语法，因为他是一门语言并且最终解释称JavaScript并在浏览器上运行。因此ELM有自己的数据更新机制，这套机制和redux相似：<br><img src="https://greenhaha.oss-cn-beijing.aliyuncs.com/frontend/assets/img/buttons.svg" alt="elm 更新机制"></p><p>ELM生成的HTML可以在屏幕上显示，而这种运行其实可以分为三个部分</p><ul><li>Model  — 可以理解为应用的状态（打比方的话可以认为是redux的全局state）</li><li>View   — 可以认为是视图层，把state放知道html上</li><li>Update — 用于更新应用的状态的（打比方的话可以认为是reducer）</li></ul><p>其实仔细一品的话其实就会发现，这特喵的不就和react 一个组件的内部更新一样吗。（原谅我不厚道的笑出了猪声）</p><h2 id="ELM应该怎么干？"><a href="#ELM应该怎么干？" class="headerlink" title="ELM应该怎么干？"></a>ELM应该怎么干？</h2><p>一个就简单的例子（hasekell语法需要自己学习）：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Browser</span><br><span class="line"><span class="keyword">import</span> Html exposing (Html, button, div, text)</span><br><span class="line"><span class="keyword">import</span> Html.Events exposing (onClick)</span><br><span class="line"></span><br><span class="line">-- MAIN</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">main =</span><br><span class="line">  Browser.sandbox &#123; init = init, update = update, view = view &#125;</span><br><span class="line"></span><br><span class="line">-- MODEL</span><br><span class="line"></span><br><span class="line">type alias Model = Int</span><br><span class="line"></span><br><span class="line"><span class="attr">init</span> : Model</span><br><span class="line">init =</span><br><span class="line">  <span class="number">0</span></span><br><span class="line"></span><br><span class="line">-- UPDATE</span><br><span class="line"></span><br><span class="line">type Msg = Increment | Decrement</span><br><span class="line"></span><br><span class="line"><span class="attr">update</span> : Msg -&gt; Model -&gt; Model</span><br><span class="line">update msg model =</span><br><span class="line">  <span class="keyword">case</span> msg <span class="keyword">of</span></span><br><span class="line">    Increment -&gt;</span><br><span class="line">      model + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    Decrement -&gt;</span><br><span class="line">      model - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">-- VIEW</span><br><span class="line"></span><br><span class="line"><span class="attr">view</span> : Model -&gt; Html Msg</span><br><span class="line">view model =</span><br><span class="line">  div []</span><br><span class="line">    [ button [ onClick Decrement ] [ text <span class="string">&quot;-&quot;</span> ]</span><br><span class="line">    , div [] [ text (<span class="built_in">String</span>.fromInt model) ]</span><br><span class="line">    , button [ onClick Increment ] [ text <span class="string">&quot;+&quot;</span> ]</span><br><span class="line">    ]</span><br></pre></td></tr></table></figure><h3 id="Main"><a href="#Main" class="headerlink" title="Main"></a>Main</h3><p><code>Main</code>函数对于ELM来说是特别的，它是用来在屏幕上描述显示HMLT的，你可以理解为它是一个沙盒。在程序init值初始化后，<code>view</code>函数会把view中的所有内容描述在屏幕上。</p><h3 id="Model"><a href="#Model" class="headerlink" title="Model"></a>Model</h3><p>state在ELM中时极其重要的存在，Model存在的重点是捕获收集当前应用的所有详细信息数据，而在上面的例子中则是当作一个计数器来使用</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type alias Model = init</span><br></pre></td></tr></table></figure><p>由于ELM是静态类型检验，所有在定义类型后需要给予初始值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">init : Model</span><br><span class="line">init = <span class="number">0</span></span><br></pre></td></tr></table></figure><h3 id="View"><a href="#View" class="headerlink" title="View"></a>View</h3><p>画面是如何呈现在屏幕上，这是则需要<code>View</code>函数。<br>上面的例子中：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">view : Model -&gt; Html Msg</span><br><span class="line">view model =</span><br><span class="line">  div []</span><br><span class="line">    [ button [ onClick Decrement ] [ text <span class="string">&quot;-&quot;</span> ]</span><br><span class="line">    , div [] [ text (<span class="built_in">String</span>.fromInt model) ]</span><br><span class="line">    , button [ onClick Increment ] [ text <span class="string">&quot;+&quot;</span> ]</span><br><span class="line">    ]</span><br></pre></td></tr></table></figure><p>他接受一个Model作为参数 并且输出HTML信息。（在ELM中静态类型校验是无处不在的）</p><h3 id="Update"><a href="#Update" class="headerlink" title="Update"></a>Update</h3><p><code>update</code>函数则是描述了Model中state的值如何更新<br>更具例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type Msg = Increment | Decrement</span><br></pre></td></tr></table></figure><p>当收到触发的Msg的时候就会在更新函数中对Model中state进行更新</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">update : Msg -&gt; Model -&gt; Model</span><br><span class="line">update msg model =</span><br><span class="line">  <span class="keyword">case</span> msg <span class="keyword">of</span></span><br><span class="line">    Increment -&gt;</span><br><span class="line">      model + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    Decrement -&gt;</span><br><span class="line">      model - <span class="number">1</span></span><br></pre></td></tr></table></figure><p>上面的例子就是一个最基础的ELM的demo。通过点击按钮更新页面上的内容。<br>运行机制的话如下图所示：<br><img src="https://greenhaha.oss-cn-beijing.aliyuncs.com/frontend/assets/img/elm%E6%95%B0%E6%8D%AE%E6%B5%81.png" alt="elm 数据流"></p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;</summary>
        
      
    
    
    
    <category term="文档教程" scheme="http://example.com/categories/%E6%96%87%E6%A1%A3%E6%95%99%E7%A8%8B/"/>
    
    
    <category term="JavaScript" scheme="http://example.com/tags/JavaScript/"/>
    
    <category term="函数式编程" scheme="http://example.com/tags/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
    
    <category term="ELM" scheme="http://example.com/tags/ELM/"/>
    
  </entry>
  
  <entry>
    <title>常用布局</title>
    <link href="http://example.com/2021/07/23/%E5%B8%B8%E7%94%A8%E5%B8%83%E5%B1%80/"/>
    <id>http://example.com/2021/07/23/%E5%B8%B8%E7%94%A8%E5%B8%83%E5%B1%80/</id>
    <published>2021-07-23T13:05:22.000Z</published>
    <updated>2024-01-02T01:12:08.528Z</updated>
    
    <content type="html"><![CDATA[<h1 id="常用布局"><a href="#常用布局" class="headerlink" title="常用布局"></a>常用布局</h1><h2 id="正常布局流-Normal-flow"><a href="#正常布局流-Normal-flow" class="headerlink" title="正常布局流(Normal flow)"></a>正常布局流(Normal flow)</h2><p>正常布局流（normal flow）是指在不对页面进行任何布局控制时，浏览器默认的HTML布局方式<br>其实总结一句话：原生态，没有任何修饰行css。遵循最基本的BFC布局</p><blockquote><p>BFC(Block formatting context)直译为”块级格式化上下文”。它是一个独立的渲染区域，只有Block-level box参与（在下面有解释）， 它规定了内部的Block-level Box如何布局，并且与这个区域外部毫不相干。所谓的BFC就是css布局的一个概念，是一块区域，一个环境</p></blockquote><h2 id="弹性盒子（Flexbox）"><a href="#弹性盒子（Flexbox）" class="headerlink" title="弹性盒子（Flexbox）"></a>弹性盒子（Flexbox）</h2><p>弹性盒子（Flexbox）是CSS弹性盒子布局模块（<a href="https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Flexible_Box_Layout">Flexible Box Layout</a> Module）的缩写。专门设计出来用于创建横向或是纵向的一维页面布局。</p><p>弹性盒子布局是css的模块之一，它定义了一种对用户界面设计而优化的css盒子模型。在弹性布局模型中，弹性容器的子元素可以在容器中任意方向上排列，可以“任意伸缩”其尺寸</p><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p><img src="https://greenhaha.oss-cn-beijing.aliyuncs.com/frontend/assets/img/flex.png" alt="flex原理图"></p><p>要理解flex布局需要明白flex容器它是有2个轴线的，水平主轴（main axis）和垂直的交叉轴（cross axis）。水平轴和垂直轴是可以通过修改来变幻的，使垂直轴变成主轴，水平方向变成交叉轴。<br>在容器中，每个子元素（单元块）成为 flex item。每个单元占据的主轴空间为（mian size），占据的交叉轴空间为（cross size）<br>main size 不等于 宽度  cross size 不等于 高度。这两个值取决于当前主轴方向，如果垂直方向是主轴，那么单元的高度就是main size</p><h3 id="Flex-容器"><a href="#Flex-容器" class="headerlink" title="Flex 容器"></a>Flex 容器</h3><p>flex容器对于实现flex布局是一个很重要的存在。实现一个flex布局需要先制定一个容器。任何一个容器都可以被指定为flex布局。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: flex | inline-flex;       //可以有两种取值</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分别生成一个块状或行内的 flex 容器盒子。简单说来，如果你使用块元素如 div，你就可以使用 flex，而如果你使用行内元素，你可以使用 inline-flex。</p><blockquote><p>需要注意的是：当时设置 flex 布局之后，子元素的 float、clear、vertical-align 的属性将会失效</p></blockquote><p>有下面六种属性可以设置在容器上，它们分别是：</p><ul><li>flex-direction ()</li><li>flex-wrap</li><li>flex-flow</li><li>justify-content</li><li>align-items</li><li>align-content</li></ul><h4 id="flex-direction-决定主轴的方向（即容器中子元素排列方向）"><a href="#flex-direction-决定主轴的方向（即容器中子元素排列方向）" class="headerlink" title="flex-direction: 决定主轴的方向（即容器中子元素排列方向）"></a>flex-direction: 决定主轴的方向（即容器中子元素排列方向）</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">flex-direction</span>: row | row-reverse | column | column-reverse;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>默认值：row 主轴为水平方向，起点在左端<br><img src="https://greenhaha.oss-cn-beijing.aliyuncs.com/frontend/assets/img/flex-directionrow.png" alt="flex-direction:row"></p><p>row-reverse：主轴为水平防线，起点在右端<br><img src="https://greenhaha.oss-cn-beijing.aliyuncs.com/frontend/assets/img/row-reverse.png" alt="row-reverse"></p><p>column:主轴为垂直方向，起点在最上面<br><img src="https://greenhaha.oss-cn-beijing.aliyuncs.com/frontend/assets/img/column.png"></p><p>column-reverse:主轴为垂直方向，起点在最下面<br><img src="https://greenhaha.oss-cn-beijing.aliyuncs.com/frontend/assets/img/row-reverse.png" alt="column-reverse"></p><h4 id="flex-wrap-决定容器中子元素是否可以换行"><a href="#flex-wrap-决定容器中子元素是否可以换行" class="headerlink" title="flex-wrap: 决定容器中子元素是否可以换行"></a>flex-wrap: 决定容器中子元素是否可以换行</h4><p>默认情况下，子元素都会排列在主轴上（实际就是一行上），使用flex-wrap 可实现容器中子元素的换行</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">flex-wrap</span>: nowrap | wrap | wrap-reverse;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>默认值：nowrap 不换行，即当主轴尺寸固定是时，当空间不足时，子元素尺寸会随之调整并不会挤到下一行<br><img src="https://greenhaha.oss-cn-beijing.aliyuncs.com/frontend/assets/img/nowrap.png" alt="nowrap"></p><p>wrap： 子元素在主轴排列的时候超出容器时换行 在第一行的上方<br><img src="https://greenhaha.oss-cn-beijing.aliyuncs.com/frontend/assets/img/wrap.png" alt="wrap"></p><p>wrap-reverse: 换行 在第一行的下方<br><img src="https://greenhaha.oss-cn-beijing.aliyuncs.com/frontend/assets/img/wrap-reverse.png" alt="wrap-reverse"></p><h4 id="flex-flow-flex-direction和flex-wrap的简写形式"><a href="#flex-flow-flex-direction和flex-wrap的简写形式" class="headerlink" title="flex-flow: flex-direction和flex-wrap的简写形式"></a>flex-flow: flex-direction和flex-wrap的简写形式</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">flex-flow</span>: &lt;flex-direction&gt; || &lt;flex-wrap&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>默认值为: row nowrap，感觉没什么卵用</p><h4 id="justify-content：定义了项目在主轴的对齐方式"><a href="#justify-content：定义了项目在主轴的对齐方式" class="headerlink" title="justify-content：定义了项目在主轴的对齐方式"></a>justify-content：定义了项目在主轴的对齐方式</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">justify-content</span>: flex-start | flex-end | center | space-between | space-around;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>建立在主轴为水平方向时测试，即 flex-direction: row</p></blockquote><p>默认值: flex-start 左对齐<br><img src="https://greenhaha.oss-cn-beijing.aliyuncs.com/frontend/assets/img/flex-start.png" alt="flex-start"></p><p>flex-end: 右对齐<br><img src="https://greenhaha.oss-cn-beijing.aliyuncs.com/frontend/assets/img/flex-end.png" alt="flex-end"></p><p>center:  居中<br><img src="https://greenhaha.oss-cn-beijing.aliyuncs.com/frontend/assets/img/center.png" alt="center"></p><p>space-between: 两端对齐，子元素之间的间隔相等，剩余空间平均分配间隙相同<br><img src="https://greenhaha.oss-cn-beijing.aliyuncs.com/frontend/assets/img/space-between.png" alt="space-between"></p><p>space-around: 每个项目两侧的间隔相同，子元素之间的间隔比子元素与边缘的间隔大一倍<br><img src="https://greenhaha.oss-cn-beijing.aliyuncs.com/frontend/assets/img/space-around.png" alt="space-around"></p><h4 id="align-items-定义了子元素在交叉轴上的对其方式"><a href="#align-items-定义了子元素在交叉轴上的对其方式" class="headerlink" title="align-items: 定义了子元素在交叉轴上的对其方式"></a>align-items: 定义了子元素在交叉轴上的对其方式</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">align-items</span>: flex-start | flex-end | center | baseline | stretch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>默认值：<code>stretch</code> 即如果子元素没有设置高度或者为auto，将充满整个容器的高度<br><img src="https://greenhaha.oss-cn-beijing.aliyuncs.com/frontend/assets/img/stretch.png" alt="stretch"><br>假设容器高度设置为 100px，而项目都没有设置高度的情况下，则项目的高度也为 100px。</p><ul><li>flex-start: 交叉轴起点对齐</li></ul><p><img src="https://greenhaha.oss-cn-beijing.aliyuncs.com/frontend/assets/img/alignitemflex-start.png" alt="alignitemflex-start"><br>假设容器高度设置为 100px，而项目分别为 20px, 40px, 60px, 80px, 100px, 则如上图显示。</p><ul><li>flex-end: 交叉轴的终点对齐</li></ul><p><img src="https://greenhaha.oss-cn-beijing.aliyuncs.com/frontend/assets/img/alignitemflexend.png" alt="alignitem-flexend"></p><ul><li>center: 交叉轴的中点对齐</li></ul><p><img src="https://greenhaha.oss-cn-beijing.aliyuncs.com/frontend/assets/img/alignitemcenter.png" alt="alignitemcenter"></p><ul><li>baseline: 项目的第一行文字的基线对齐</li></ul><p><img src="https://greenhaha.oss-cn-beijing.aliyuncs.com/frontend/assets/img/alignitembaseline.png" alt="baseline"><br>以文字的底部为主，仔细看图可以理解。</p><h4 id="align-content-定义了多根轴线的对齐方式，如果项目只有一根轴线，那么该属性将不起作用"><a href="#align-content-定义了多根轴线的对齐方式，如果项目只有一根轴线，那么该属性将不起作用" class="headerlink" title="align-content: 定义了多根轴线的对齐方式，如果项目只有一根轴线，那么该属性将不起作用"></a>align-content: 定义了多根轴线的对齐方式，如果项目只有一根轴线，那么该属性将不起作用</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">align-content</span>: flex-start | flex-end | center | space-between | space-around | stretch;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>当<code>flex-wrap</code>设置之后 默认情况下 容器中只会有一条轴线，子元素是不会换行的，因此不会产生其他轴线。<br>但是<code>flex-wrap</code>设置为<code>wrap</code> 换行属性之后，容器中可能会出现其他轴线，这时候就需要去设置轴线的对齐方式了</p><ul><li>默认值：stretch<br><img src="https://greenhaha.oss-cn-beijing.aliyuncs.com/frontend/assets/img/aligncontentstretch.png" alt="aligncontentstretch"><br>从图可以看出又三条轴线(因为容器宽度有限)，当值为 stretch 时会三条轴线平分容器的垂直方向上的空间。</li></ul><p>虽然在每条轴线上项目的默认值也为 stretch，但是由于我每个子元素我都设置了高度，所以它并没有撑开整个容器。如果项目不设置高度的话就会变成下面这样：<br><img src="https://greenhaha.oss-cn-beijing.aliyuncs.com/frontend/assets/img/aligncontentstretch2.png" alt="aligncontentstretch"><br>前面也有提到(align-items)，这里重点还是理解三条轴线会平分垂直轴上的空间。</p><ul><li><p>flex-start：轴线全部在交叉轴上的起点对齐<br><img src="https://greenhaha.oss-cn-beijing.aliyuncs.com/frontend/assets/img/aligncontentflexstart.png" alt="aligncontentflexstart"></p></li><li><p>flex-end：轴线全部在交叉轴上的终点对齐<br><img src="https://greenhaha.oss-cn-beijing.aliyuncs.com/frontend/assets/img/aligncontentflexend.png" alt="aligncontentflexend"></p></li><li><p>center: 轴线全部在交叉轴上的中间对齐<br><img src="https://greenhaha.oss-cn-beijing.aliyuncs.com/frontend/assets/img/aligncontentcenter.png" alt="aligncontencenter"></p></li><li><p>space-between: 轴线两端对齐，之间的间隔相等，即剩余空间等分成间隙<br><img src="https://greenhaha.oss-cn-beijing.aliyuncs.com/frontend/assets/img/aligncontentspacebetween.png" alt="aligncontentspacebetween"></p></li><li><p>space-around：每个轴线两侧的间隔相等，所以轴线之间的间隔比轴线与边缘的间隔大一倍。</p></li></ul><p><img src="https://greenhaha.oss-cn-beijing.aliyuncs.com/frontend/assets/img/aligncontentspacearound.png" alt="aligncontentspacearound"></p><h3 id="Flex-子元素"><a href="#Flex-子元素" class="headerlink" title="Flex 子元素"></a>Flex 子元素</h3><ul><li>order</li><li>flex-basis</li><li>flex-grow</li><li>flex-shrink</li><li>flex</li><li>align-self</li></ul><p>以上6中属性作用在子元素上</p><ul><li>order: 定义项目在容器中的排列顺序，数值越小，排列越靠前，默认值为 0<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">    <span class="attribute">order</span>: &lt;integer&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><img src="https://greenhaha.oss-cn-beijing.aliyuncs.com/frontend/assets/img/order.png" alt="order"></p><p>在 HTML 结构中，虽然 -2，-1 的 item 排在后面，但是由于分别设置了 order，使之能够排到最前面。<br>可以理解为order 数值越小排列的时候越排在前面</p><ul><li>flex-basis：定义了在分配多余空间之前，项目占据的主轴空间，浏览器根据这个属性，计算主轴是否有多余空间</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">    <span class="attribute">flex-basis</span>: &lt;length&gt; | auto;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>默认值：auto，即子元素自身大小，<br>当主轴为水平方向的时候，当设置了 flex-basis，项目的宽度设置值会失效，flex-basis 需要跟 flex-grow 和 flex-shrink 配合使用才能发挥效果。</p><blockquote><ul><li>当 flex-basis 值为 0 % 时，是把该项目视为零尺寸的，故即使声明该尺寸为 140px，也并没有什么用。</li><li>当 flex-basis 值为 auto 时，则跟根据尺寸的设定值(假如为 100px)，则这 100px 不会纳入剩余空间。</li></ul></blockquote><ul><li>flex-grow:定义子元素放大比例</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">    <span class="attribute">flex-grow</span>: &lt;number&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>默认值：0，flex布局后即使存在剩余空间也不会放大<br><img src="https://greenhaha.oss-cn-beijing.aliyuncs.com/frontend/assets/img/flexgrow.png" alt="flexgrow"><br>当所有的项目都以 flex-basis 的值进行排列后，仍有剩余空间，那么这时候 flex-grow 就会发挥作用了。<br>如果所有项目的 flex-grow 属性都为 1，则它们将等分剩余空间。(如果有的话)</p><p>如果一个项目的 flex-grow 属性为 2，其他项目都为 1，则前者占据的剩余空间将比其他项多一倍。</p><p>当然如果当所有项目以 flex-basis 的值排列完后发现空间不够了，且 flex-wrap：nowrap 时，此时 flex-grow 则不起作用了，这时候就需要接下来的这个属性。</p><ul><li>flex-shrink:定义了项目的缩小比例</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">    <span class="attribute">flex-shrink</span>: &lt;number&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>默认值: 1，即如果空间不足，该项目将缩小，负值对该属性无效。<br><img src="https://greenhaha.oss-cn-beijing.aliyuncs.com/frontend/assets/img/flexshrink.png" alt="flex-shrink"><br>每个子元素都设置了宽度为 50px，但是由于自身容器宽度只有 200px，这时候每个子元素会被同比例进行缩小，因为默认值为 1。</p><blockquote><ul><li>如果所有项目的 flex-shrink 属性都为 1，当空间不足时，都将等比例缩小。</li><li>如果一个项目的 flex-shrink 属性为 0，其他项目都为 1，则空间不足时，前者不缩小。</li></ul></blockquote><ul><li>flex: flex-grow, flex-shrink 和 flex-basis的简写</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item</span>&#123;</span><br><span class="line">    <span class="attribute">flex</span>: none | [ &lt;<span class="string">&#x27;flex-grow&#x27;</span>&gt; &lt;<span class="string">&#x27;flex-shrink&#x27;</span>&gt;? || &lt;<span class="string">&#x27;flex-basis&#x27;</span>&gt; ]</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>flex 的默认值是以上三个属性值的组合。假设以上三个属性同样取默认值，则 flex 的默认值是 0 1 auto。</p><p>有关快捷值：auto (1 1 auto) 和 none (0 0 auto)</p><p>关于 flex 取值，还有许多特殊的情况，可以按以下来进行划分：</p><p>当 flex 取值为一个非负数字，则该数字为 flex-grow 值，flex-shrink 取 1，flex-basis 取 0%，如下是等同的：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;<span class="attribute">flex</span>: <span class="number">1</span>;&#125;</span><br><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">    <span class="attribute">flex-grow</span>: <span class="number">1</span>;</span><br><span class="line">    <span class="attribute">flex-shrink</span>: <span class="number">1</span>;</span><br><span class="line">    <span class="attribute">flex-basis</span>: <span class="number">0%</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当 flex 取值为 0 时，对应的三个值分别为 0 1 0%</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;<span class="attribute">flex</span>: <span class="number">0</span>;&#125;</span><br><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">    <span class="attribute">flex-grow</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">flex-shrink</span>: <span class="number">1</span>;</span><br><span class="line">    <span class="attribute">flex-basis</span>: <span class="number">0%</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当 flex 取值为一个长度或百分比，则视为 flex-basis 值，flex-grow 取 1，flex-shrink 取 1，有如下等同情况（注意 0% 是一个百分比而不是一个非负数字）</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item-1</span> &#123;<span class="attribute">flex</span>: <span class="number">0%</span>;&#125;</span><br><span class="line"><span class="selector-class">.item-1</span> &#123;</span><br><span class="line">    <span class="attribute">flex-grow</span>: <span class="number">1</span>;</span><br><span class="line">    <span class="attribute">flex-shrink</span>: <span class="number">1</span>;</span><br><span class="line">    <span class="attribute">flex-basis</span>: <span class="number">0%</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.item-2</span> &#123;<span class="attribute">flex</span>: <span class="number">24px</span>;&#125;</span><br><span class="line"><span class="selector-class">.item-2</span> &#123;</span><br><span class="line">    <span class="attribute">flex-grow</span>: <span class="number">1</span>;</span><br><span class="line">    <span class="attribute">flex-shrink</span>: <span class="number">1</span>;</span><br><span class="line">    <span class="attribute">flex-basis</span>: <span class="number">24px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当 flex 取值为两个非负数字，则分别视为 flex-grow 和 flex-shrink 的值，flex-basis 取 0%，如下是等同的：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;<span class="attribute">flex</span>: <span class="number">2</span> <span class="number">3</span>;&#125;</span><br><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">    <span class="attribute">flex-grow</span>: <span class="number">2</span>;</span><br><span class="line">    <span class="attribute">flex-shrink</span>: <span class="number">3</span>;</span><br><span class="line">    <span class="attribute">flex-basis</span>: <span class="number">0%</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当 flex 取值为一个非负数字和一个长度或百分比，则分别视为 flex-grow 和 flex-basis 的值，flex-shrink 取 1，如下是等同的：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;<span class="attribute">flex</span>: <span class="number">11</span> <span class="number">32px</span>;&#125;</span><br><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">    <span class="attribute">flex-grow</span>: <span class="number">11</span>;</span><br><span class="line">    <span class="attribute">flex-shrink</span>: <span class="number">1</span>;</span><br><span class="line">    <span class="attribute">flex-basis</span>: <span class="number">32px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>建议优先使用这个属性，而不是单独写三个分离的属性。</p><p>grow 和 shrink 是一对双胞胎，grow 表示伸张因子，shrink 表示是收缩因子。</p><p>grow 在 flex 容器下的子元素的宽度和比容器和小的时候起作用。 grow 定义了子元素的尺寸增长因子，容器中除去子元素之和剩下的尺寸会按照各个子元素的 grow 值进行平分加大各个子元素上。</p><blockquote><ul><li>当 flex-wrap 为 wrap | wrap-reverse，且子项宽度和不及父容器宽度时，flex-grow 会起作用，子项会根据 flex-grow 设定的值放大（为0的项不放大）</li><li>当 flex-wrap 为 wrap | wrap-reverse，且子项宽度和超过父容器宽度时，首先一定会换行，换行后，每一行的右端都可能会有剩余空间（最后一行包含的子项可能比前几行少，所以剩余空间可能会更大），这时 flex-grow 会起作用，若当前行所有子项的 flex-grow 都为0，则剩余空间保留，若当前行存在一个子项的 flex-grow 不为0，则剩余空间会被 flex-grow 不为0的子项占据</li><li>当 flex-wrap 为 nowrap，且子项宽度和不及父容器宽度时，flex-grow 会起作用，子项会根据 flex-grow 设定的值放大（为0的项不放大）</li><li>当 flex-wrap 为 nowrap，且子项宽度和超过父容器宽度时，flex-shrink 会起作用，子项会根据 flex-shrink 设定的值进行缩小（为0的项不缩小）。但这里有一个较为特殊情况，就是当这一行所有子项 flex-shrink 都为0时，也就是说所有的子项都不能缩小，就会出现讨厌的横向滚动条</li></ul></blockquote><p>总结上面四点，可以看出不管在什么情况下，在同一时间，flex-shrink 和 flex-grow 只有一个能起作用，这其中的道理细想起来也很浅显：空间足够时，flex-grow 就有发挥的余地，而空间不足时，flex-shrink 就能起作用。当然，flex-wrap 的值为 wrap | wrap-reverse 时，表明可以换行，既然可以换行，一般情况下空间就总是足够的，flex-shrink 当然就不会起作用</p><ul><li>align-self: 允许单个项目有与其他项目不一样的对齐方式</li></ul><p>每个子元素覆盖<code>align-self</code>定义的属性<br>默认值：auto，表示继承父元素的 align-items 属性，如果没有父元素，则等同于 stretch。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">     <span class="attribute">align-self</span>: auto | flex-start | flex-end | center | baseline | stretch;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这个跟 <code>align-items</code> 属性时一样的，只不过 <code>align-self</code> 是对单个子元素生效的，而 <code>align-items</code> 则是对容器下的所有子元素生效的。</p><p><img src="https://greenhaha.oss-cn-beijing.aliyuncs.com/frontend/assets/img/alignself.png" alt="align-self"><br>容器 align-items 设置为 flex-start，而第三</p><h2 id="Grid布局（网格布局）"><a href="#Grid布局（网格布局）" class="headerlink" title="Grid布局（网格布局）"></a>Grid布局（网格布局）</h2><p>Flexbox用于设计横向或纵向的布局，而Grid布局则被设计用于同时在两个维度上把元素按行和列排列整齐。它是最强大的css布局方案<br><br>它将网页划分成一个个网格，可以任意组合不同的网格，做出各种各样的布局。以前，只能通过复杂的 CSS 框架达到的效果，现在浏览器内置了<br><img src="https://greenhaha.oss-cn-beijing.aliyuncs.com/frontend/assets/img/gridcss.png" alt="grid"></p><p>Grid布局与Flex布局有一定的相似性，都可以指定容器内部多个项目的位置。但是他们有一定的区别。<br>Flex 布局是轴线布局，只能指定“项目”（子元素）针对轴线的位置，可以看作是一维布局。Grid布局则是将容器划分“行”和“列”，产生单元格，<br>然后指定“项目所在“的单元格。可以看作是二维布局。Grid布局远比Flex布局强大。</p><h3 id="基本概念-1"><a href="#基本概念-1" class="headerlink" title="基本概念"></a>基本概念</h3><ul><li>容器与项目<br>采用网格布局的区域，称为“容器”（container）。 容器内部采用网格定位的子元素。称为”项目“（item）<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;<span class="name">p</span>&gt;</span>1<span class="tag">&lt;/<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;<span class="name">p</span>&gt;</span>2<span class="tag">&lt;/<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;<span class="name">p</span>&gt;</span>3<span class="tag">&lt;/<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>上面代码中，最外层的<code>&lt;div&gt;</code>元素就是容器，内层的三个<code>&lt;div&gt;</code>元素就是项目。</li></ul><blockquote><p>注意：项目只能是容器的顶层子元素，不包含项目的子元素，比如上面代码的<code>&lt;p&gt;</code>元素就不是项目。Grid 布局只对项目生效。</p></blockquote><ul><li>行和列<br>容器里面的水平区域称为“行”（row），垂直区域称为“列”（column）<br><img src="https://greenhaha.oss-cn-beijing.aliyuncs.com/frontend/assets/img/row.png" alt="row-column"></li></ul><p>上图中，水平的深色区域就是”行”，垂直的深色区域就是”列”。</p><ul><li>单元格</li></ul><p>行和列的交叉区域，称为”单元格”（cell）。</p><p>正常情况下，n行和m列会产生n x m个单元格。比如，3行3列会产生9个单元格。</p><ul><li>网格线<br>划分网格的线，称为”网格线”（grid line）。水平网格线划分出行，垂直网格线划分出列。</li></ul><p>正常情况下，n行有n + 1根水平网格线，m列有m + 1根垂直网格线，比如三行就有四根水平网格线。</p><p><img src="https://greenhaha.oss-cn-beijing.aliyuncs.com/frontend/assets/img/%E7%BD%91%E6%A0%BC%E7%BA%BF.png" alt="网格线"><br>上图是一个 4 x 4 的网格，共有5根水平网格线和5根垂直网格线。</p><h3 id="容器属性"><a href="#容器属性" class="headerlink" title="容器属性"></a>容器属性</h3><p>Grid布局的属性分为2种，一种定义在容器上面，称为容器属性；另一种定义在项目上面，称为项目属性</p><ul><li>display属性<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span>&#123;</span><br><span class="line">    <span class="attribute">display</span>: grid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="https://greenhaha.oss-cn-beijing.aliyuncs.com/frontend/assets/img/displaygrid.png" alt="display:grid"><br>上图是<code>display: grid</code>的<a href="https://jsbin.com/guvivum/edit?html,css,output">效果</a>。</li></ul><p>默认情况下，容器元素都是块级元素，但也可以设计成行内元素</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span>&#123;</span><br><span class="line">    <span class="attribute">display</span>: inline-grid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码指定div 是一个行内元素并且该元素采用网格布局<br><img src="https://greenhaha.oss-cn-beijing.aliyuncs.com/frontend/assets/img/inlinegrid.png" alt="inlinegrid"></p><blockquote><p>注意⚠️： 设置为网格布局后，容器子元素的 <code>float</code>、<code>display: inline-block</code>、<code>dispaly: table-cell</code>、<code>vertical-align</code>、<code>column-*</code> 等设置都失效。</p></blockquote><ul><li>gird-template-columns 属性 &amp; grid-template-rows 属性<br>容器指定了网格布局以后，接着就要划分行和列。<code>grid-template-columns</code>属性定义每一列的列宽，<code>grid-template-rows</code>属性定义每一行的行高。</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: grid;</span><br><span class="line">    grid-template-<span class="attribute">columns</span>: <span class="number">100px</span> <span class="number">100px</span> <span class="number">100px</span>;</span><br><span class="line">    grid-template-rows: <span class="number">100px</span> <span class="number">100px</span> <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上方代码指定一个三行三列的网格，行宽和行高都是<code>100px</code>.<br><img src="https://greenhaha.oss-cn-beijing.aliyuncs.com/frontend/assets/img/gridtemplaterow.png" alt="gridtemplaterows"><br>对于单位的使用没有特殊限制 <code>%</code> 或者绝对单位 <a href="https://jsbin.com/povapisuma/edit?html,css,output">效果</a></p><ol><li>repeat()</li></ol><p><code>repeat()</code>函数可以简化重复的值</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span>&#123;</span><br><span class="line">    <span class="attribute">display</span>: grid;</span><br><span class="line">    grid-template-<span class="attribute">columns</span>: <span class="built_in">repeat</span>(<span class="number">3</span>, <span class="number">90px</span>);</span><br><span class="line">    grid-template-rows: <span class="built_in">repeat</span>(<span class="number">3</span>, <span class="number">80px</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>repeate(x, y)</code> 接受2个参数<br>x：表示重复的次数<br>y：表示参数重复的值</p><p><code>repeat()</code>重复某种模式也是可以的</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grid-template-<span class="attribute">columns</span>: <span class="built_in">repeat</span>(<span class="number">2</span>, <span class="number">100px</span> <span class="number">90px</span> <span class="number">120px</span>);</span><br></pre></td></tr></table></figure><p><a href="https://jsbin.com/hovemudute/edit?html,css,output">上方代码效果</a><br><img src="https://greenhaha.oss-cn-beijing.aliyuncs.com/frontend/assets/img/repeat.png" alt="repeat1"></p><ol start="2"><li>auto-file 关键字</li></ol><p>单元格大小是固定的，但是容器的大小不确定。如果想要每一行（或每一列）容纳尽可能多的单元格，这时可以使用<code>auto-fill</code> 关键字表示自动填充。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span>&#123;</span><br><span class="line">    <span class="attribute">display</span>: grid;</span><br><span class="line">    grid-template-<span class="attribute">columns</span>: <span class="built_in">repeat</span>(auto-fill, <span class="number">110px</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://jsbin.com/vegevemuhe/edit?html,css,output">代码</a>表示每列宽度<code>100px</code>,  然后自动填充，知道容器不能放置更多的列<br><img src="https://greenhaha.oss-cn-beijing.aliyuncs.com/frontend/assets/img/autofill.png" alt="auto-fill"></p><ol start="3"><li>fr关键字</li></ol><p>为方便表示比例关系，网格布局提供了<code>fr</code>关键字（fraction的缩写，译为 “片段”）。如果两列宽度分别为<code>1fr</code>和<code>2fr</code>,就表示后者是前者的2倍。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span>&#123;</span><br><span class="line">    <span class="attribute">display</span>: grid;</span><br><span class="line">    grid-template-<span class="attribute">columns</span>: <span class="number">1</span>fr <span class="number">1</span>fr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://jsbin.com/hadexek/edit?html,css,output">上面代码</a>表示2个相同的宽度<br><img src="https://greenhaha.oss-cn-beijing.aliyuncs.com/frontend/assets/img/fr.png" alt="fr"></p><p>fr可以与绝对长度的单位结合使用，很方便</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span>&#123;</span><br><span class="line">    <span class="attribute">display</span>: grid;</span><br><span class="line">    grid-template-<span class="attribute">columns</span>: <span class="number">150px</span> <span class="number">1</span>fr <span class="number">2</span>fr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://jsbin.com/remowec/edit?html,css,output">上面代码</a>表示，第一列的宽度为150像素，第二列的宽度是第三列的一半。<br><img src="https://greenhaha.oss-cn-beijing.aliyuncs.com/frontend/assets/img/frpx.png" alt="frpx"></p><ol start="4"><li>minmax()</li></ol><p><code>minmax()</code>函数产生一个长度范围，表示长度就在这个范围之中，他接受2个参数，minmax(x, y)</p><p>x: 最小值<br>y: 最大值</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grid--template-<span class="attribute">columns</span>: <span class="number">1</span>fr <span class="number">1</span>fr <span class="built_in">minmax</span>(<span class="number">100px</span>, <span class="number">1</span>fr);</span><br></pre></td></tr></table></figure><p>上面代码中，minmax(100px, 1fr)表示列宽不小于100px，不大于1fr</p><ol start="5"><li>auto 关键字<br><code>auto</code>关键字表示由路由器自己决定长度<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grid-template-columns: 100px auto 100px</span><br></pre></td></tr></table></figure></li></ol><p>上面的代码中第二列的宽度，基本上等于改列单元格的最大宽度，除非单元格内容设置了<code>min-width</code>, 且这个值大于最大宽度。</p><ol start="6"><li>网格线的名称<br><code>grid-template-columns</code>属性和<code>grid-template-rows</code>属性里面，还可以使用方括号，指定每一根网格线的名称，方便使用</li></ol><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span>&#123;</span><br><span class="line">    <span class="attribute">display</span>: grid;</span><br><span class="line">    grid-template-<span class="attribute">columns</span>:  [c1] <span class="number">100px</span> [c2] <span class="number">100px</span> [c3] auto [c4];</span><br><span class="line">    grid-template-rows: [r1] <span class="number">100px</span> [r2] <span class="number">100px</span> [r3] auto [r4];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码指定网格布局为3行x3列，因此有4根垂直网格线和4根水平网格线。方括号里面依次是这八根线的名称。<br>网格布局允许同一根线有多个名称。比如<code>[fifth-line row-5]</code></p><ol start="7"><li>布局实例</li></ol><p><code>grid-template-columns</code> 属性对于网页布局非常好用。两栏式布局只需要一行代码</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.wrapper</span>&#123;</span><br><span class="line">    <span class="attribute">display</span>: grid;</span><br><span class="line">    grid-template-<span class="attribute">columns</span>: <span class="number">70%</span> <span class="number">30%</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>传统的十二网格布局也很容易</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grid-template-<span class="attribute">columns</span>: <span class="built_in">repeat</span>(<span class="number">12</span>, <span class="number">1</span>fr)</span><br></pre></td></tr></table></figure><ul><li>grid-row-gap 属性 &amp; grid-column-gap 属性 &amp; grid-gap 属性</li></ul><p><code>grid-row-gap</code> 属性设置行与行的间隔（行间距）， <code>grid-columns-gap</code>属性设置列与列的间隔（列间距）</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span>&#123;</span><br><span class="line">    grid-row-gap: <span class="number">20px</span>;</span><br><span class="line">    grid-<span class="attribute">column-gap</span>: <span class="number">20px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://jsbin.com/mezufab/edit?html,css,output">上面代码中</a>,<code>grid-row-gap</code>用于设置行间距，<code>grid-column-gap</code> 用于设置列间距。<br><img src="https://greenhaha.oss-cn-beijing.aliyuncs.com/frontend/assets/img/gridrowcolumngap.png" alt="grid-row-gap&amp;grid-column-gap"></p><p><code>grid-gap</code>属性是<code>grid-column-gap</code>和<code>grid-row-gap</code>合并简写形式</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grid-gap: &lt;grid-row-gap&gt; &lt;grid-column-gap&gt;</span><br></pre></td></tr></table></figure><p>上面的一段CSS代码等同于下面的代码</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span>&#123;</span><br><span class="line">    grid-gap: <span class="number">20px</span> <span class="number">20px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果<code>grid-gap</code>省略了第二个值，浏览器认为第二个值等于第一个值</p><blockquote><p>更具最新标准，上面三个属性名称<code>grid-</code>前缀已经删除，<code>grid-column-gap</code>和<code>grid-row-gap</code>写成<code>column-gap</code>和<code>row-gap</code>， <code>grid-gap</code>写成<code>gap</code> </p></blockquote><ul><li>grid-template-areas 属性</li></ul><p>网格布局允许指定“区域”（area）， 一个区域由单个或多个单元格组成。<code>grid-template-areas</code> 属性用于定义区域。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: grid;</span><br><span class="line">  grid-template-<span class="attribute">columns</span>: <span class="number">100px</span> <span class="number">100px</span> <span class="number">100px</span>;</span><br><span class="line">  grid-template-rows: <span class="number">100px</span> <span class="number">100px</span> <span class="number">100px</span>;</span><br><span class="line">  grid-template-areas: <span class="string">&#x27;a b c&#x27;</span></span><br><span class="line">                       <span class="string">&#x27;d e f&#x27;</span></span><br><span class="line">                       <span class="string">&#x27;g h i&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码先划出9个单元格，然后将其定名为<code>a</code>到<code>i</code>的九个区域，分别对应这九个单元格。</p><h2 id="定位"><a href="#定位" class="headerlink" title="定位"></a>定位</h2>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;</summary>
        
      
    
    
    
    <category term="知识剖析" scheme="http://example.com/categories/%E7%9F%A5%E8%AF%86%E5%89%96%E6%9E%90/"/>
    
    
    <category term="浏览器" scheme="http://example.com/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
    <category term="CSS" scheme="http://example.com/tags/CSS/"/>
    
    <category term="布局" scheme="http://example.com/tags/%E5%B8%83%E5%B1%80/"/>
    
  </entry>
  
  <entry>
    <title>快速搭建一个MOCKSERVE服务器</title>
    <link href="http://example.com/2021/07/05/%E6%90%AD%E5%BB%BAmockserve/"/>
    <id>http://example.com/2021/07/05/%E6%90%AD%E5%BB%BAmockserve/</id>
    <published>2021-07-05T12:30:22.000Z</published>
    <updated>2024-01-02T01:12:08.529Z</updated>
    
    <content type="html"><![CDATA[<h1 id="如何快速搭建一个mockserve服务器"><a href="#如何快速搭建一个mockserve服务器" class="headerlink" title="如何快速搭建一个mockserve服务器"></a>如何快速搭建一个mockserve服务器</h1><h2 id="什么是mock"><a href="#什么是mock" class="headerlink" title="什么是mock"></a>什么是mock</h2><p>如果将mock单独翻译过来，其意义为 “虚假、虚设”，因此在软件开发领域，我们也可以将其理解成 “虚假数据”，或者 “真实数据的替身”。</p><h2 id="mock的好处"><a href="#mock的好处" class="headerlink" title="mock的好处"></a>mock的好处</h2><ul><li>团队可以更好地并行工作</li></ul><p>当使用mock之后，各团队之间可以不需要再互相等待对方的进度，只需要约定好相互之间的数据规范（文档），即可使用mock构建一个可用的接口，然后尽快的进行开发和调试以及自测，提升开发进度的的同时，也将发现缺陷的时间点大大提前。</p><ul><li>开启TDD（Test-Driven Development）模式，即测试驱动开发</li></ul><p>单元测试是TDD实现的基石，而TDD经常会碰到协同模块尚未开发完成的情况，但是有了mock，这些一切都不是问题。当接口定义好后，测试人员就可以创建一个Mock，把接口添加到自动化测试环境，提前创建测试。</p><ul><li>测试覆盖率</li></ul><p>比如一个接口在各种不同的状态下要返回不同的值，之前我们的做法是复现这种状态然后再去请求接口，这是非常不科学的做法，而且这种复现方法很大可能性因为操作的时机或者操作方式不当导致失败，甚至污染之前数据库中的数据。如果我们使用mock，就完全不用担心这些问题。</p><ul><li>方便演示</li></ul><p>通过使用Mock模拟数据接口，我们即可在只开发了UI的情况下，无须服务端的开发就可以进行产品的演示。</p><ul><li>隔离系统</li></ul><p>在使用某些接口的时候，为了避免系统中数据库被污染，我们可以将这些接口调整为Mock的模式，以此保证数据库的干净。</p><h2 id="如何快速实现一个mockserve"><a href="#如何快速实现一个mockserve" class="headerlink" title="如何快速实现一个mockserve"></a>如何快速实现一个mockserve</h2><h3 id="什么是mockserve"><a href="#什么是mockserve" class="headerlink" title="什么是mockserve"></a>什么是mockserve</h3><p>专门实现 mock 功能的一个服务。</p><h3 id="mockserve-的作用"><a href="#mockserve-的作用" class="headerlink" title="mockserve 的作用"></a>mockserve 的作用</h3><p>的业务系统很少有孤立存在的，它们或多或少需要使用兄弟团队或是其他公司提供的服务，这给我们的联调和测试造成了麻烦。对于这种情况，我们常见的解决方案是搭建一个临时的server，模拟那些服务，提供数据进行联调和测试。这就是 mock server 出现原因。</p><p><img src="https://greenhaha.oss-cn-beijing.aliyuncs.com/frontend/assets/img/mockserve.png" alt="mockserve"></p><h3 id="mock数据的几种方式"><a href="#mock数据的几种方式" class="headerlink" title="mock数据的几种方式"></a>mock数据的几种方式</h3><ol><li><p>直接在页面写死数据，后期等接口来了，再改成动态的; </p></li><li><p>在js里直接声明变量，并给变量赋值，在逻辑脚本中使用，并渲染到dom;</p></li><li><p>将模拟数据编辑成json数据或者是零碎的js脚本中，通过请求，取回数据，并进行业务逻辑处理，渲染到dom</p></li><li><p>最理想化的</p></li></ol><ul><li><p>前后台在需求分解之后，一起定义好接口api，包含：请求url（项目前缀+具体的接口名称）、请求方式、请求参数、数据响应；</p></li><li><p>前端研发人员根据接口约定，模拟请求返回对应的数据，完成对应的交互；</p></li><li><p>后台人员根据接口约定，完成对应的api，并完成对应的自测；</p></li><li><p>待后台人员交付接口api后，前端人员直接修改接口项目前缀，切换到对应的环境，即可进入项目提测。</p></li></ul><h3 id="如何使用web框架快速搭建mockserve"><a href="#如何使用web框架快速搭建mockserve" class="headerlink" title="如何使用web框架快速搭建mockserve"></a>如何使用web框架快速搭建mockserve</h3><p>这个mockserve是基于 express+mock.js+nodemon 来构建的</p><p>Express 是一个基于 Node 平台的 Web 开发框架，使用它可以很方便的搭建本地Web 服务。用来部署我们的 Mock 数据，Express 可以通过 npm 来安装，其官网地址如下：<a href="http://www.expressjs.com.cn/">http://www.expressjs.com.cn/</a> 其中有详细安装方法</p><p>Mock.js 是一个模拟数据结构、生成随机数据的 JavaScript 库，有一套语法规则用来模拟结构和生成数据。其安装过程也很简单，官网地址：<a href="http://mockjs.com/">http://mockjs.com/</a></p><p>nodemon node进程自动重启，监听文件</p><h3 id="搭建步骤："><a href="#搭建步骤：" class="headerlink" title="搭建步骤："></a>搭建步骤：</h3><p>首先本地创建项目工程文件夹，名字随意 然后进入到创建的文件夹中</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> express_mockserve</span><br></pre></td></tr></table></figure><p>利用npm或者yarn 本地初始化工程</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn init</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm init</span><br></pre></td></tr></table></figure><p>安装相关依赖包依赖包</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install express mockjs nodemon</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn add express mockjs nodemon</span><br></pre></td></tr></table></figure><p>安装完成后，打开package.json文件，在script对象中加入下列代码</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;mock:serve&quot;</span>: <span class="string">&quot;nodemon express_mockserve/index.js --watch express_mockserve/*&quot;</span></span><br></pre></td></tr></table></figure><blockquote><p>作用：利用nodemon 自动启动node并监听目标文件更改，如果更改自动热更新</p></blockquote><p>然后创建<code>index.js</code> 工程启动文件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> app = express();</span><br><span class="line"><span class="keyword">var</span> data = &#123;</span><br><span class="line">    <span class="attr">name</span> : <span class="string">&quot;jack&quot;</span>,</span><br><span class="line">    <span class="attr">age</span> : <span class="number">25</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">&#x27;/mock&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req,res</span>) </span>&#123;</span><br><span class="line">    res.send(<span class="built_in">JSON</span>.stringify(data));</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">var</span> server = app.listen(<span class="number">8001</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上面的代码使用 Express 搭建了一个简单的本地服务器，在终端使用 Node 执行此 JavaScript 程序，在浏览器中输入如下地址，进行 GET 请求，就可以看到已经获取到本地服务器返回的数据。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://localhost:8001/mock</span><br></pre></td></tr></table></figure><p>下面借助 Mock.js 来随机生成模拟数据，修改上面代码如下</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> Mock = <span class="built_in">require</span>(<span class="string">&#x27;mockjs&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> app = express();</span><br><span class="line"><span class="keyword">var</span> data = Mock.mock(&#123;</span><br><span class="line"></span><br><span class="line">    <span class="string">&#x27;people|1-10&#x27;</span> : [&#123;</span><br><span class="line">        <span class="attr">name</span> : <span class="string">&quot;@cname&quot;</span>,</span><br><span class="line">        <span class="string">&#x27;age|10-40&#x27;</span> : <span class="number">0</span>,</span><br><span class="line">        <span class="comment">// 属性 id 是一个自增数，起始值为 1，每次增 1</span></span><br><span class="line">        <span class="string">&#x27;id|+1&#x27;</span>: <span class="number">1</span></span><br><span class="line">    &#125;]</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">&#x27;/people&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req,res</span>) </span>&#123;</span><br><span class="line">    res.send(<span class="built_in">JSON</span>.stringify(data));</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">var</span> server = app.listen(<span class="number">8001</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上面代码使用了 Mock.js 中生成随机数据的一些语法，重启Node服务，再次刷新浏览器，就会看到效果。。<br>具体的 Mock.js 模拟数据的语法和规则可以在 <a href="https://github.com/nuysoft/Mock/wiki/Getting-Started">https://github.com/nuysoft/Mock/wiki/Getting-Started</a> 查看</p><p>项目demo：<a href="https://github.com/greenhaha/exprssmockserve">地址</a></p><h3 id="关于express搭建mockserve跨域问题"><a href="#关于express搭建mockserve跨域问题" class="headerlink" title="关于express搭建mockserve跨域问题"></a>关于express搭建mockserve跨域问题</h3><p>如果express搭建mockserve产生跨域问题 通常有2中解决方案：</p><ol><li><p>安装解决跨域中间件 <code>cors</code><br>使用发放</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install cors --save-dev</span><br></pre></td></tr></table></figure><p>然后再工程的入口文件里 加入下列代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const cors = require(&#x27;cors&#x27;);</span><br><span class="line">app.use(cors());</span><br></pre></td></tr></table></figure></li><li><p>手动实现解决方案</p></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">app.use(<span class="function">(<span class="params">req, res, next</span>) =&gt;</span> &#123;</span><br><span class="line">res.header(<span class="string">&#x27;Access-Control-Allow-Origin&#x27;</span>, <span class="string">&#x27;*&#x27;</span>)</span><br><span class="line">res.header(<span class="string">&#x27;Access-Control-Allow-Headers&#x27;</span>, <span class="string">&#x27;Authorization,X-API-KEY, Origin, X-Requested-With, Content-Type, Accept, Access-Control-Request-Method&#x27;</span> )</span><br><span class="line">res.header(<span class="string">&#x27;Access-Control-Allow-Methods&#x27;</span>, <span class="string">&#x27;GET, POST, OPTIONS, PATCH, PUT, DELETE&#x27;</span>)</span><br><span class="line">res.header(<span class="string">&#x27;Allow&#x27;</span>, <span class="string">&#x27;GET, POST, PATCH, OPTIONS, PUT, DELETE&#x27;</span>)</span><br><span class="line">next();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>注：方案2中不同的值在解决跨域中起到不同的作用</p><ul><li>Access-Control-Allow-Origin<br><code>Access-Control-Allow-Origin</code> 是一个html5中添加的CORS(Cross-Origin Resource Sharing)头<br>跨域访问时，B站点 通过在响应头中添加 Access-Control-Allow-Origin:<a href="http://sitea/">http://siteA</a> 向浏览器表示该资源可被A站点正常访问使用。除非添加了Access-Control-Allow-Origin响应头，否则默认情况下一个站点的资源不允许来自于其他域的任何XMLHttpRequest请求。</li></ul><p>对于B站点任意页面或者资源，如果想要允许被A站点访问，则应在页面或者资源请求的响应中添加相应头： Access-Control-Allow-Origin: <a href="http://sitea.com/">http://siteA.com</a></p><ul><li><p>Simple请求<br>现代浏览器不会完全阻止跨域请求。如果A站点请求B站点的一个页面P，浏览器实际上会在网络级拉取页面P，然后检查页面P响应头中A站点是否在允许列表中。如果响应中没有声明A站点具有访问权限，则浏览器会触发XMLHttpRequest’s error事件，并且阻止响应数据的执行。</p></li><li><p>Non-Simple 请求<br>真实发生的网络级请求实际上会稍微复杂一点。如果一个请求是Non-Simple的，浏览器首先会发送一个不包含数据的OPTIONS http请求，以此来验证服务器是否接受该站点的相应请求（GET,POST,PUT..etg.），一个Simple的请求需要同时满足以下两点：</p><ul><li>只能使用HTTP的GET,POST或者HEAD方法</li><li>只能使用Simple的请求头：<ul><li>Accept</li><li>Accept-Language</li><li>Content-Language</li><li>Last-Event-ID</li><li>Content-Type (Simple的请求定义中，content-type只能是application/x-www-form-urlencoded, multipart/form-data,或者 text/plain)<br>不符合这种情况的请求则是一个Non-Simple的请求，除此之外的http方法和http头叫做Non-Simple方法和头</li></ul></li></ul></li></ul><p>如果服务端对OPTIONS预请求的响应中包含了恰当的Non-Simple响应头(Access-Control-Allow-Headers,Access-Control-Allow-Methods),并且响应头的值中包含了真实要发生的请求的Non-Simple请求头和方法，浏览器才会继续发送真正的Non-Simple请求。</p><ul><li>Access-Control-Allow-Headers<br>响应首部 <code>Access-Control-Allow-Headers</code> 用于 preflight request （预检请求）中，列出了将会在正式请求的 Access-Control-Request-Headers 字段中出现的首部信息。</li></ul><p>简单首部，如 simple headers、Accept、Accept-Language、Content-Language、Content-Type （只限于解析后的值为 application/x-www-form-urlencoded、multipart/form-data 或 text/plain 三种MIME类型（不包括参数）），它们始终是被支持的，不需要在这个首部特意列出。</p><ul><li><p>Access-Control-Allow-Methods<br>响应首部 <code>Access-Control-Allow-Methods</code> 在对 preflight request.（预检请求）的应答中明确了客户端所要访问的资源允许使用的方法或方法列表。</p></li><li><p>Allow<br>Allow 首部字段用于枚举资源所支持的 HTTP 方法的集合。</p></li></ul><p>若服务器返回状态码 405 Method Not Allowed，则该首部字段亦需要同时返回给客户端。如果 Allow  首部字段的值为空，说明资源不接受使用任何 HTTP 方法的请求。这是可能的，比如服务器需要临时禁止对资源的任何访问。</p><blockquote><p>为什么访问url 没有端口号也可以访问对应页面工程<br>只有IP地址只可以发链路层的PING包侦测地址是否可达，页面传输是应用层的HTTP协议，从TCP/IP网络层开始，高层次的协议通信是要有ip加端口号的。浏览器默认80端口，一般而言tomcat也不会直接面对用户，前面会加一层代理层（Apache nginx），代理层的默认端口就是80。</p></blockquote>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;</summary>
        
      
    
    
    
    <category term="文档教程" scheme="http://example.com/categories/%E6%96%87%E6%A1%A3%E6%95%99%E7%A8%8B/"/>
    
    
    <category term="Node" scheme="http://example.com/tags/Node/"/>
    
    <category term="JavaScript" scheme="http://example.com/tags/JavaScript/"/>
    
    <category term="mockserve" scheme="http://example.com/tags/mockserve/"/>
    
    <category term="API" scheme="http://example.com/tags/API/"/>
    
  </entry>
  
  <entry>
    <title>NPM与YARN</title>
    <link href="http://example.com/2021/07/04/yarn%E4%B8%8Enpm/"/>
    <id>http://example.com/2021/07/04/yarn%E4%B8%8Enpm/</id>
    <published>2021-07-04T14:12:22.000Z</published>
    <updated>2024-01-02T01:12:08.521Z</updated>
    
    <content type="html"><![CDATA[<h2 id="NPM"><a href="#NPM" class="headerlink" title="NPM"></a>NPM</h2><h3 id="什么是npm？"><a href="#什么是npm？" class="headerlink" title="什么是npm？"></a>什么是npm？</h3><p>npm（全称 Node Package Manager，即“node包管理器”）是Node.js默认的、用JavaScript编写的软件包管理系统</p><blockquote><p>相关历史<br>npm完全有JavaScript编写，最初由艾萨克·施吕特（Isaac Z. Schlueter）开发。艾萨克表示自己意识到“模块管理很糟糕”的问题，并看到了PHP的PEAR与Perl的CPAN等软件的缺点，于是编写了npm。（<a href="https://github.com/nodejs/node-v0.x-archive/issues/5132#issuecomment-15432598">参考内容</a>）<br><br>2020年3月16 日，GitHub CEO Nat Friedman 宣布 GitHub 已签署收购 NPM（npm 背后的公司）的协议，并表示 npm 加入 GitHub 后会继续免费提供公共软件注册中心服务。</p></blockquote><h3 id="相关运行机制"><a href="#相关运行机制" class="headerlink" title="相关运行机制"></a>相关运行机制</h3><p>npm会随着Node.js自动安装。npm模块仓库提供了一个名为“registry”的查询服务，用户可通过本地的npm命令下载并安装指定模块。此外用户也可以通过npm把自己设计的模块分发到registry上面。</p><p>registry上面的模块通常采用CommonJS格式，而且都包含一个JSON格式的元文件。</p><p>npm的模块以“先到先得”的原则注册，各模块作者不会发生混乱。然而一旦有人撤回自己发布的模块，那么不仅会使依赖那个模块的项目出现问题，还会带来安全风险。例如有一个模块叫做“left-pad”，其中只有一个字符串对齐的功能。但是，当作者把它从registry里面移除之后，许多模块便无法正确构建。</p><p>npm的registry没有审核机制，因此会存在一些低质量、不安全甚至有害的模块，不过npm服务器的管理员也可以删除有害模块并阻止不怀好意的用户。</p><p>另外也有人为npm制作了统计功能，这样可以让开发者了解各模块的使用情况，帮助他们选择合适的模块。</p><h3 id="依赖安装过程"><a href="#依赖安装过程" class="headerlink" title="依赖安装过程"></a>依赖安装过程</h3><p>① 发出 npm install 命令<br>② 查询node_modules目录之中是否已经存在指定模块，若存在，不再重新安装<br>③ 若不存在，npm 向 registry 查询模块压缩包的网址④ 下载压缩包，存放在根目录下的.npm目录里⑤ 解压压缩包到当前项目的node_modules目录注意： 一个模块安装以后，本地其实保存了两份。一份是.npm目录下的压缩包，另一份是node_modules目录下解压后的代码。但是，运行npm install 的时候，只会检查node_modules目录，而不会检查.npm目录。也就是说，如果一个模块在.npm下有压缩包，但是没有安装在node_modules目录中，npm 依然会从远程仓库下载一次新的压缩包。</p><h3 id="package-和-package-json文件"><a href="#package-和-package-json文件" class="headerlink" title="package 和 package.json文件"></a>package 和 package.json文件</h3><p>package（包）是用javascript代码编写的功能包 package.json文件是包的描述文件，在每个项目的根目录下面。</p><ul><li>描述包的信息(比如名称、版本、入口文件等)，以便发布到npm registry</li><li>描述项目所需的依赖包，方便通过npm install下载安装 package.json文件的字段详情介绍参考：<br><a href="https://javascript.ruanyifeng.com/nodejs/packagejson.html">https://javascript.ruanyifeng.com/nodejs/packagejson.html</a></li></ul><p>npm 共享 JS 代码的过程就是：<br><img src="https://greenhaha.oss-cn-beijing.aliyuncs.com/frontend/assets/img/package.jpg" alt="npm"></p><ol><li>一个统一的package代码仓库 (npm官网)</li><li>编写自己的package和package.json文件(参考npm官方文档介绍)</li><li>通过 npm publish 把package放到这个仓库里</li><li>其他人的项目里想要使用某些package就写到package.json文件中，然后运行npm install，就会自动将这些代码下载下来，统一放到node_modules目录中。</li></ol><h3 id="npm-常用命令"><a href="#npm-常用命令" class="headerlink" title="npm 常用命令"></a>npm 常用命令</h3><ul><li><p>查看当前npm版本： npm -v</p></li><li><p>安装包 </p></li><li><ul><li>npm install 包名 </li></ul></li><li><ul><li>npm install 包名 -g : 全局安装，安装后在命令行任意目录下可直接使用包命令</li></ul></li><li><p>更新包： npm install 包名@latest</p></li><li><p>卸载包： npm uninstall 包名</p></li><li><p>根据guide创建一个package.json文件： npm init</p></li><li><p>换源：npm –registry 源地址</p></li></ul><h2 id="YARN"><a href="#YARN" class="headerlink" title="YARN"></a>YARN</h2><h3 id="什么是yarn"><a href="#什么是yarn" class="headerlink" title="什么是yarn"></a>什么是yarn</h3><p>正如官网主页写的yarn是快速、可靠、安全的依赖管理工具</p><ul><li>快速： Yarn 缓存了每个下载过的包，所以再次使用时无需重复下载。 同时利用并行下载以最大化资源利用率，因此安装速度更快。</li><li>可靠：使用详细、简洁的锁文件格式和明确的安装算法，Yarn 能够保证在不同系统上无差异的工作。</li><li>安全： 在执行代码之前，Yarn 会通过算法校验每个安装包的完整性。</li></ul><p>而对于<a href="https://engineering.fb.com/2016/10/11/web/yarn-a-new-package-manager-for-javascript/">官方文档</a>中所说：<br>Yarn 是为了弥补 npm 的一些缺陷而出现的。</p><blockquote><p>Yarn is a new package manager that replaces the existing workflow for the npm client or other package managers while remaining compatible with the npm registry. It has the same feature set as existing workflows while operating faster, more securely, and more reliably. — (engineering.fb)[<a href="https://engineering.fb.com/2016/10/11/web/yarn-a-new-package-manager-for-javascript/]">https://engineering.fb.com/2016/10/11/web/yarn-a-new-package-manager-for-javascript/]</a><br>中文大意就是：yarn是一个新的包管理工具并取代现有npm端以及其他包管理器的现有工作流，并同时保持与 npm 注册表兼容。它具有与现有工作流程相同的功能等。</p></blockquote><h3 id="yarn-优点"><a href="#yarn-优点" class="headerlink" title="yarn 优点"></a>yarn 优点</h3><ul><li>速度快。速度快的主要原因：</li></ul><ol><li>并行安装：无论 npm 还是 Yarn 在执行包的安装时，都会执行下载任务。npm 是按照队列执行每个 package，也就是说必须要等到当前 package 安装完成之后，才能继续后面的安装。而 Yarn 是同步执行所有任务，提高了性能。</li><li>离线模式：如果之前已经安装过一个软件包，用Yarn再次安装时之间从缓存中获取，就不用像npm那样再从网络下载了。减少对网络的依赖防止了在网速不好的情况下下载出现问题或者缓慢等情况</li></ol><ul><li>安装版本统一：为了防止拉取到不同的版本，Yarn 有一个锁定文件 (lock file) 记录了被确切安装上的模块的版本号。每次只要新增了一个模块，Yarn 就会创建（或更新）yarn.lock 这个文件。这么做就保证了，每一次拉取同一个项目依赖时，使用的都是一样的模块版本。npm 其实也有办法实现处处使用相同版本的 packages，但需要开发者执行 npm shrinkwrap 命令。这个命令将会生成一个锁定文件，在执行 npm install 的时候，该锁定文件会先被读取，和 Yarn 读取 yarn.lock 文件一个道理。npm 和 Yarn 两者的不同之处在于，Yarn 默认会生成这样的锁定文件，而 npm 要通过 shrinkwrap 命令生成 npm-shrinkwrap.json 文件，只有当这个文件存在的时候，packages 版本信息才会被记录和更新。</li><li>更简洁的输出：npm 的输出信息比较冗长。在执行 npm install 的时候，命令行里会不断地打印出所有被安装上的依赖。相比之下，Yarn 简洁太多：默认情况下，结合了 emoji直观且直接地打印出必要的信息，也提供了一些命令供开发者查询额外的安装信息。</li><li>多注册来源处理：所有的依赖包，不管他被不同的库间接关联引用多少次，安装这个包时，只会从一个注册来源去装，要么是 npm 要么是 bower, 防止出现混乱不一致。</li><li>更好的语义化： yarn改变了一些npm命令的名称，比如 yarn add/remove，感觉上比 npm 原本的 install/uninstall 要更清晰。</li></ul><h3 id="安装过程的步骤"><a href="#安装过程的步骤" class="headerlink" title="安装过程的步骤"></a>安装过程的步骤</h3><ol><li>分析: Yarn 通过向每个注册库（registry）发出请求并递归查找每个依赖项来开始解析依赖项。</li><li>获取: 接下来，Yarn 在全局缓存目录中查找所需的包是否已经下载。如果没有，Yarn 会获取压缩包 并将其放在全局缓存中，这样它就可以脱机工作并且不需要多次下载依赖项。依赖项也可以作为压缩包 放置在源代码管理中，用于完全离线安装。</li><li>链接: 最后，Yarn 通过将全局缓存中所需的所有文件复制到本地node_modules目录中来将所有内容链接在一起。</li></ol><h3 id="yarn-与-npm-命令对比"><a href="#yarn-与-npm-命令对比" class="headerlink" title="yarn 与 npm 命令对比"></a>yarn 与 npm 命令对比</h3><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">npm install === yarn </span><br><span class="line">npm install xxx --save === yarn add xxx</span><br><span class="line">npm uninstall xxx --save === yarn remove xxx</span><br><span class="line">npm install xxx --save-dev === yarn add xxx --dev</span><br><span class="line">npm update --save === yarn upgrade</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;</summary>
        
      
    
    
    
    <category term="知识剖析" scheme="http://example.com/categories/%E7%9F%A5%E8%AF%86%E5%89%96%E6%9E%90/"/>
    
    
    <category term="Node" scheme="http://example.com/tags/Node/"/>
    
    <category term="JavaScript" scheme="http://example.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>vue 高阶内容</title>
    <link href="http://example.com/2021/07/04/%E9%AB%98%E9%98%B6%E8%B5%84%E6%96%991/"/>
    <id>http://example.com/2021/07/04/%E9%AB%98%E9%98%B6%E8%B5%84%E6%96%991/</id>
    <published>2021-07-04T14:12:22.000Z</published>
    <updated>2024-01-02T01:12:08.529Z</updated>
    
    <content type="html"><![CDATA[<h1 id="vue-高阶内容"><a href="#vue-高阶内容" class="headerlink" title="vue 高阶内容"></a>vue 高阶内容</h1><h2 id="vuejs"><a href="#vuejs" class="headerlink" title="vuejs"></a>vuejs</h2><p>vue.js 有个几个核心思：</p><ul><li>虚拟dom </li><li>响应式数据</li><li>组件通信</li></ul><h3 id="虚拟DOM（Virtual-DOM）"><a href="#虚拟DOM（Virtual-DOM）" class="headerlink" title="虚拟DOM（Virtual-DOM）"></a>虚拟<code>DOM</code>（Virtual-DOM）</h3><h4 id="真实DOM与渲染流程"><a href="#真实DOM与渲染流程" class="headerlink" title="真实DOM与渲染流程"></a>真实<code>DOM</code>与渲染流程</h4><p>首先要想了解虚拟DOM，就需要了解什么是真实DOM；<br>如下图为<code>webkit</code>渲染引擎工作流程（概括）</p><p><img src="https://greenhaha.oss-cn-beijing.aliyuncs.com/frontend/assets/img/%E7%9C%9F%E5%AE%9Edom%E6%B8%B2%E6%9F%93%E6%B5%81%E7%A8%8B.jpg" alt="webkit渲染流程"></p><p>无论是什么浏览器的内核引擎，基本的渲染工作流程分为5个步骤：<br><br>创建DOM树 —&gt; 创建style rules（常见css 样式树） —&gt; 构建Render 树  —&gt; 布局Layout  —&gt; Painting</p><ul><li>第一步，构建DOM树：用HTML解析器解析HTML 标签等相关元素，构建出一颗DOM树</li><li>第二步，生成样式表：用css解析器，分析css文件和元素上inline样式（行内样式），生成页面的样式表；</li><li>第三部，构建Render树：将DOM树和样式树关联以来，构建出一颗render树（Attachment）。每个DOM节点都有一个attach方法，接受样式信息，返回一个render对象，这些render对象最终会被构建成一颗render树</li><li>第四步，确定节点坐标：根绝render树结构，为每个render树上的节点确定一个在显示器上的精确坐标</li><li>第五步，绘制页面：根据render树与节点坐标，然后调用每个节点的paint方法，将他们绘制出来</li></ul><blockquote><ul><li><code>DOM</code>树的构建是文档加载完成开始吗？<br><br>  构建<code>DOM</code>树是一个渐进式的构成，为了给用户一个更好的体验，渲染引擎会将内容尽快的显示出来而不是等待所有HTML文档解析完成后才开始构建<code>render</code>树和布局</li><li><code>render</code>树是<code>DOM</code>树和<code>CSS</code>样式表构建完成后开始构建的吗？<br><br>  因为浏览器的解析是渐进式的过程，所有这3个过程在实际进行的时候并不是完全独立的，会有交叉的过程，会边加载，边解析，边渲染</li><li><code>CSS</code>的解析注意点？<br><br>  <code>CSS</code>的解析是从右往左解析嵌套的样式越多，解析的越慢</li><li><code>JS</code>操作真实<code>DOM</code>代价？<br><br>  原生<code>JS</code>操作<code>DOM</code>时，浏览器会按照上面的构建顺序进行构建，当操作了10个<code>DOM</code>节点的时候，浏览器在获取到第一个<code>DOM</code>节点时会直接进行上述的构建顺序构建，并不会获知后面的9个需要变更的<code>DOM</code>节点，当第一个执行完成后依次进行剩下的9个构建，造成了性能浪费，即使计算器硬件一直在迭代，操作的DOM的代价也是很昂贵的，频繁的操作会造成页面的卡顿，影响用的体验</li></ul></blockquote><h4 id="Virtual-DOM基础"><a href="#Virtual-DOM基础" class="headerlink" title="Virtual-DOM基础"></a><code>Virtual-DOM</code>基础</h4><h5 id="虚拟DOM的好处"><a href="#虚拟DOM的好处" class="headerlink" title="虚拟DOM的好处"></a>虚拟<code>DOM</code>的好处</h5><p>虚拟<code>DOM</code>是为了解决浏览器性能问题而设计出来的。如果一次操作更新10个<code>DOM</code>的动作，虚拟<code>DOM</code>不会立即操作<code>DOM</code>，而是将这10次更新的<code>diff</code>内容保存到本地一个<code>JS</code>对象中，最终将这个<code>JS</code>对象一次性<code>attach</code>到<code>DOM</code>树上，再进行后续操作，避免大量无所谓的计算量。所以用<code>JS</code>对象模拟<code>DOM</code>节点的好处就是页面的更新可以先全部反映在<code>JS</code>对象（虚拟<code>DOM</code>）上，操作内存中的<code>JS</code>对象的速度显然要更快，等更新完成后，再将最终<code>JS</code>对象映射到真实<code>DOM</code>，有浏览器去绘制</p><h4 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h4><blockquote><ul><li>如何用<code>JS</code>对象模拟<code>DOM</code>树<br>这是一个真实的<code>DOM</code>树</li></ul></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;virtual-dom&quot;&gt;</span><br><span class="line">&lt;ul id=&quot;list&quot;&gt;</span><br><span class="line">  &lt;li class=&quot;item&quot;&gt;Item 1&lt;/li&gt;</span><br><span class="line">  &lt;li class=&quot;item&quot;&gt;Item 2&lt;/li&gt;</span><br><span class="line">  &lt;li class=&quot;item&quot;&gt;Item 3&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line">&lt;div&gt;Hello World&lt;/div&gt;</span><br><span class="line">&lt;/div&gt; </span><br><span class="line"></span><br></pre></td></tr></table></figure><p>用<code>JavaScript</code>来表示一个DOM节点很容易，需要记住节点的类型、属性、还有子节点：<br><code>element.js</code> 表示节点对象的代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Element virdual-dom 对象定义</span><br><span class="line"> * @param &#123;String&#125; tagName - dom 元素名称</span><br><span class="line"> * @param &#123;Object&#125; props - dom 属性</span><br><span class="line"> * @param &#123;Array&lt;Element|String&gt;&#125; - 子节点</span><br><span class="line"> */</span><br><span class="line">function Element(tagName, props, children) &#123;</span><br><span class="line">    this.tagName = tagName</span><br><span class="line">    this.props = props</span><br><span class="line">    this.children = children</span><br><span class="line">    // dom 元素的 key 值，用作唯一标识符</span><br><span class="line">    if(props.key)&#123;</span><br><span class="line">       this.key = props.key</span><br><span class="line">    &#125;</span><br><span class="line">    var count = 0</span><br><span class="line">    children.forEach(function (child, i) &#123;</span><br><span class="line">        if (child instanceof Element) &#123;</span><br><span class="line">            count += child.count</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            children[i] = &#x27;&#x27; + child</span><br><span class="line">        &#125;</span><br><span class="line">        count++</span><br><span class="line">    &#125;)</span><br><span class="line">    // 子元素个数</span><br><span class="line">    this.count = count</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function createElement(tagName, props, children)&#123;</span><br><span class="line"> return new Element(tagName, props, children);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module.exports = createElement;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>更具<code>element</code>对象的设定，则上面的<code>DOM</code>结构就可以简单表示为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var el = require(&quot;./element.js&quot;)</span><br><span class="line">var ul = el(&#x27;div&#x27;, &#123;id:&#x27;virtual-dom&#x27;&#125;,[</span><br><span class="line">    el(&#x27;ul&#x27;, &#123;id:&#x27;list&#x27;&#125;, [</span><br><span class="line">        el(&#x27;li&#x27;, &#123;class:&#x27;item&#x27;&#125;, [&#x27;Item 1&#x27;]),</span><br><span class="line">        el(&#x27;li&#x27;, &#123;class:&#x27;item&#x27;&#125;, [&#x27;Item 2&#x27;]),</span><br><span class="line">        el(&#x27;li&#x27;, &#123;class:&#x27;item&#x27;&#125;, [&#x27;Item 3&#x27;])</span><br><span class="line">    ]),</span><br><span class="line">    el(&#x27;div&#x27;, &#123;&#125;, [&#x27;Hello World&#x27;])</span><br><span class="line">])</span><br></pre></td></tr></table></figure><p>现在<code>ul</code>就是我们用<code>JavaScript</code>对象表示的DOM结构，输出查看<code>ul</code>对应的数据结构：<br><img src="https://greenhaha.oss-cn-beijing.aliyuncs.com/frontend/assets/img/ul%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.jpg" alt="ul数据结构"></p><blockquote><ul><li>渲染用<code>JS</code>表示的<code>DOM</code>对象<br>由于这是<code>JS</code>表示的<code>DOM</code>对象,在浏览器中是无法表示的，因此需要将<code>ul</code>渲染成页面上真实的<code>DOM</code>结构需要进行渲染函数渲染：</li></ul></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * render 将virdual-dom 对象渲染为实际 DOM 元素</span><br><span class="line"> */</span><br><span class="line">Element.prototype.render = function () &#123;</span><br><span class="line">    var el = document.createElement(this.tagName)</span><br><span class="line">    var props = this.props</span><br><span class="line">    // 设置节点的DOM属性</span><br><span class="line">    for (var propName in props) &#123;</span><br><span class="line">        var propValue = props[propName]</span><br><span class="line">        el.setAttribute(propName, propValue)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    var children = this.children || []</span><br><span class="line">    children.forEach(function (child) &#123;</span><br><span class="line">        var childEl = (child instanceof Element)</span><br><span class="line">            ? child.render() // 如果子节点也是虚拟DOM，递归构建DOM节点</span><br><span class="line">            : document.createTextNode(child) // 如果字符串，只构建文本节点</span><br><span class="line">        el.appendChild(childEl)</span><br><span class="line">    &#125;)</span><br><span class="line">    return el</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>我们通过查看以上<code>render</code>方法,会根据<code>tagName</code>构建一个真正的<code>DOM</code>节点，然后设置这个节点的属性，最后递归的把自己的子节点也构建起来.<br>我们将构建好的<code>DOM</code>结构添加到页面<code>body</code>上面，如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ulRoot = ul.render();</span><br><span class="line">document.body.appendChild(ulRoot); </span><br><span class="line"></span><br></pre></td></tr></table></figure><p>真正渲染到<code>body</code>中真正的<code>DOM</code>结构<br><br><img src="https://greenhaha.oss-cn-beijing.aliyuncs.com/frontend/assets/img/body.jpg" alt="ul真实DOM结构"></p><blockquote><ul><li>比较两颗虚拟<code>DOM</code>树的差异-<code>diff</code> 算法</li></ul></blockquote><p>diff算法用来比较两颗V-dom树的差异。如果要对2颗树完全比较，那么diff算法的事件发展度为<code>O(n^3)</code>, 但是对于前端来说，很少会进行跨越层级的移动<code>DOM</code>元素，所以<code>V-dom</code>只会对同一个层级的元素进行对比。如图所示，<code>div</code>只会和同级的<code>div</code>对比，第二层级的只会跟第二层级的对比，因此复杂度就降为了<code>O(n)</code><br><img src="https://greenhaha.oss-cn-beijing.aliyuncs.com/frontend/assets/img/diff%E6%AF%94%E8%BE%83%E5%9B%BE.jpg" alt="diff算法"></p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;</summary>
        
      
    
    
    
    <category term="知识剖析" scheme="http://example.com/categories/%E7%9F%A5%E8%AF%86%E5%89%96%E6%9E%90/"/>
    
    
    <category term="Node" scheme="http://example.com/tags/Node/"/>
    
    <category term="JavaScript" scheme="http://example.com/tags/JavaScript/"/>
    
    <category term="vue" scheme="http://example.com/tags/vue/"/>
    
    <category term="vdom" scheme="http://example.com/tags/vdom/"/>
    
  </entry>
  
  <entry>
    <title>react-router基础知识</title>
    <link href="http://example.com/2021/06/30/react-router%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <id>http://example.com/2021/06/30/react-router%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</id>
    <published>2021-06-30T12:34:00.000Z</published>
    <updated>2024-01-02T01:12:08.509Z</updated>
    
    <content type="html"><![CDATA[<h1 id="react-router"><a href="#react-router" class="headerlink" title="react-router"></a>react-router</h1><p><img src="https://www.zoo.team/images/upload/upload_fc4d71102131b3c8094572ecd4641111.jpg" alt="router history 核心流程"></p><h2 id="router和route"><a href="#router和route" class="headerlink" title="router和route"></a>router和route</h2><p>react-router主要是用于Url跳转，其核心概念即为Router和Route。</p><p>Router相当于一个容器，用于包裹Route，一个Route即为一个Url。Route里面会包裹一个组件。当在浏览器里输入Url时，就会跳转到相应的Route并显示相关组件。<br><br>一个Router里面可以包含多个Route的伪代码为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;Router&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">      &lt;Route /&gt;</span><br><span class="line">      &lt;Route /&gt;</span><br><span class="line">      &lt;Route /&gt;</span><br><span class="line">  &lt;/div</span><br><span class="line">&lt;Router&gt;</span><br></pre></td></tr></table></figure><blockquote><p>Router要求子组件只能有一个。</p></blockquote><p>Router和History有三个种类型：</p><ul><li>HashHistory和HashRouter</li><li>BrowerHistory和BrowerRouter</li><li>createMemoryHistory和MemoryRouter</li></ul><p>BrowerHistory和HashHistory主要区别在于Url格式：</p><p>使用hashHistory,浏览器的url是这样的：/#/user/liuna?_k=adseis<br>使用browserHistory,浏览器的url是这样的：/user/liuna</p><p>这样看起来当然是browerHistory更好一些，但是它需要server端支持。</p><p>使用hashHistory时，因为有 # 的存在，浏览器不会发送request，react-router 自己根据 url 去 render 相应的模块。</p><ul><li>hashroter<br>一个<code>&lt;Router&gt;</code>使用该URL（即哈希部分window.location.hash），以确保URL与页面UI保持同步。<br>并且官网推荐使用<code>&lt;BrowserHistory&gt;</code></li></ul><blockquote><p>IMPORTANT NOTE: Hash history does not support location.key or location.state. In previous versions we attempted to shim the behavior but there were edge-cases we couldn’t solve. Any code or plugin that needs this behavior won’t work. As this technique is only intended to support legacy browsers, we encourage you to configure your server to work with <BrowserHistory> instead.</p></blockquote><p>eg:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;HashRouter</span><br><span class="line">  basename=&#123;optionalString&#125;</span><br><span class="line">  getUserConfirmation=&#123;optionalFunc&#125;</span><br><span class="line">  hashType=&#123;optionalString&#125;</span><br><span class="line">&gt;</span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">App</span> /&gt;</span></span></span><br><span class="line">&lt;/HashRouter&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="为什么react-router的官方文档推荐使用browserHistory？"><a href="#为什么react-router的官方文档推荐使用browserHistory？" class="headerlink" title="为什么react-router的官方文档推荐使用browserHistory？"></a>为什么react-router的官方文档推荐使用browserHistory？</h3><p>首先 browserHistory 其实使用的是 HTML5 的 History API，浏览器提供相应的接口来修改浏览器的历史记录；而 hashHistory 是通过改变地址后面的 hash 来改变浏览器的历史记录；</p><p>History API 提供了 pushState() 和 replaceState() 方法来增加或替换历史记录。而 hash 没有相应的方法，hash 仅仅是通过使用hashchange方法来监听hash的变化，所以并没有替换历史记录的功能。</p><p>另一个原因是 hash 部分并不会被浏览器发送到服务端，也就是说不管是请求 <a href="http://domain.com/index.html#foo">http://domain.com/index.html#foo</a> 还是 <a href="http://domain.com/index.html#bar">http://domain.com/index.html#bar</a> ，服务只知道请求了 index.html 并不知道 hash 部分的细节。而 History API 需要服务端支持，这样服务端能获取请求细节。</p><p>*BrowserRouter<br>基于H5 History接口的路由<br>eg</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;BrowserRouter</span><br><span class="line">  basename=&#123;optionalString&#125;    </span><br><span class="line">  forceRefresh=&#123;optionalBool&#125;   </span><br><span class="line">  getUserConfirmation=&#123;optionalFunc&#125;</span><br><span class="line">  keyLength=&#123;optionalNumber&#125;  </span><br><span class="line">&gt;</span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">App</span> /&gt;</span></span></span><br><span class="line">&lt;/BrowserRouter&gt;</span><br></pre></td></tr></table></figure><ul><li><p>Link<br>声明式路由组件</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Link to=<span class="string">&quot;/about&quot;</span>&gt;About&lt;/Link&gt;</span><br></pre></td></tr></table></figure></li><li><p>to 导向哪个路由，可以为字符串，也可以为一个对象或者函数</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;Link to=<span class="string">&quot;/courses?sort=name&quot;</span> /&gt;</span><br><span class="line"></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">Link</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">   <span class="attr">to</span>=<span class="string">&#123;&#123;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">     <span class="attr">pathname:</span> &quot;/<span class="attr">courses</span>&quot;,    // 路径</span></span></span><br><span class="line"><span class="tag"><span class="xml">     <span class="attr">search:</span> &quot;?<span class="attr">sort</span>=<span class="string">name</span>&quot;,  // 查询参数</span></span></span><br><span class="line"><span class="tag"><span class="xml">     <span class="attr">hash:</span> &quot;#<span class="attr">the-hash</span>&quot;,   // <span class="attr">hash</span>值</span></span></span><br><span class="line"><span class="tag"><span class="xml">     <span class="attr">state:</span> &#123; <span class="attr">fromDashboard:</span> <span class="attr">true</span> &#125;  // 持久化到<span class="attr">location</span>的状态数据</span></span></span><br><span class="line"><span class="tag"><span class="xml">   &#125;&#125;</span></span></span><br><span class="line"><span class="tag"><span class="xml"> /&gt;</span></span></span><br></pre></td></tr></table></figure><p>一个函数，当前位置作为参数传递给它，并且应该以字符串或对象的形式返回位置表示</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;Link to=&#123;<span class="function"><span class="params">location</span> =&gt;</span> (&#123; ...location, <span class="attr">pathname</span>: <span class="string">&quot;/courses&quot;</span> &#125;)&#125; /&gt;</span><br><span class="line"></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">Link</span> <span class="attr">to</span>=<span class="string">&#123;location</span> =&gt;</span> `$&#123;location.pathname&#125;?sort=name`&#125; /&gt;</span></span><br></pre></td></tr></table></figure><p>其他可用属性</p></li><li><p>replace: 当为true时，单击该链接将替换历史堆栈中的当前条目，而不是添加一个新条目。</p></li><li><p>innerRef 值为函数</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;Link</span><br><span class="line">  to=<span class="string">&quot;/&quot;</span></span><br><span class="line">  innerRef=&#123;<span class="function"><span class="params">node</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// node指向挂载的dom元素, 卸载时候为null</span></span><br><span class="line">  &#125;&#125;</span><br><span class="line">/&gt;</span><br></pre></td></tr></table></figure><p>值为Ref对象</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> anchorRef = React.createRef()</span><br><span class="line"></span><br><span class="line">&lt;Link to=<span class="string">&quot;/&quot;</span> innerRef=&#123;anchorRef&#125; /&gt;</span><br></pre></td></tr></table></figure></li><li><p>component 定制化自己的导航组件</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> FancyLink = React.forwardRef(<span class="function">(<span class="params">props, ref</span>) =&gt;</span> (</span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">a</span> <span class="attr">ref</span>=<span class="string">&#123;ref&#125;</span> &#123;<span class="attr">...props</span>&#125;&gt;</span>  &#123;props.children&#125;<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span></span><br><span class="line">))</span><br><span class="line"></span><br><span class="line">&lt;Link to=<span class="string">&quot;/&quot;</span> component=&#123;FancyLink&#125; /&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>NavLink<br>是 Link 的一个特殊版本，当呈现的元素与当前URL匹配时，它将向该元素添加样式属性。</p></li></ul><p>activeClassName 当元素处于active状态时，类将提供该class。默认的给定class是active。这将与className样式叠加</p><p>activeStyle 内嵌方式声明active状态样式</p><p>exact 布尔类型， 为true是路径完全匹配才会添加active class</p><p>strict 路径匹配是否严格， 为true的话结尾的斜杠会被考虑</p><p>isActive函数， 可以自定义active class添加逻辑</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;NavLink</span><br><span class="line">  to=<span class="string">&quot;/events/123&quot;</span></span><br><span class="line">  isActive=&#123;<span class="function">(<span class="params">match, location</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!match) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// only consider an event active if its event id is an odd number</span></span><br><span class="line">    <span class="keyword">const</span> eventID = <span class="built_in">parseInt</span>(match.params.eventID);</span><br><span class="line">    <span class="keyword">return</span> !<span class="built_in">isNaN</span>(eventID) &amp;&amp; eventID % <span class="number">2</span> === <span class="number">1</span>;</span><br><span class="line">  &#125;&#125;</span><br><span class="line">&gt;</span><br><span class="line">  Event <span class="number">123</span></span><br><span class="line">&lt;/NavLink&gt;</span><br></pre></td></tr></table></figure><ul><li><p>Redirect<br>重定向</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;Route exact path=<span class="string">&quot;/&quot;</span>&gt;</span><br><span class="line">  &#123;loggedIn ? <span class="xml"><span class="tag">&lt;<span class="name">Redirect</span> <span class="attr">to</span>=<span class="string">&quot;/dashboard&quot;</span> /&gt;</span></span> : <span class="xml"><span class="tag">&lt;<span class="name">PublicHomePage</span> /&gt;</span></span>&#125;</span><br><span class="line">&lt;/Route&gt;</span><br></pre></td></tr></table></figure><p>to也可以为对象</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;Redirect</span><br><span class="line">  to=&#123;&#123;</span><br><span class="line">    <span class="attr">pathname</span>: <span class="string">&quot;/login&quot;</span>,</span><br><span class="line">    <span class="attr">search</span>: <span class="string">&quot;?utm=your+face&quot;</span>,</span><br><span class="line">    <span class="attr">state</span>: &#123; <span class="attr">referrer</span>: currentLocation &#125;</span><br><span class="line">  &#125;&#125;</span><br><span class="line">/&gt;</span><br></pre></td></tr></table></figure><p>push属性: 当为真时，重定向将把一个新的条目推送到历史中，而不是取代当前的条目。 from属性: 要重定向的路径名。路径-regexp@^1.7.0能够理解的任何有效URL路径。在to中为模式提供了所有匹配的URL参数。必须包含to中使用的所有参数。不被to使用的其他参数将被忽略。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;Switch&gt;</span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">Redirect</span> <span class="attr">from</span>=<span class="string">&quot;/old-path&quot;</span> <span class="attr">to</span>=<span class="string">&quot;/new-path&quot;</span> /&gt;</span></span></span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;/new-path&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">Place</span> /&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">Route</span>&gt;</span></span></span><br><span class="line">&lt;/Switch&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Redirect with matched parameters</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">Switch</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">Redirect</span> <span class="attr">from</span>=<span class="string">&quot;/users/:id&quot;</span> <span class="attr">to</span>=<span class="string">&quot;/users/profile/:id&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;/users/profile/:id&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">Profile</span> /&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">Route</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">Switch</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>exact属性， 路径是否完全匹配<br>strict属性： 路径匹配是否严格，区分斜杠<br>sensitive属性: 路径匹配是否大小写敏感</p></li><li><p>route<br>path（string）: 路由匹配路径。（没有path属性的Route 总是会 匹配）；<br>exact（bool）：为true时，则要求路径与location.pathname必须完全匹配；<br>strict（bool）：true的时候，有结尾斜线的路径只能匹配有斜线的location.pathname；</p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;Router&gt;</span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">Route</span> <span class="attr">exact</span> <span class="attr">path</span>=<span class="string">&quot;/&quot;</span> <span class="attr">component</span>=<span class="string">&#123;Home&#125;/</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;/news&quot;</span> <span class="attr">component</span>=<span class="string">&#123;NewsFeed&#125;/</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/Router&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果应用的地址是/,那么相应的UI会类似这个样子：</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">Home</span>/&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果应用的地址是/news,那么相应的UI就会成为这个样子：</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">NewsFeed</span>/&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure><ul><li><p>Switch</p></li><li><p>使用场景: 只要有一个 <code>path</code>匹配上了对应的组件, 后续就不会再进行匹配了</p></li><li><p>我们来看下面的路由规则：</p><ul><li>当我们匹配到某一个路径时，我们会发现有一些问题</li><li>比如 /about 路径匹配到的同时，/:userid也被匹配到了，并且最后的一个NoMatch组件总是被匹配到<br><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/741d953942e14e3787c7353fbfa79f70~tplv-k3u1fbpfcp-zoom-1.image"></li></ul></li><li><p>原因是什么呢？默认情况下，react-router中只要是路径被匹配到的Route对应的组件「都会被渲染」</p><ul><li>但是实际开发中, 我们希望有一种排他的思想</li><li>只要匹配到了第一个, 后面就不应该继续匹配了</li><li>这个时候我们可以使用Switch来将所有Route组件进行包裹<br><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5ed2ff8df0a4438c9de616e3e34f1126~tplv-k3u1fbpfcp-zoom-1.image"></li></ul></li></ul>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;</summary>
        
      
    
    
    
    <category term="知识剖析" scheme="http://example.com/categories/%E7%9F%A5%E8%AF%86%E5%89%96%E6%9E%90/"/>
    
    
    <category term="JavaScript" scheme="http://example.com/tags/JavaScript/"/>
    
    <category term="浏览器" scheme="http://example.com/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
    <category term="react" scheme="http://example.com/tags/react/"/>
    
    <category term="react-router" scheme="http://example.com/tags/react-router/"/>
    
  </entry>
  
  <entry>
    <title>浏览器历史堆栈</title>
    <link href="http://example.com/2021/06/20/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8E%86%E5%8F%B2%E5%A0%86%E6%A0%88/"/>
    <id>http://example.com/2021/06/20/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8E%86%E5%8F%B2%E5%A0%86%E6%A0%88/</id>
    <published>2021-06-20T12:35:00.000Z</published>
    <updated>2024-01-02T01:12:08.529Z</updated>
    
    <content type="html"><![CDATA[<h1 id="浏览器历史记录"><a href="#浏览器历史记录" class="headerlink" title="浏览器历史记录"></a>浏览器历史记录</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><ol><li>浏览器历史记录管理栈</li><li>栈中指针指向的页面</li><li>如何生成一条历史记录<br> 1）点击页面中有a标签的href<br> 2）执行location.href = ‘xxx’(location.replace(‘xxx’)生成一条记录取代当前指针所指向的记录)<br> 3）表单提交跳转（注意只能跳到当前窗口）<br> 4）简单粗暴的方法，直接在当前页面的地址栏中输入地址<br> 5）使用pushState方法可以不刷新页面就可以生成一条历史记录，页面URL发生改变</li><li>如何在浏览器中获取当前页面历史记录状态<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">window.history</span><br><span class="line">如下图所示</span><br><span class="line">length:1  // 表示当前页面中会话历史元素的数目，当打开一个标签页时就会自动生成一个历史记录</span><br><span class="line">scrollRestoration:&quot;auto&quot; // 允许web应用程序在历史导航上显示的设置默认滚动恢复行为。此属性可以是自动的(auto)或者是手动的(manual)。</span><br><span class="line">这是一个实验的属性，在IE和Safari下不支持。</span><br><span class="line">state:null // 返回一个表示历史堆栈顶部的状态的值。这是一种可以不必等待popstate事件而查看状态的方式。</span><br><span class="line">指针指向的记录如果state不为null，则显示存进去的state。</span><br></pre></td></tr></table></figure><img src="https://greenhaha.oss-cn-beijing.aliyuncs.com/frontend/assets/img/history.png" alt="history"></li></ol><h2 id="浏览器对历史记录管理的策略"><a href="#浏览器对历史记录管理的策略" class="headerlink" title="浏览器对历史记录管理的策略"></a>浏览器对历史记录管理的策略</h2><p>每次添加新的历史记录的时候，都会在栈的最顶端<br>在测试的时候在当前页面点击打开测试页面的时候都会生成一条历史记录，新的历史记录会压入栈顶。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;demo1.html&quot;</span>&gt;</span>demo1<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line"> <span class="comment">&lt;!--通过location.href=&quot;demo2.html&quot;改变页面地址：--&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">onclick</span>=<span class="string">&quot;changTo(2);&quot;</span>&gt;</span>href=&quot;demo2.html&quot;<span class="tag">&lt;/<span class="name">button</span>&gt;</span>     </span><br><span class="line"> <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;demo3.html&quot;</span> <span class="attr">method</span>=<span class="string">&quot;get&quot;</span> <span class="attr">class</span>=<span class="string">&quot;dib&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> &gt;</span>demo3.html<span class="tag">&lt;/<span class="name">button</span>&gt;</span><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line"> <span class="comment">&lt;!--通过pushState来改变页面地址：--&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">onclick</span>=<span class="string">&quot;push4()&quot;</span>&gt;</span>pushState&quot;demo4.html&quot;<span class="tag">&lt;/<span class="name">button</span>&gt;</span>   </span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">changTo</span>(<span class="params">index</span>) </span>&#123;</span><br><span class="line"> location.href = <span class="string">&#x27;demo&#x27;</span> + index + <span class="string">&#x27;.html&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span>  <span class="title">push4</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> history.pushState(<span class="string">&#x27;hello&#x27;</span>, <span class="string">&#x27;&#x27;</span>, <span class="string">&#x27;/demo4.html&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>点击demo1,demo2,demo3,demo4，然后再点击demo3,demo2,demo1生成的历史记录如下图</p><p><img src="https://greenhaha.oss-cn-beijing.aliyuncs.com/frontend/assets/img/historylist.png" alt="historylist"></p><p>使用history API操作栈指针来获取历史页面</p><p>指针所在的位置会获取当前页面的state，<br>history.back() : 返回上一页<br>history.forword() ： 跳转到前一页<br>history.go(n) ： n可以为正数也可为负数，代表当前指针是向前移动还是向后移动几个位置。如果n大于或小于历史记录的数目时，指针不会发生任何变化。</p><p>下面图片的操作步骤为：先back() =&gt; go(-2) =&gt; go(-2) =&gt; go(2)</p><p><img src="https://greenhaha.oss-cn-beijing.aliyuncs.com/frontend/assets/img/historylist2.png" alt="history2"></p><p>如果此时在demo3的位置点击demo1，历史记录栈会如下所示：<br>历史记录都是插入在栈指针所在位置的后面，前面的记录会被自动删除</p><p><img src="https://greenhaha.oss-cn-beijing.aliyuncs.com/frontend/assets/img/historylist3.png" alt="historylist3"></p><p>历史记录超过了浏览器限制的最大条数（比如chrome、firfox为50条，IE超过了100），栈顶进入一条历史记录，则栈的底端移出去一条。</p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;</summary>
        
      
    
    
    
    <category term="知识剖析" scheme="http://example.com/categories/%E7%9F%A5%E8%AF%86%E5%89%96%E6%9E%90/"/>
    
    
    <category term="浏览器" scheme="http://example.com/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
    <category term="history" scheme="http://example.com/tags/history/"/>
    
  </entry>
  
</feed>
